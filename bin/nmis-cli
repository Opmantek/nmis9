#!/usr/bin/perl
#
#  Copyright 1999-2014 Opmantek Limited (www.opmantek.com)
#
#  ALL CODE MODIFICATIONS MUST BE SENT TO CODE@OPMANTEK.COM
#
#  This file is part of Network Management Information System ("NMIS").
#
#  NMIS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  NMIS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with NMIS (most likely in a file named LICENSE).
#  If not, see <http://www.gnu.org/licenses/>
#
#  For further information on NMIS or for a license other than GPL please see
#  www.opmantek.com or email contact@opmantek.com
#
#  User group details:
#  http://support.opmantek.com/users/
#
# *****************************************************************************
use strict;
our $VERSION = "9.0.12";


use FindBin;
use lib "$FindBin::Bin/../lib";

use POSIX qw();
use File::Basename;
use Getopt::Long;
use File::Spec;
use Data::Dumper;
use Term::ReadKey;
use Time::Local;								# report stuff - fixme needs rework!
use Time::HiRes;

# this imports the LOCK_ *constants (eg. LOCK_UN, LOCK_EX), also the stat modes
use Fcntl qw(:DEFAULT :flock :mode);
use Errno qw(EAGAIN ESRCH EPERM);

use NMISNG;
use NMISNG::Log;
use NMISNG::Util;
use NMISNG::Outage;
use NMISNG::Auth;

use Compat::NMIS;

my $PROGNAME = basename($0);
my $debugsw = 0;
my $helpsw = 0;
my $quietsw = 0;
my $usagesw = 0;
my $verbosesw = 0;
my $versionsw = 0;

 die unless (GetOptions('debug:i'    => \$debugsw,
                        'help'       => \$helpsw,
                        'quiet'      => \$quietsw,
                        'usage'      => \$usagesw,
                        'verbose'    => \$verbosesw,
                        'version'    => \$versionsw));

# For the Version mode, just print it and exit.
if (${versionsw}) {
	print "$PROGNAME version=$NMISNG::VERSION\n";
	exit (0);
}
if ($helpsw) {
   help();
   exit(0);
}

my $usage       = "Usage: $PROGNAME [option=value...] <act=command>

 act=fixperms
 act=gettmp
 act=config-backup
 act=ensure-indexes
 act=noderefresh
 act=daemon-status (or act=status)

 act=schedule [at=time] <job.type=activity> [job.priority=0..1] [job.X=....]
 act=schedule-help for more detailed help
 act=list-schedules [verbose=t|f] [only=active|queued] [job.X=...]
 act=delete-schedule id=<schedule_id|ALL> [job.X=...]
 act=abort id=<schedule_id>

 act=purge [simulate=t|f] [info=t|f]
 act=dbcleanup [simulate=t|f] [info=t|f] [use_performance_query=t|f]

 act=run-reports period=<day|week|month> type=<all|times|health|top10|outage|response|avail|port>

 act=list-outages [filter=<filter> ...]
 act=create-outage [outage.A=B... outage.X.Y=Z...]
 act=update-outage id=<outid> [outage.A=B... outage.X.Y=Z...]
 act={delete-outage|show-outage} id=<outid>
 act=check-outages [node=<nodename>|uuid=<uuid>] [time=<time>]
 act=outage-help for more detailed help
 act=collect-performance-data 
 act=collect-top-data
 
 act=clean-sessions user=<username>
 act=get-sessions user=<username>
 act=set-last-login user=<username> last_login=<last_login>
 act=unlock-user user=<username>
 
\n";


my $scheduleusage = qq|Job Scheduling:

act=list-schedules: displays overview of pending and active jobs;
  verbose=t causes job arguments to be displayed fully.
  only=queued shows pending jobs only,
  only=active shows only jobs that are in progress.

act=delete-schedule: removes a schedule record from the database
act=abort: like delete-schedule but also terminates any worker process that is
  processing that job.

  if id=ALL is given, then additional job.X properties can be used
  to select particular schedule records.

act=schedule: inserts a new job record into the database.

Supported Arguments for Schedule Creation:

at: optional time argument for the job to commence, default is now.
  Time format is described in man at

job.type: job type, required, one of: collect update services
  thresholds escalations metrics configbackup purge dbcleanup
  selftest permission_test or plugins delete edit 

job.priority: optional number between 0 (lowest) and 1 (highest) job priority.
 default is 1 for manually scheduled jobs

For collect/update/services:
job.node: node name
job.uuid: node uuid
job.group: group name
  All three are optional and can be repeated. If none are given,
  all active nodes are chosen.

For collect:
job.wantsnmp, job.wantwmi: optional, default is 1.

For plugins:
job.phase: required, one of update or collect
job.uuid: required, one or more node uuids to operate on

job.force: optional, if set to 1 certain job types ignore scheduling policies
 and bypass any cached data.
job.verbosity: optional, verbosity level for just this one job.
 must be one of 1..9, debug, info, warn, error or fatal.
job.output: optional,  if given as /path/name_prefix or name_prefix
 then all log output for this job is saved in a separate file.
 path is relative to log directory, and actual file is
 name_prefix-<timestamp>.log.
job.tag: somerandomvalue
 Optional, used for post-operation plugin grouping.

|;

my $outageusage = qq|Outage Management:

list-outages: shows overview of selected outage schedules
show-outage: displays the details for one outage instance

create-outage: creates new outage schedule
update-oudage: updates existing outage schedule
 only the given outage.A, outage.X.Y properties are changed.

check-outage: reports which outages would apply at the given time
 (or now) and  for one node (if given) or all nodes

Supported Arguments for Outage Creation:

outage.description: free-form textual description.
outage.change_id: change management ticket identifier, used for event tagging

outage.frequency: one of 'once', 'daily', 'weekly' or 'monthly'
outage.start, outage.end: date and time of outage start and end,
 format depends on frequency
  daily: "HH:MM" or "HH:MM:SS". 24:00 is allowed for end.
  weekly: "MDAY HH:MM" or "MDAY HH:MM:SS", MDAY one of 'Mon', 'Tue' etc.
  monthly: "D HH:MM:SS", "-D HH:MM:SS", "D HH:MM", "-D HH:MM"
   D is the numeric day of the month, 1..31.  -D counts from the end of the month,
   -1 is the last day of the month, -2 the second to last etc.
  once: ISO8601 date time recommended,
   e.g. 2017-10-31T03:04:26+0000

outage.options: optional key=values to adjust NMIS' behaviour during an outage
outage.selector: any number of criteria for selecting devices for this outage
  selector keys: node.X or config.Y, node config or global config properties
  selector values: single string, /regex string/ or array or single strings.
  arrays must be given as separate indexed entries.
  all selectors must match for a node to be subject to the outage.

example: $PROGNAME act=create-outage \\
outage.description='certain nodes are busy each month start' \\
outage.change_id='ticket #42' \\
outage.frequency=monthly outage.start="1 12:00" outage.end="1 13:30" \\
outage.selector.node.group.0="busybodies" \\
outage.selector.node.group.1="alsobad"\n\n|;

my $Q = NMISNG::Util::get_args_multi(@ARGV);

if ($usagesw) {
   print($usage);
   exit(0);
}

if (!@ARGV || !$Q->{act})
{
    help();
    exit(0);
}

my $debug   = $debugsw;
my $quiet   = $quietsw;
my $verbose = $verbosesw;
$debug      = $Q->{debug}                                            if (exists($Q->{debug}));   # Backwards compatibility
$quiet      = NMISNG::Util::getbool_cli("quiet", $Q->{quiet}, 0)     if (exists($Q->{quiet}));   # Backwards compatibility
$verbose    = NMISNG::Util::getbool_cli("verbose", $Q->{verbose}, 0) if (exists($Q->{verbose})); # Backwards compatibility

my $customconfdir = $Q->{dir}? $Q->{dir}."/conf" : undef;
my $C      = NMISNG::Util::loadConfTable(dir => $customconfdir,
																				 debug => $debug);
die "no config available!\n" if (ref($C) ne "HASH" or !keys %$C);

# the db config needs adjusting before dbcleanup is attempted: the aggregations
# often take longer than the default 5s...and that param cannot be set on live connections.
if ($Q->{act} eq "dbcleanup")
{
	$C->{db_query_timeout} = 1000*300;	# 5 minutes max
}

# log to stderr if debug is given
my $logfile = $C->{'<nmis_logs>'} . "/cli.log";
my $error = NMISNG::Util::setFileProtDiag(file => $logfile) if (-f $logfile);
warn "failed to set permissions: $error\n" if ($error);

# use debug, or info arg, or configured log_level
my $logger = NMISNG::Log->new( level => NMISNG::Log::parse_debug_level(
																 debug => $debug ) // $C->{log_level},
																 path  => ($debug > 0)? undef : $logfile);

# Get temporary directory
my $tmp = NMISNG::Util::getTmpDir();

# this opens a database connection
my $nmisng = NMISNG->new(
	config => $C,
       log => $logger,
);

# for audit logging
my ($thislogin) = getpwuid($<); # only first field is of interest

# show the daemon status
if ($Q->{act} =~ /^(daemon[-_])?status$/)
{
	my $pt = Proc::ProcessTable->new(enable_ttys => 0);
	# opcharts 3 'nmisd' calls itself 'nmisd',
	# 'nmisd worker' or 'nmisd collector <something>' - exclude these
	my %ours = ( map { ($_->pid => $_) }
							 (grep($_->cmndline =~ /^nmisd\.(fping|scheduler|worker).*$/,
										 @{$pt->table})));
	die "No NMIS9 daemons running!\n" if (!keys %ours);

	my $fmt = (-t \*STDOUT? "%-16s%-48s\n" : "%s\t%s\n");
	printf($fmt,"PID","Daemon Role") if (-t \*STDOUT);
	for my $pid (sort keys %ours)
	{
		printf($fmt, $pid, $ours{$pid}->cmndline);
	}
	exit 0;
}
elsif ($Q->{act} =~ /^schedule[_-]help$/)
{
	print $scheduleusage;
	exit 0;
}
# scheduling of actions, overriding/augmenting what nmisd automatically schedules
elsif ($Q->{act} eq "schedule")
{
	# no args at all? print help
	my $what = $Q->{"job.type"};
	if (!defined $what)
	{
		print $scheduleusage;
		exit 1;
	}
	my $priority = $Q->{"job.priority"} // 1; # default assumption is non-automatic custom job, hence max priority
	my $verbosity = $Q->{"job.verbosity"};
	my $customlog = $Q->{"job.output"};
	my $sharedtag = $Q->{"job.tag"}; # optional, for collect or update

	# at=time or now
	my $when = $Q->{at}? NMISNG::Util::parseDateTime($Q->{at}) || NMISNG::Util::getUnixTime($Q->{at}) : Time::HiRes::time;
	die "Invalid time specification \"$Q->{at}\"!\n" if (!$when);

	my %jobargs;
	for my $match (grep(/^job\..+$/, keys %$Q))
	{
		next if ($match =~ /^job\.(type|priority|verbosity|output|tag|data|keeprrds)$/); # these don't go into the job args
		my $argument = $match;
		$argument =~ s/^job\.//;
		$jobargs{$argument} = (($argument eq "force") # for force we'd need 1/0
                                                     ? NMISNG::Util::getbool_cli("force", $Q->{$match}, 1)
                                                     : $Q->{$match});
	}

	# perform any necessary arg conversions and expansions
	# collect/services/update, find the nodes implied and schedule a separate job for each
	# post-update/collect plugins require a list of node uuids - should normally be left to the daemon to schedule
	if ($what =~ /^(collect|update|services|plugins)$/)
	{
		my @filters;
		
		for my $filterable (qw(node name group uuid)) # job.node === job.name === node name
		{
			my $thisjob = $jobargs{$filterable};
			my @arr = split(",", $thisjob);
			my @inputs = ref(\@arr) eq "ARRAY"? @arr: $jobargs{$filterable} // ();
			map { push @filters, { ($filterable eq "node"? "name" :
															$filterable =~ /^(name|uuid)$/?
															$filterable : "configuration.$filterable") => $_ }; } (@inputs);
		}
		my $possibles = $nmisng->expand_node_selection(@filters);

		die "Failed to query nodes: ".$possibles->error."\n" if ($possibles->error);
		die "No nodes found matching your selectors!\n" if (!$possibles->count);

		map { delete $jobargs{$_} } (qw(name node group)); # no longer needed, uuid is what counts
		if ($what eq "collect")
		{
			$jobargs{wantwmi} = NMISNG::Util::getbool_cli("job.wantwmi", $Q->{"job.wantwmi"}, 1);
			$jobargs{wantsnmp} = NMISNG::Util::getbool_cli("job.wantsnmp", $Q->{"job.wantsnmp"}, 1);
		}

		if ($what eq "plugins")			# one combined job with the node uuids passed in
		{
			$jobargs{uuid} = [ map { $_->{uuid} } (@{$possibles->data}) ];

			my ($error,$jobid) = $nmisng->update_queue(
				jobdata => {
					type => $what,
					time => $when,
					priority => $priority,
					verbosity => $verbosity,
					output => $customlog,
					in_progress => 0,					# somebody else is to work on this
					args => \%jobargs });
			die "Failed to add schedule: $error\n" if ($error);
			print "Job $jobid created for type $what and ".$possibles->count." nodes.\n" if (!$quiet);
		} 
		# collect/update/services need separate scheduling for each node
		else
		{
			for my $onenode (@{$possibles->data})
			{
				$jobargs{uuid} = $onenode->{uuid};

				my ($error,$jobid) = $nmisng->update_queue(
					jobdata => {
						type => $what,
						time => $when,
						priority => $priority,
						verbosity => $verbosity,
						output => $customlog,
						in_progress => 0,					# somebody else is to work on this
						tag => $sharedtag,
						args => \%jobargs });
				die "Failed to add schedule: $error\n" if ($error);
				print "Job $jobid created for node $onenode->{name} ($onenode->{uuid}) and type $what.\n" if (!$quiet);
			}
		}
	}
	# none of these take any job arguments
	elsif ($what =~ /^(selftest|permission_test|configbackup|purge|dbcleanup|escalations|metrics|thresholds)$/)
	{
		my ($error,$jobid) = $nmisng->update_queue(
			jobdata => {
				type => $what,
				time => $when,
				priority => $priority,
				verbosity => $verbosity,
				output => $customlog,
				in_progress => 0,					# somebody else is to work on this
			});
		die "Failed to add schedule: $error\n" if ($error);
		print "Job $jobid created for type $what.\n" if (!$quiet);
	}
	else
	{
		die "Unrecognized job type \"$what\"!\n";
	}

	exit 0;
}
# print in-progess and queued jobs, and automatically scheduled stuff
# shorten the args unless verbose=true
# also supports job.X=... selectors
elsif ($Q->{act} =~ /^list[_-]schedules?$/)
{
	my %queryargs = (sort => { time => 1 });
	for my $match (grep(/^job\..+$/, keys %$Q))
	{
		my $what = $Q->{$match};
		my $where = ($match =~ /^job\.(type|priority|verbosity|output|tag)$/)?  # these don't go into args.X
				$1 : ($match =~ s/^job\./args./ && $match); # the rest does
		$queryargs{$where} = $what;
	}

	my $queued = $nmisng->get_queue_model(%queryargs);
	if (my $fault = $queued->error)
	{
		die "Failed to search queue: $fault\n";
	}

	my $queuedjobs = $queued->data;
	if (!@$queuedjobs)
	{
		print STDERR "No activities scheduled or in-progress.\n" if (!$quiet);
	}
	else
	{
		if (!defined($Q->{only}) or $Q->{only} eq "active")
		{
			my $fmt = "%-26s%-26s%-48s%-20s%s\n";
			printf("Active Jobs:\n$fmt",
						 "Id","When","Status","What",
						 "Parameters");

			my $some;
			for my $active (grep($_->{in_progress}, @$queuedjobs))
			{
				$some = 1;

				my $printable = $active->{args}?
					Data::Dumper->new([$active->{args}])->Terse(1)->Indent(0)->Pair("=")->Dump :  "";
				$printable = "<output truncated, too long>"
						if (!$verbose && length($printable) > 64);

				printf($fmt,
							 $active->{_id},
							 scalar(localtime($active->{time})),
							 ("In Progress since "
								.localtime($active->{in_progress})
								. ($verbose? " (Worker $active->{status}->{pid}) " : "")),
							 $active->{type},
							 $printable);
			}
			print "No active jobs at this time.\n" if (!$some);
			print "\n";
		}

		if (!defined($Q->{only}) or $Q->{only} eq "queued")
		{
			my $fmt = "%-26s%-26s%-12s%-20s%s\n";
			printf("Queued Jobs:\n$fmt",
						 "Id","When","Priority","What","Parameters");

			my $some;
			for my $sched (grep(!$_->{in_progress}, @$queuedjobs))
			{
				$some = 1;
				my $printable = $sched->{args}?
						Data::Dumper->new([$sched->{args}])->Terse(1)->Indent(0)->Pair("=")->Dump :  "";
				$printable = "<output truncated, too long>"
						if (!$verbose && length($printable) > 64);

				printf($fmt,
							 $sched->{_id},
							 scalar(localtime($sched->{time})),
							 $sched->{priority},
							 $sched->{type},
							 $printable);
			}

			print "No queued jobs at this time.\n" if (!$some);
			print "\n";
		}
	}

	if (!defined $Q->{only})
	{
		# show the scheduled periods for the known automatic actions
		my $fmt = "%-30s%s\n";
		printf("\nAutomatic Schedule:\n$fmt", "Operation","Frequency");
		for ( [ "escalations", "Escalations" ],
					[ "thresholds", "Threshold Computations" ],
					[ "metrics", "Metrics Computation" ],
					[ "configbackup", "Configuration Backup"],
					[ "purge", "Old File Purging"],
					[ "dbcleanup", "Database Cleanup"],
					[ "selftest", "Selftest" ],
					[ "permission_test", "File Permission Test" ],
				)
		{
			my ($key, $label) = @$_;
			# thresholds are usually computed during a node's collect operation
			next if ($key eq "thresholds"
							 and
							 (!NMISNG::Util::getbool($C->{global_threshold}) # totally disabled
								or NMISNG::Util::getbool($C->{threshold_poll_node}))); # or done with node

			my $freq = defined($C->{"schedule_$key"}) && $C->{"schedule_$key"} > 0?
					NMISNG::Util::period_friendly($C->{"schedule_$key"}) : "Disabled";

			printf($fmt,$label, $freq);
		}
	}

	exit 0;
}
# delete-schedule removes one or more specific scheduled job entry (if identified by id),
# or many/all if given the id=ALL and any number of job.XYZ filters.
#
# abort does that and terminates the worker process that is working on that job
elsif ($Q->{act} =~ /^(delete[_-]schedule|abort)$/)
{
	my $wantabort = ($1 eq "abort");
	my @todo;

	# by filter or wholesale?
	if ($Q->{id} eq "ALL")
	{
		# look for any job.* values and try and filter by themn
		my %queryargs;
		foreach my $key (keys %$Q)
		{
			if( $key =~ /^job\.(.*)$/)
			{
				$queryargs{$1} = $Q->{$key};
			}
		}
		my $jobs = $nmisng->get_queue_model(%queryargs);

		if (my $fault = $jobs->error)
		{
			die "Failed to lookup schedule: $fault\n";
		}
		@todo = map { $_->{_id}->{value} } (@{$jobs->data()});
	}
	elsif ($Q->{id})
	{
		@todo = ref($Q->{id}) eq "ARRAY"? @{$Q->{id}}: $Q->{id};
	}
	else
	{
		die "No schedule ID given!\n";
	}

	for my $id (@todo)
	{
		if ($wantabort)
		{
			my $job = $nmisng->get_queue_model(id => $id);
			if (my $fault = $job->error)
			{
				die "Failed to lookup schedule: $fault\n";
			}
			die "No matching schedule exists!\n" if ($job->count != 1);

			my $thejob = $job->data->[0]; 	# we want the first and only schedule entry
			if ($thejob->{in_progress}
					&& ref($thejob->{status}) eq "HASH"
					&& defined($thejob->{status}->{pid})
					&& $thejob->{status}->{pid} > 1
					&& kill(0,$thejob->{status}->{pid}))
			{
				my $shootme = $thejob->{status}->{pid};
				# let's be careful: is it an nmis process?
				my $pt = Proc::ProcessTable->new(enable_ttys => 0);
				my %bypid = map { ($_->pid => $_) } (@{$pt->table});

				if (defined $bypid{$shootme}
						&& $bypid{$shootme}->cmndline =~ /^nmisd worker/)
				{
					print STDERR "Terminating process $shootme (".$bypid{$shootme}->cmndline.") which owns job $id\n";
					kill("TERM", $shootme);	 # polite
					Time::HiRes::sleep(0.5);
					kill(0,$shootme) && kill("KILL", $shootme); # then firm if required
				}
			}
		}

		my $error = $nmisng->remove_queue(id => $id) if ($id);
		# Don't die, continue the loop
		print "$error\n" if ($error);
		print "Removed job with id $id \n" if (!$error);
	}
	exit 0;
}

# outage management
elsif ($Q->{act} =~ /^outage[_-]help$/)
{
	print $outageusage;
	exit 0;
}
# overview of all or selected outages
elsif ($Q->{act} =~ /^list[_-]outages$/)
{
	my %filter;
	for my $maybe (keys %$Q)
	{
		next if ($maybe !~ /^(id|description|change_id|frequency|start|end|options\.nostats|selector.(config|node).[^=]+)$/);

		if ($Q->{$maybe} =~ m!^/(.*)/(i)?$!)
		{
			my ($re,$options) = ($1,$2);
			$filter{$maybe} = ($options? qr{$re}i : qr{$re});
		}
		else
		{
			$filter{$maybe} =  $Q->{$maybe};
		}
	}

	my $res = NMISNG::Outage::find_outages(filter => \%filter);
	die "Error: failed to find outages: $res->{error}\n" if (!$res->{success});

	if (!@{$res->{outages}})
	{
		print STDERR "No matching outages.\n" if (!$quiet);
		exit 0;
	}

	# uuids are 36c wide, align only if output is to tty
	my $fmt = (-t \*STDOUT? "%36s\t%16s\t%30s\t\%10s\t%20s\t%20s\n" : "%s\t%s\t%s\t%s\t%s\t%s\n");
	# header only if tty
	printf($fmt, "ID", "Change ID", "Description",
				 "Frequency", "Start", "End") if (-t \*STDOUT);

	for my $orec (@{$res->{outages}})
	{
		printf($fmt,
					 $orec->{id},
					 $orec->{change_id},
					 $orec->{description},
					 $orec->{frequency},
					 ($orec->{frequency} eq "once" && $orec->{start} =~ /^\d+(\.\d+)?$/?
						POSIX::strftime("%Y-%m-%dT%H:%M:%S", localtime($orec->{start})) : $orec->{start}),
					 ($orec->{frequency} eq "once" && $orec->{end} =~ /^\d+(\.\d+)?$/?
						POSIX::strftime("%Y-%m-%dT%H:%M:%S", localtime($orec->{end})) : $orec->{end})
					 , );

	}
}
# remove one outage by id
elsif ($Q->{act} =~ /^delete[_-]outage$/)
{
	my $outid = $Q->{"id"};
	die "Error: Cannot delete outage without id argument!\n\n$outageusage\n" if (!$outid);

	my $res = NMISNG::Outage::remove_outage(id => $outid, meta => { user => $thislogin });
	die "Error: failed to remove outage: $res->{error}\n" if (!$res->{success});
}
# show one outage structure in flattened form
elsif ($Q->{act} =~ /^show[_-]outage$/)
{
	my $outid = $Q->{"id"};
	die "Error: Cannot show outage without id argument!\n\n$outageusage\n" if (!$outid);

	my $res = NMISNG::Outage::find_outages(filter => { id => $outid });
	die "Error: Failed to lookup outage: $res->{error}" if (!$res->{success});
	# there can be at most one with this id
	my $theoneandonly = $res->{outages}->[0];
	die "Error: No outage with id $outid exists!\n" if (!$theoneandonly);

	my ($error, %flatearth) = NMISNG::Util::flatten_dotfields($theoneandonly);
	for my $k (sort keys %flatearth)
	{
		my $val = $flatearth{$k};
		print "$k=$flatearth{$k}\n";
	}
	exit 0;
}
elsif ($Q->{act} =~ /^update[_-]outage$/)
{
	# update: id required
	my $outid = $Q->{id};

	die "Error: Cannot update outage without id argument!\n\n$outageusage\n"
			if (!$outid);

	# look it up, amend with given values
	my $res = NMISNG::Outage::find_outages(filter => { id => $outid });
	die "Error: Failed to lookup outage: $res->{error}" if (!$res->{success});
	# there can be at most one with this id
	my $updateme = $res->{outages}->[0];
	die "Error: No outage with id $outid exists!\n" if (!$updateme);

	my $dosomething;
	for my $name (grep(/^outage\./, keys %$Q))
	{
		my $dotted = $name; $dotted =~ s/^outage\.//;
		$updateme->{$dotted} = (defined($Q->{$name}) && $Q->{$name} ne "")?
				$Q->{$name} : undef;
		++$dosomething;

		my $error = NMISNG::Util::translate_dotfields($updateme);
		die "Error: translation of arguments failed: $error\n" if ($error);
	}
	die "Error: No changes for outage \"$outid\"!\n" if (!$dosomething);

	$updateme->{id} = $outid;			# bsts...
	$res = NMISNG::Outage::update_outage(%$updateme, meta => { user => $thislogin });
	die "Error: Failed to update \"$outid\": $res->{error}\n" if (!$res->{success});
}
elsif ($Q->{act} =~ /^create[_-]outage$/)
{
	# create w/o args? show help
	die "Error: Cannot create outage without arguments!\n\n$outageusage\n"
			if (!grep(/^outage\./, keys %$Q));

	my ($addables,%createme);
	for my $name (grep(/^outage\./, keys %$Q))
	{
		my $dotted = $name; $dotted =~ s/^outage\.//;
		$createme{$dotted} = (defined($Q->{$name}) && $Q->{$name} ne "")?
				$Q->{$name} : undef;
		++$addables;

		my $error = NMISNG::Util::translate_dotfields(\%createme);
		die "Error: translation of arguments failed: $error\n" if ($error);
	}
	die "Error: No valid arguments for creating an outage!\n\n$outageusage\n" if (!$addables);
	# make sure the user doesn't pass a clashing id arg!
	$createme{id} //= $Q->{id} if (defined $Q->{id});
	if ($createme{id})
	{
		my $clash = NMISNG::Outage::find_outages(filter => { id => $createme{id} });
		die "Error: Failed to lookup outage: $clash->{error}" if (!$clash->{success});
		die "Error: Cannot create outage with id \"$createme{id}\": already exists!\n"
				if (@{$clash->{outages}});
	}

	my $res = NMISNG::Outage::update_outage(%createme, meta => { user => $thislogin });
	die "Error: Failed to create: $res->{error}\n" if (!$res->{success});

	# print the created id if not quiet, and without fluff if not tty
	print((-t \*STDOUT? "Created outage \"$res->{id}\"\n" : $res->{id}."\n"))
			if (!$quiet);
	exit 0;
}
elsif ($Q->{act} =~ /^check[_-]outages$/)
{
	my $nodeobj;									# particular node?

	if (my $nodename = $Q->{node} or my $uuid = $Q->{uuid})
	{
		my %nodesel;
		$nodesel{name} = $nodename if ($nodename);
		$nodesel{uuid} = $uuid if ($uuid);

		$nodeobj = $nmisng->node(%nodesel);
		die "Invalid node/uuid arguments, no matching node exists!\n"
				if (!$nodeobj);
	}

	my $when = $Q->{time} || time;
	if ($when !~ /^\d+(\.\d+)?$/)
	{
		$when = NMISNG::Util::parseDateTime($when) || NMISNG::Util::getUnixTime($when);
	}


	my $res = NMISNG::Outage::check_outages( node => $nodeobj, nmisng => $nmisng, time => $when);
	die "Failed to check outages: $res->{error}\n" if (!$res->{success});


	print "\nRelevant outages"
			.($nodeobj? (" for node ".$nodeobj->name.", "):"")
			." at time "
			.localtime($when).":\n";

	for (["Past:", "past"], ["Future:", "future"], ["Current: ", "current" ])
	{
		my ($tag, $source) = @$_;

		if (!@{$res->{$source}})
		{
			print "$tag None\n";
		}
		else
		{
			my @output;
			for my $match (@{$res->{$source}})
			{
				my $msg = "\n\t\"$match->{description}\" ($match->{id})\n\t$match->{frequency} from '"
						. ($match->{start} =~ /^\d+(\.\d+)?$/? scalar(localtime($match->{start})) : $match->{start})
						."' to '"
						. ($match->{end} =~ /^\d+(\.\d+)?$/? scalar(localtime($match->{end})) : $match->{end})."'";
				$msg .= "\n\t(actual '".localtime($match->{actual_start}). "' to '".localtime($match->{actual_end})."')"
						if ($match->{actual_start});
				push @output, $msg;
			}
			print "$tag ".join("\n\n", @output)."\n";
		}
	}
	print "\n";
	exit 0;
}

elsif ($Q->{act} =~ /^run[_-]reports$/)
{
	my ($period, $reporttype) = @{$Q}{"period","type"};

	if ($period !~ /^(day|week|month)$/i) {
		print "\033[1mUnknown date period selected! ('period=$period')\033[0m\n\n";
		help(3);
		exit(255);
	}
	if ($reporttype !~ /^(all|times|health|top10|outage|response|avail|port)$/) {
		print "\033[1mUnknown report type selected! ('type=$reporttype')\033[0m\n\n";
		help(3);
		exit(255);
	}

	my $reportdir = $C->{report_root};
	NMISNG::Util::createDir($reportdir) if (!-d $reportdir);
	my ($start, $end, $outfile);
	my $time = time();

	# fixme9: is this warning still applicable at all?
	# attention: the file naming logic here must match purge_files() in cgi-bin/reports.pl,
	# or unwanted ancient reports will be left behind!
	if ($period eq 'day')
	{
		my ($s,$m,$h) = (localtime($time))[0..2];
		$end = $time-($s+($m*60)+($h*60*60));
		$start = $end - (60*60*24); # yesterday

		$outfile= POSIX::strftime("day-%d-%m-%Y-%a.html",localtime($start));
	}
	elsif ($period eq 'week')
	{
		my ($s,$m,$h,$wd) = (localtime($time))[0..2,6];
		$end = $time-($s+($m*60)+($h*60*60)+($wd*60*60*24));
		$start = $end - (60*60*24*7); # last weekend

		$outfile = POSIX::strftime("week-%d-%m-%Y-%a.html",localtime($start));
	}
	elsif ($period eq 'month')
	{
		my ($m,$y) = (localtime($time))[4,5];
		$end = timelocal(0,0,0,1,$m,$y);
		$m -= 1;
		if ($m < 0) {
			$m = 11; $y -= 1;
		}
		$start = timelocal(0,0,0,1,$m,$y);

		$outfile =  POSIX::strftime("month-%m-%Y.html",localtime($start));
	}

	my @todos = ($reporttype eq "all"? (qw(times health top10 outage response avail port)) : $reporttype);
	for my $thisreport (@todos)
	{
		my $file = "$reportdir/${thisreport}-${outfile}";
		my $status = system("$C->{'<nmis_cgi>'}/reports.pl", "report=$thisreport",
												"start=$start", "end=$end", "outfile=$file") >> 8;
		$nmisng->log->error("generating report=$thisreport file=$file failed: $!")
				if ($status);
		NMISNG::Util::setFileProtDiag(file =>$file) if (-f $file);
	}
}
elsif ($Q->{act} =~ /^config[_-]backup$/)
{
	my $res = $nmisng->config_backup;
	die "$res->{error}\n" if (!$res->{success});

	print "Configuration Backup saved as \"$res->{file}\".\n" if ($Q->{info});
}
elsif ($Q->{act} eq 'purge')
{
	my $simulate = NMISNG::Util::getbool_cli("simulate", $Q->{simulate}, 0);
	my $info = NMISNG::Util::getbool_cli("info", $Q->{info}, 0);
	my $res = $nmisng->purge_old_files(simulate => $simulate);
	die "$res->{error}\n" if (!$res->{success});
	print join("\n", @{$res->{info}}),"\n" if ($Q->{info} or $simulate);

	$res = NMISNG::Outage::purge_outages(nmisng => $nmisng,
																			 simulate => $simulate);
	die "$res->{error}\n" if (!$res->{success});
	if ($res->{message} eq 'No outages exist.')
	{
		print $res->{message} . "\n";
	} else {
		print join("\n", @{$res->{info}}),"\n" if ($info or $simulate);
	}	
}
elsif ($Q->{act} eq "dbcleanup")
{
	my $simulate = NMISNG::Util::getbool_cli("simulate", $Q->{simulate}, 0);
	my $info = NMISNG::Util::getbool_cli("info", $Q->{info}, 0);
	my $use_performance_query = NMISNG::Util::getbool_cli("use_performance_query", $Q->{use_performance_query}, 0);
	my $res;
	if ($use_performance_query) {
		$res = $nmisng->dbcleanup(simulate => $simulate, use_performance_query => $use_performance_query);
	}
	else {
		$res = $nmisng->dbcleanup(simulate => $simulate);
	}

	print join("\n", @{$res->{info}}),"\n" if ($info or $simulate);
}
elsif ($Q->{act} eq 'noderefresh')
{
	noderefresh();
}
elsif ($Q->{act} =~ /collect[-_]performance[-_]data/)
{
	collectPerformanceData();
}
elsif ($Q->{act} =~ /collect[-_]top[-_]data/)
{
	collectTopData();
}
elsif ($Q->{act} =~ /ensure[_-]indexes/)
{
	print $nmisng->ensure_indexes();
}
elsif ($Q->{act} eq "gettmp")
{
	print "$tmp";
}
elsif ($Q->{act} eq "fixperms")
{
	if ($verbose)
	{
		print "Fixing the permissions for NMIS9 based on the configuration $C->{configfile}\nOperating on base directory: $C->{'<nmis_base>'}\nSetting owner to $C->{nmis_user}, group $C->{nmis_group}\n";
	}

	if ( $< != 0)
	{
		print STDERR "\nWARNING: Not running with root privileges, so this operation may not succeed entirely!\n\n";
	}
	else
	{
		system("chown","-R","$C->{nmis_user}:$C->{nmis_group}", $C->{'<nmis_base>'});
		system("chmod","-R","g+rw", $C->{'<nmis_base>'});

		if ( $C->{'<nmis_base>'} ne $C->{'<nmis_data>'} )
		{
			system("chown","-R", "$C->{nmis_user}:$C->{nmis_group}",
						 $C->{'<nmis_data>'});

			system("chmod","-R","g+rw", $C->{'<nmis_data>'});
		}
	}

	# single depth directories
	my %done;
	for my $location ($C->{'<nmis_data>'}, # commonly same as base
										$C->{'<nmis_base>'},
										$C->{'<nmis_admin>'}, $C->{'<nmis_bin>'}, $C->{'<nmis_cgi>'},
										$C->{'<nmis_models>'},
										$C->{'<nmis_default_models>'},
										$C->{'<nmis_logs>'},
										$C->{'log_root'}, # should be the same as nmis_logs
										$C->{'config_logs'},
										$C->{'json_logs'},
										$C->{'<menu_base>'},
										$C->{'report_root'},
										$C->{'script_root'}, # commonly under nmis_conf
										$C->{'plugin_root'}, # ditto
 )
	{
		next if ($done{$location});

		if (!-d $location)
		{
			print "Creating missing directory $location\n" if ($verbose);
			NMISNG::Util::createDir($location);
		}
		NMISNG::Util::setFileProtDirectory($location, "false");

		$done{$location} = 1;
	}

	# deeper dirs with recursion
	%done = ();
	for my $location ($C->{'<nmis_base>'}."/lib",
										$C->{'<nmis_conf>'},
										$C->{'<nmis_var>'},
										$C->{'<nmis_menu>'},
										$C->{'mib_root'},
										$C->{'database_root'},
										$C->{'web_root'}, )
	{
		next if ($done{$location});

		if (!-d $location)
		{
			print "Creating missing directory $location\n" if ($verbose);
			NMISNG::Util::createDir($location);
		}
		NMISNG::Util::setFileProtDirectory($location, "true");

		$done{$location} = 1;
	}

	# remove the selftest cache file to ensure it's regenerated;
	# otherwise we may show stale warnings about permissions that were already fixed
	unlink($C->{'<nmis_var>'}."/nmis_system/selftest.json");
}
elsif ($Q->{act} eq "groupsync")
{
	die "groupsync is no longer supported or necessary.\n";
}
# do sanitary checking on inventory
elsif ($Q->{act} =~ /^check[_-]inventory$/)
{
	my ($entries,$error) = NMISNG::Inventory::check_inventory_for_bad_things($nmisng,$Q->{min_size});
	if( $error )
	{
		print "Error: ".Dumper($error);
	}
	else
	{
		print "Result: ".Dumper($entries);
	}
}
elsif ($Q->{act} =~ /clean[-_]sessions/)
{
	my $user = $Q->{user};
	clean_sessions(user => $user);
}
elsif ($Q->{act} =~ /get[-_]sessions/)
{
	my $user = $Q->{user};
	get_sessions(user => $user);
}
elsif ($Q->{act} =~ /set[-_]last[-_]login/)
{
	my $user = $Q->{user};
	my $last_login = $Q->{last_login};
	set_last_login(user => $user, last_login => $last_login);
}
elsif ($Q->{act} =~ /unlock[-_]user/)
{
	my $user = $Q->{user};
	unlock_user(user => $user);
}
else
{
	print "\033[1mUnrecognized action! ('act=$Q->{act}')\033[0m\n\n";
	help(3);
	exit(255);
}
exit 0;


# resave nodes, forces lastupdate to be new and all validation to be run
sub noderefresh
{
	my $updated = 0;

	# get all nodes (or just one, not documented)
	my $md = $nmisng->get_nodes_model( name => $Q->{node} );
	if (my $error = $md->error)
	{
		die "Failed to lookup nodes: $error\n";
	}

	if (!$md->count)
	{
		print STDERR "No matching nodes.\n";
		exit 0;
	}

	for my $nth (0..($md->count-1))
	{
		my $rawdata = $md->data->[$nth];
		my ($insterror, $node) = $md->object($nth);
		die "Failed to instantiate node object: $insterror\n" if ($insterror);

		# first, check if the db data needs the configuration to be moved,
		# so that the record's top level holds only the known few properties
		if (!exists($rawdata->{configuration}))
		{
			my %newconfig;

			# only these may remain: _id, uuid, cluster_id, name, activated, lastupdate,
			# overrides, configuration, aliases, addresses
			for my $moveme (grep($_ !~ /^(_id|uuid|cluster_id|name|activated|lastupdate|overrides)$/,
													 keys %$rawdata))
			{
				$newconfig{$moveme} = $rawdata->{$moveme};
				delete $rawdata->{$moveme};
			}
			$node->configuration(\%newconfig); # which makes the node dirty

			# the first two top-level keepers are set on new, but nothing else is
			for my $mustset (qw(cluster_id name))
			{
				$node->$mustset($rawdata->{$mustset}) if (defined($rawdata->{$mustset}));
				delete $rawdata->{$mustset};
			}
			# these two must be hashes
			for my $mustset (qw(activated overrides))
			{
				$node->$mustset($rawdata->{$mustset}) if (ref($rawdata->{$mustset}) eq "HASH");
				delete $rawdata->{$mustset};
			}
		}

		# now retrigger config validation and saving
		$node->configuration( $node->configuration );
		$node->_dirty(1,"forcing a save");
		my ($op,$error) = $node->save();
		if( $op < 1 || $error )
		{
			print "Error saving: ".$node->name.", op:$op, error: $error"
		}
		else
		{
			$updated++;
		}
	}
	print "total nodes: ".$md->count.", updated: $updated\n";
}

# Collect performance data
sub collectPerformanceData
{
	my $output_folder = $C->{'system_performance'} // $C->{'<nmis_var>'}.'/system_performance';

	my $expandeddir = NMISNG::Util::getDir(dir => "conf"); # expands dirs like 'conf' or 'logs' into full location
	my $conf_file = "$expandeddir/performance";
	my ($data, $fh) = NMISNG::Util::readFiletoHash(file => $conf_file);
	# Try with 'conf-default' directory: in NMISNG::Util::getDir() we use 'dir => "conf_default"' to match '<nmis_conf_default>'

	if ( ref($data) ne "HASH") {
		print "Failed to read file $conf_file: $!\n";
		$expandeddir = NMISNG::Util::getDir(dir => "conf_default"); # expands dirs like 'conf' or 'logs' into full location
		$conf_file = "$expandeddir/performance";
		print "Reading file $conf_file ...\n";
		($data, $fh) = NMISNG::Util::readFiletoHash(file => $conf_file);
		if ( ref($data) ne "HASH") {
			print "Failed to read file $conf_file: $!\n";
		}
	}
	$data //= {};
	
	# Check output directory
	if (!-e $output_folder) 
	{
		mkdir $output_folder;
		$nmisng->log->info("Creating output folder $output_folder")
	} else {
		$nmisng->log->debug("Output folder setup in $output_folder")
	}
	
	if (ref($data) eq "HASH") {
		foreach my $key (keys %$data) {
			print "Running $key ... \n";
	
			# Run output
			my $cmd = $data->{$key}->{'command'};
			my $output = `$cmd 2>&1`;
			#print $output;
			if ($output) {
				# Create output file
				my $file = $output_folder . "/$key-". time . ".txt";
				open(FH, '>', $file) or die $!;
				print FH $output;
				close(FH);
				
				my $user = $C->{nmis_user};
				my $group = $C->{nmis_group};
				
				system("chown","-R", "$user:$group", $file);
				system("chmod","-R","g+rw", $file);
	
			} else {
				print "\t No command output for $key \n";
			}
		}
	}
}

# Collect performance data
# top - 17:29:46 up 75 days,  7:12,  5 users,  load average: 0.36, 0.17, 0.11
# Tasks: 166 total,   1 running, 164 sleeping,   0 stopped,   1 zombie
# %Cpu(s): 16.1 us,  1.7 sy,  0.0 ni, 81.8 id,  0.2 wa,  0.0 hi,  0.3 si,  0.0 st
# KiB Mem :  6115260 total,   592752 free,  1343404 used,  4179104 buff/cache
# KiB Swap:  8388604 total,  8353224 free,    35380 used.  4473640 avail Mem
# date,cpuUser,cpuSys,cpuNice,cpuIdle,cpuWaitIO,cpuHi,cpuSi,cpuSt,memTotal,memFree,memUsed,membuff/cache,swaptotal,swapfree,swapused,memAvail
# 20210302T17:45,3.4,0.6,0.0,95.8,0.0,0.0,0.0,0.0,6115260,503084,1419156,4193020,8388604,8353224,35380,4397888
sub collectTopData
{
	my $output_folder = $C->{'system_performance'} // $C->{'<nmis_var>'}.'/system_performance';	
	my $ymd = sub{sprintf '%04d%02d%02d', $_[5]+1900, $_[4]+1, $_[3]}->(localtime);
	my $file = "$output_folder/$ymd.csv";
	my $tmpfile = "$tmp/tmp-topn-".time.".txt";
	
	# Check output directory
	if (!-e $output_folder) 
	{
		mkdir $output_folder;
		$nmisng->log->info("Creating output folder $output_folder")
	} else {
		$nmisng->log->debug("Output folder setup in $output_folder")
	}
	
	my $output = `top -b -n 1 | head -n 5`;
	
	# Proccess output
	open my $OUTPUT, '>', $tmpfile or die "Couldn't open temp file: $!\n";
	print $OUTPUT $output;
	close $OUTPUT;
	unlink $tmpfile or warn "Could not unlink $tmpfile: $!";

	my %data;
	my @header = qw /date users load cpuUser cpuSys cpuNice cpuIdle cpuWaitIO cpuHi cpuSi cpuSt memTotal memFree memUsed membuff swaptotal swapfree swapused memAvail/;
	
	#my $time = localtime($time->epoch);
	#my($year, $mon, $day, $hour, $min) = $date =~ /^(\d{4}) (\d{2}) (\d{2})\ (\d{2}):(\d{2})$/x;
	my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
	
	$year += 1900;
	#$data{date} = "$year/$mon/$mday $hour:$min:$sec";	
	my $local_date = sprintf "%d/%02d/%02d %02d:%02d:%02d\n", $year, $mon, $mday, $hour, $min, $sec;
	$data{date} = $local_date;
	$data{date} =~ s/\n//;
	foreach my $line (split /[\r\n]+/, $output) {
	  
	  if ( $line =~ /top - (\d+\:\d+\:\d+) up (\d+) days,\s+(\d+\:\d+),\s+(\d+) users?,\s+load average: (\d+\.\d+), (\d+\.\d+), (\d+\.\d+)/ ) {
		  $data{load} = $5;
		  $data{users} = $4;
	  }
	  elsif ( $line =~ /top - (\d+\:\d+\:\d+) up\s+(\d+\:\d+),\s+(\d+) users?,\s+load average: (\d+\.\d+), (\d+\.\d+), (\d+\.\d+)/ ) {
		  $data{load} = $5;
		  $data{users} = $4;
	  }
	  ## Regular expression magic to grab what you want
	  # 			    %Cpu(s):  0.2 us,  0.0 sy,  0.0 ni, 99.7 id,  0.0 wa,  0.0 hi,  0.2 si,  0.0 st
	  elsif ( $line =~ /%Cpu\(s\):\s+(\d+\.\d+) us,\s+(\d+\.\d+) sy,\s+(\d+\.\d+) ni,\s*(\d+\.\d+) id,\s+(\d+\.\d+) wa,\s+(\d+\.\d+) hi,\s+(\d+\.\d+) si,\s+(\d+\.\d+) st/ ) {
		  $data{cpuUser} = $1;
		  $data{cpuSys} = $2;
		  $data{cpuNice} = $3;
		  $data{cpuIdle} = $4;
		  $data{cpuWaitIO} = $5;
		  $data{cpuHi} = $6;
		  $data{cpuSi} = $7;
		  $data{cpuSt} = $8;
	  }
	  elsif ( $line =~ /[MK]iB Mem :\s+(\d+\.?\d*) total,\s+(\d+\.?\d*) free,\s+(\d+\.?\d*) used,\s+(\d+\.?\d*) buff\/cache/ ) {
		  $data{memTotal} = $1;
		  $data{memFree} = $2;
		  $data{memUsed} = $3;
		  $data{membuff} = $4;
	  }
	  elsif ( $line =~ /[MK]iB Swap:\s+(\d+\.?\d*) total,\s+(\d+\.?\d*) free,\s+(\d+\.?\d*) used.\s+(\d+\.?\d*) avail Mem/ ) {
		  $data{swaptotal} = $1;
		  $data{swapfree} = $2;
		  $data{swapused} = $3;
		  $data{memAvail} = $4;
	  }
	}

	
	# Write file
	my $exists = 0;
	$exists = 1 if (-f $file);
	
	open(FH, '>>', $file) or die $!;
	print FH join(',', @header), "\n" if ($exists == 0);
	foreach my $val (@header) {
		print FH $data{$val}, ",";
	}
	print FH "\n";
	close(FH);
	
	my $user = $C->{nmis_user};
	my $group = $C->{nmis_group};
			
	system("chown","-R", "$user:$group", $file);
	system("chmod","-R","g+rw", $file);
}

# Clean user sessions
sub clean_sessions
{
	my %args = @_;
	my $user = $args{user};
	
	die "Needs a user to remove the sessions!\n" if (!$user);
	my $auth = new NMISNG::Auth;
	my ($error, $count) = $auth->get_live_session_counter(user => $user, remove_all => 1);
	print "$error \n" if ($error);
	print "$count sessions left for $user " if ($count);
}

# Get user sessions
sub get_sessions
{
	my %args = @_;

	my $auth = new NMISNG::Auth;
	my $all = $auth->get_all_live_session_counter();
	foreach my $user (keys %{$all}) {
		print " $user: ". $all->{$user}->{sessions} . "\n"; 
	}
}

# Set last login
sub set_last_login
{
	my %args = @_;
	my $user = $args{user};
	my $lastlogin = $args{lastlogin};
	
	die "Needs a user or last login to set last login!\n" if (!$user or !$lastlogin);
	
	my $auth = new NMISNG::Auth;
	my ($success, $error) = $auth->update_last_login(user => $user, lastlogin => $lastlogin);
	if ($error) {
		if ($error =~ /Permission/) {
			print "Must be run as root \n";
		} else {
			print "$error"; 
		}
		
	} else {
		print "set_last_login. Done \n"; 
	}
	
}

# Set last login
sub unlock_user
{
	my %args = @_;
	my $user = $args{user};
	die "Needs a user or last login to set last login!\n" if (!$user);
	
	my $auth = new NMISNG::Auth;
	my ($success, $error) = $auth->update_last_login(user => $user, remove => 1);
	if ($error) {
		if ($error =~ /Permission/) {
			print "Must be run as root \n";
		} else {
			print "$error \n"; 
		}
		
	} else {
		print "unlock_user $user. Done \n"; 
	}
	
}


###########################################################################
#  Help Function
###########################################################################
sub help
{
   my(${currRow}) = @_;
   my @{lines};
   my ${workLine};
   my ${line};
   my ${key};
   my ${cols};
   my ${rows};
   my ${pixW};
   my ${pixH};
   my ${i};
   my $IN;
   my $OUT;

   if ((-t STDERR) && (-t STDOUT)) {
      if (${currRow} == "")
      {
         ${currRow} = 0;
      }
      if ($^O =~ /Win32/i)
      {
         sysopen($IN,'CONIN$',O_RDWR);
         sysopen($OUT,'CONOUT$',O_RDWR);
      } else
      {
         open($IN,"</dev/tty");
         open($OUT,">/dev/tty");
      }
      ($cols, $rows, $pixW, $pixH) = Term::ReadKey::GetTerminalSize $OUT;
   }
   STDOUT->autoflush(1);
   STDERR->autoflush(1);

   push(@lines, "\n\033[1mNAME\033[0m\n");
   push(@lines, "       $PROGNAME -  NMIS Command Line Interface.\n");
   push(@lines, "\n");
   push(@lines, "\033[1mSYNOPSIS\033[0m\n");
   push(@lines, "       $PROGNAME [options...] act=<command> <command-parameters>...\n");
   push(@lines, "\n");
   push(@lines, "\033[1mDESCRIPTION\033[0m\n");
   push(@lines, "       The $PROGNAME program provides a command line interface for the NMIS\n");
   push(@lines, "       application. The program always expects an 'action' parameter specifying\n");
   push(@lines, "       what action is requested. Each action requires unique parameters\n");
   push(@lines, "       depending on the requirements of the action. There are also global\n");
   push(@lines, "       options accepted by all actions.\n");
   push(@lines, "\n");
   push(@lines, "\033[1mOPTIONS\033[0m\n");
   push(@lines, " --debug[1-9]             - global option to print detailed messages\n");
   push(@lines, " --help                   - display command line usage\n");
   push(@lines, " --quiet                  - display no output\n");
   push(@lines, " --usage                  - display a brief overview of command syntax\n");
   push(@lines, " --verbose                - display verbose output\n");
   push(@lines, " --version                - print a version message and exit\n");
   push(@lines, "\n");
   push(@lines, "\033[1mARGUMENTS\033[0m\n");
   push(@lines, "     act=<command>        - The action command to invoke.  Each is described below.\n");
   push(@lines, "     <command-parameters> - One of more command parameters depending on the command.\n");
   push(@lines, "     [debug=<true|false|yes|no|info|warn|error|fatal|verbose|0-9>]\n");
   push(@lines, "     [verbose=<true|false|yes|no|1|0>]\n");
   push(@lines, "     [quiet=<true|false|yes|no|1|0>]\n");
   push(@lines, "\n");
   push(@lines, "\033[1mEXIT STATUS\033[0m\n");
   push(@lines, "     The following exit values are returned:\n");
   push(@lines, "     0 Success\n");
   push(@lines, "     215 Failure\n\n");
   push(@lines, "\033[1mACTIONS\033[0m\n");
   push(@lines, "  -- GENERAL ACTIONS --\n");
   push(@lines, "     act=config-backup\n");
   push(@lines, "                     This action backs up the NMIS configurations, including\n");
   push(@lines, "                     The Configuration Models, and CRON directories. It should be\n");
   push(@lines, "                     be run as root!\n");
   push(@lines, "     act=daemon-status (or act=status)\n");
   push(@lines, "                     This action displays the status of the NMIS daemon.\n");
   push(@lines, "     act=ensure-indexes\n");
   push(@lines, "                     This action fixes incorrect database indices.\n");
   push(@lines, "     act=fixperms\n");
   push(@lines, "                     This action fixes incorrect file permissions in the NMIS\n");
   push(@lines, "                     installation. It should be run as root!\n");
   push(@lines, "     act=gettmp\n");
   push(@lines, "                     This action simply returns the configured temporary directory\n");
   push(@lines, "                     for this installation.\n");
   push(@lines, "     act=noderefresh\n");
   push(@lines, "                     This action Walks the list of nodes causing an internal\n");
   push(@lines, "                     Node refresh of each.\n");
   push(@lines, "\n");
   push(@lines, "  -- SCHEDULING ACTIONS --\n");
   push(@lines, "     act=schedule [at=time] <job.type=<activity>> [job.priority=0..1]\n");
   push(@lines, "                            [job.<node|uuid|group>=<instance> ...]\n");
   push(@lines, "                            [job.wantsnmp=<true|false|yes|no|1|0>]\n");
   push(@lines, "                            [job.wantwmi=<true|false|yes|no|1|0>]\n");
   push(@lines, "                            [job.phase=<update|collect>]\n");
   push(@lines, "                            [job.uuid=<uuid>]\n");
   push(@lines, "                            [job.force=<true|false|yes|no|1|0>]\n");
   push(@lines, "                            [job.verbosity=<1..9|debug|info|warn|error|fatal>]\n");
   push(@lines, "                            [job.output=<path>]\n");
   push(@lines, "                            [job.tag=<string>]\n");
   push(@lines, "                     This action inserts a new job record into the database.\n");
   push(@lines, "                        Supported Arguments for Schedule Creation:\n");
   push(@lines, "\n");
   push(@lines, "                        at=<time>: (Optional) time argument for the job to\n");
   push(@lines, "                           commence. Default is now.\n");
   push(@lines, "                           Time format is described below. Additional\n");
   push(@lines, "                           details can be found by running 'man at' on a Linux system.\n");
   push(@lines, "\n");
   push(@lines, "                        job.type=<activity>: (Required) One of: 'collect',\n");
   push(@lines, "                           'update', 'services','thresholds', 'escalations',\n");
   push(@lines, "                           'metrics', 'configbackup', 'purge', 'dbcleanup'\n");
   push(@lines, "                           'selftest', 'permission_test', or 'plugins' delete edit\n");
   push(@lines, "\n");
   push(@lines, "                        job.priority=<0..1>: (Optional) Number between 0\n");
   push(@lines, "                           0 (lowest) and 1 (highest) job priority.\n");
   push(@lines, "                           Default is 1 for manually scheduled jobs\n");
   push(@lines, "\n");
   push(@lines, "                        job.<node|uuid|group>=<instance>: (Optional)\n");
   push(@lines, "                           For 'collect', 'update', or 'services':\n");
   push(@lines, "                             This argument can be repeated. If none are given,\n");
   push(@lines, "                             all active nodes are included.\n");
   push(@lines, "\n");
   push(@lines, "                        job.wantsnmp=<true|false|yes|no|1|0> (Optional)\n");
   push(@lines, "                             For 'collection'. Default is true.\n");
   push(@lines, "                        job.wantwmi=<true|false|yes|no|1|0> (Optional)\n");
   push(@lines, "                             For 'collection'. Default is true.\n");
   push(@lines, "\n");
   push(@lines, "                        job.phase=<update|collect> (Required for 'plugins')\n");
   push(@lines, "                             Specifies which phase to schedule.\n");
   push(@lines, "                        job.uuid=<uuid> (Required for 'plugins')\n");
   push(@lines, "                             Specifies the uuid to act on. This argument can be\n");
   push(@lines, "                             repeated.\n");
   push(@lines, "                        job.force=<true|false|yes|no|1|0> (Optional) Causes certain job\n");
   push(@lines, "                             types to ignore scheduling policies and bypass any\n");
   push(@lines, "                             cached data. Default is false.\n");
   push(@lines, "                        job.verbosity=<1..9|debug|info|warn|error|fatal>:\n");
   push(@lines, "                             (Optional) Specifies verbosity level for just this\n");
   push(@lines, "                             one job.\n");
   push(@lines, "                        job.output=<path>: (Optional) If given as name_prefix\n");
   push(@lines, "                             or /path/name_prefix then all log output for this\n");
   push(@lines, "                             job is saved in a separate file. The path is\n");
   push(@lines, "                             relative to the log directory, and actual file is\n");
   push(@lines, "                             <name_prefix>-<timestamp>.log.\n");
   push(@lines, "                        job.tag=<string>: (Optional) The name can any random\n");
   push(@lines, "                             string and is is used for post-operation plugin\n");
   push(@lines, "                             grouping.\n");
   push(@lines, "     act=list-schedules [verbose=<true|false|yes|no|1|0>] [only=active|queued]\n");
   push(@lines, "                            [job.<queued|active>=<schedule_id> ...]\n");
   push(@lines, "                     This action displays an overview of pending and active jobs;\n");
   push(@lines, "                        verbose=<true|false|yes|no|1|0> (Optional) Causes job arguments\n");
   push(@lines, "                              to be displayed fully.\n");
   push(@lines, "                        only=<queued|active>: (Optional) 'queued' shows pending\n");
   push(@lines, "                              jobs only. 'active' shows only jobs that are in\n");
   push(@lines, "                              progress.\n");
   push(@lines, "                        job.<queued|active>=<schedule_id>: (Optional) Shows a\n");
   push(@lines, "                              particular job progress. This argument can be\n");
   push(@lines, "                              repeated.\n");
   push(@lines, "     act=delete-schedule id=<schedule_id|ALL> [job.X=...]\n");
   push(@lines, "                     This action removes a schedule record from the database\n");
   push(@lines, "                        id=<schedule_id|ALL>: (Required) Specifies the specific\n");
   push(@lines, "                              schedule to delete, or 'ALL' to delete all\n");
   push(@lines, "                              schedules.\n");
   push(@lines, "                        job.<queued|active>=<schedule_id>: (Optional) Deletes a\n");
   push(@lines, "                              particular jobs. This argument can be repeated.\n");
   push(@lines, "     act=abort id=<schedule_id>\n");
   push(@lines, "                     This action works like delete-schedule but also terminates\n");
   push(@lines, "                     any worker process that is processing that job.\n");
   push(@lines, "                       if id=ALL is given, then additional job.X properties can be used\n");
   push(@lines, "                       to select particular schedule records.\n");
   push(@lines, "     \n");
   push(@lines, "  -- CLEANUP ACTIONS --\n");
   push(@lines, "     act=purge [simulate=<true|false|yes|no|1|0>] [info=<true|false|yes|no|1|0>]\n");
   push(@lines, "                     This action removes past none-recurring outages after a\n");
   push(@lines, "                     configurable timeperiod.\n");
   push(@lines, "                        simulate=<true|false|yes|no|1|0> (Optional) If this option is\n");
   push(@lines, "                             selected, the purge only prints out what\n");
   push(@lines, "                             would have been purged. Default is false.\n");
   push(@lines, "                        info=<true|false|yes|no|1|0> (Optional) If this option is\n");
   push(@lines, "                             selected, the purge prints out what\n");
   push(@lines, "                             is being purged. Default is false.\n");
   push(@lines, "     act=dbcleanup [simulate=<true|false|yes|no|1|0>] [info=<true|false|1|0>]\n");
   push(@lines, "                            [use_performance_query=<true|false|yes|no|1|0>]\n");
   push(@lines, "                     This action runs a thorough database cleanup routine.\n");
   push(@lines, "                     It will audit and remove:\n");
   push(@lines, "                      * All inventory entries whose node is gone,\n");
   push(@lines, "                      * All inventory entries whose node AND cluster is gone,\n");
   push(@lines, "                      * All events entries whose node AND cluster is gone,\n");
   push(@lines, "                      * All status entries whose node AND cluster is gone,\n");
   push(@lines, "                      * All latest_data entries whose node AND cluster is gone,\n");
   push(@lines, "                        and all timed data whose inventory is gone.\n");
   push(@lines, "                        simulate=<true|false|yes|no|1|0> (Optional) If this option is\n");
   push(@lines, "                             selected, the purge only prints out what\n");
   push(@lines, "                             would have been purged. Default is false.\n");
   push(@lines, "                        info=<true|false|yes|no|1|0> (Optional) If this option is\n");
   push(@lines, "                             selected, the purge prints out what\n");
   push(@lines, "                             is being purged. Default is false.\n");
   push(@lines, "                        use_performance_query=<true|false|yes|no|1|0> (Optional)\n");
   push(@lines, "                             If this option is true, the query will work from\n");
   push(@lines, "                             nodes. if false, the query will corelate all\n");
   push(@lines, "                             inventory to the parent node.  Default is to use\n");
   push(@lines, "                             the setting from the configuration filee.\n");
   push(@lines, "     \n");
   push(@lines, "  -- REPORTING ACTIONS --\n");
   push(@lines, "     act=run-reports period=<day|week|month>\n");
   push(@lines, "                            type=<all|times|health|top10|outage|response|avail|port>\n");
   push(@lines, "                     This action runs the specified reports.\n");
   push(@lines, "                        period=<string>: (Required) The period to run.  One of\n");
   push(@lines, "                              day, week, or month.\n");
   push(@lines, "                        type=<string>: (Required) The type of reposts to be\n");
   push(@lines, "                              run.  'All' runs all of the other reports..\n");
   push(@lines, "     \n");
   push(@lines, "  -- PERFORMANCE ACTIONS --\n");
   push(@lines, "     act=create-outage ...\n");
   push(@lines, "                     This action creates new outage schedule.\n");
   push(@lines, "                        outage.description=<string>: (Optional) free-form textual\n");
   push(@lines, "                              description.\n");
   push(@lines, "                        outage.change_id: (Optional) Change management ticket\n");
   push(@lines, "                              identifier, used for event tagging.\n");
   push(@lines, "                        outage.frequency: (Optional) One of 'once', 'daily',\n");
   push(@lines, "                              'weekly' or 'monthly'.\n");
   push(@lines, "                        outage.start: (Optional) Date and time of outage start.\n");
   push(@lines, "                        outage.end: (Optional) Date and time of outage end.\n");
   push(@lines, "                               Format depends on frequency:\n");
   push(@lines, "                                 * daily: \"HH:MM\" or \"HH:MM:SS\". 24:00 is\n");
   push(@lines, "                                   allowed for end.\n");
   push(@lines, "                                 * weekly: \"MDAY HH:MM\" or \"MDAY HH:MM:SS\",\n");
   push(@lines, "                                   MDAY one of 'Mon', 'Tue' etc.\n");
   push(@lines, "                                 * monthly: \"D HH:MM:SS\", \"-D HH:MM:SS\",\n");
   push(@lines, "                                   \"D HH:MM\", \"-D HH:MM\" D is the numeric day of\n");
   push(@lines, "                                   the month, 1..31.  -D counts from the end of\n");
   push(@lines, "                                   the month, -1 is the last day of the month,\n");
   push(@lines, "                                   -2 the second to last etc.\n");
   push(@lines, "                                 * once: ISO8601 date time recommended,\n");
   push(@lines, "                                   e.g. 2017-10-31T03:04:26+0000\n");
   push(@lines, "                        outage.options: (Optional) key=values to adjust NMIS'\n");
   push(@lines, "                                 behaviour during an outage.\n");
   push(@lines, "                        outage.selector: (Optional) Any number of criteria for\n");
   push(@lines, "                                 selecting devices for this outage\n");
   push(@lines, "                                 selector keys: node.X or config.Y, node config\n");
   push(@lines, "                                    or global config properties.\n");
   push(@lines, "                                 selector values: single string, /regex string/,\n");
   push(@lines, "                                    array, or single strings.\n");
   push(@lines, "                                    Note: Arrays must be given as separate\n");
   push(@lines, "                                           indexed entries.\n");
   push(@lines, "                                          All selectors must match for a node to\n");
   push(@lines, "                                           be subject to the outage.\n");
   push(@lines, "     act=check-outages [node=<name>|uuid=<outage_id>] [time=<time>]\n");
   push(@lines, "                      This action reports which outages would apply at the given\n");
   push(@lines, "                      time (or now) and  for one node (if given) or all nodes\n");
   push(@lines, "     act=collect-performance-data \n");
   push(@lines, "                      This action collects performance data as specified in\n");
   push(@lines, "                      the 'performance.nmis' file. This data usually includes\n");
   push(@lines, "                      output from 'iostat', 'df', etc. The command sholuld be\n");
   push(@lines, "                      run as the 'nmis' user.\n");
   push(@lines, "     act=collect-top-data\n");
   push(@lines, "                      This action runs a 'top' command and collects CPU metrics.\n");
   push(@lines, "                      The command sholuld be run as the 'nmis' user.\n");
   push(@lines, "     act=delete-outage id=<outage_id>\n");
   push(@lines, "                      This action deletes a specified outage record.\n");
   push(@lines, "     act=list-outages [filter=<filter> ...]\n");
   push(@lines, "                     This action shows overview of selected outage schedules.\n");
   push(@lines, "                        filter=<filtername>: (Optional) The name of a filter to\n");
   push(@lines, "                              include. This argument can be repeated.\n");
   push(@lines, "     act=show-outage\n");
   push(@lines, "                     This action displays the details for one outage instance.\n");
   push(@lines, "     act=update-oudage\n");
   push(@lines, "                      This action updates an existing outage schedule.\n");
   push(@lines, "                      only the given outage.A, outage.X.Y properties are changed.\n");
   push(@lines, "\n");
   push(@lines, "  -- SESSION ACTIONS --\n");
   push(@lines, "     act=clean-sessions user=<username>\n");
   push(@lines, "                      This action deletes all sessions from the specified user.\n");
   push(@lines, "     act=get-sessions\n");
   push(@lines, "                      This action lists all sessions from all users\n");
   push(@lines, "     act=set-last-login user=<username> last_login=<last_login>\n");
   push(@lines, "                      This action sets the Last login from the specified user.\n");
   push(@lines, "                      The command sholuld be run as the 'root' user.\n");
   push(@lines, "     act=unlock-user user=<username>\n");
   push(@lines, "                      This action unlocks the specified user's account..\n");
   push(@lines, "                      The command sholuld be run as the 'root' user.\n");
   push(@lines, "   Notes:\n");
   push(@lines, "        * Time Format: These include both absolute time and date formats like\n");
   push(@lines, "          the ISO 8601 type \"2016-05-20T14:40\", as well as very handy relative\n");
   push(@lines, "          formats like \"now + 45 minutes\" or \"tomorrow midnight\".\n");
   push(@lines, "          More Information:\n");
   push(@lines, "          https://community.opmantek.com/display/opCommon/Supported+Time+Formats.\n");
   push(@lines, "\033[1mEXAMPLES\033[0m\n");
   push(@lines, "   act=create-outage \n");
   push(@lines, "      outage.description='certain nodes are busy each month start' \n");
   push(@lines, "      outage.change_id='ticket #42' \n");
   push(@lines, "      outage.frequency=monthly outage.start=\"1 12:00\" outage.end=\"1 13:30\" \n");
   push(@lines, "      outage.selector.node.group.0=\"busybodies\" \n");
   push(@lines, "      outage.selector.node.group.1=\"alsobad\"\n");
   push(@lines, "\n");
   push(@lines, "\n");
   print(STDERR "                       $PROGNAME - ${VERSION}\n");
   print(STDERR "\n");
   ${currRow} += 2;
   foreach (@lines)
   {
      if ((-t STDERR) && (-t STDOUT)) {
         ${i} = tr/\n//;  # Count the newlines in this string
         ${currRow} += ${i};
         if (${currRow} >= ${rows})
         {
            print(STDERR "Press any key to continue.");
            ReadMode 4, $IN;
            ${key} = ReadKey 0, $IN;
            ReadMode 0, $IN;
            print(STDERR "\r                          \r");
            if (${key} =~ /q/i)
            {
               print(STDERR "Exiting per user request. \n");
               return;
            }
            if ((${key} =~ /\r/) || (${key} =~ /\n/))
            {
               ${currRow}--;
            } else
            {
               ${currRow} = 1;
            }
         }
      }
      print(STDERR "$_");
   }
}

