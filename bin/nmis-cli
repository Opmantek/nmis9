#!/usr/bin/perl
#
#  Copyright 1999-2014 Opmantek Limited (www.opmantek.com)
#
#  ALL CODE MODIFICATIONS MUST BE SENT TO CODE@OPMANTEK.COM
#
#  This file is part of Network Management Information System ("NMIS").
#
#  NMIS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  NMIS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with NMIS (most likely in a file named LICENSE).
#  If not, see <http://www.gnu.org/licenses/>
#
#  For further information on NMIS or for a license other than GPL please see
#  www.opmantek.com or email contact@opmantek.com
#
#  User group details:
#  http://support.opmantek.com/users/
#
# *****************************************************************************
use strict;
our $VERSION = "9.0.0a";

use FindBin;
use lib "$FindBin::Bin/../lib";

use POSIX qw();
use File::Basename;
use File::Spec;
use File::Find;
use Data::Dumper;
use Time::Local;

# this imports the LOCK_ *constants (eg. LOCK_UN, LOCK_EX), also the stat modes
use Fcntl qw(:DEFAULT :flock :mode);
use Errno qw(EAGAIN ESRCH EPERM);

use NMISNG;
use NMISNG::Log;
use NMISNG::Util;
use NMISNG::Outage;

if ( @ARGV == 1 && $ARGV[0] eq "--version" )
{
	print "version=$VERSION\n";
	exit 0;
}

my $thisprogram = basename($0);
my $usage       = "Usage: $thisprogram [option=value...] <act=command>

 act=fixperms
 act=config-backup
 act=groupsync

 act=purge [simulate=t/f] [info=t/f]
 act=dbcleanup [simulate=t/f] [info=t/f]

 act=run-reports period=<day|week|month> type=<all|times|health|top10|outage|response|avail|port>

 act=list-outages [filter=X...]
 act=create-oudate [outage.A=B... outage.X.Y=Z...]
 act=update-outage id=<outid> [outage.A=B... outage.X.Y=Z...]
 act={delete-outage|show-outage} id=<outid>
 act=check-outages [node=X|uuid=Y] [time=T]
  act=outage-help for more detailed help

\n";

my $outageusage = qq|Outage Management:

list-outages: shows overview of selected outage schedules
show-outage: displays the details for one outage instance

create-outage: creates new outage schedule
update-oudate: updates existing outage schedule
 only the given outage.A, outage.X.Y properties are changed.

check-outage: reports which outages would apply at the given time
 (or now) and  for one node (if given) or all nodes

Supported Arguments for Outage Creation:

outage.description: free-form textual description.
outage.change_id: change management ticket identifier, used for event tagging

outage.frequency: one of 'once', 'daily', 'weekly' or 'monthly'
outage.start, outage.end: date and time of outage start and end,
 format depends on frequency
  daily: "HH:MM" or "HH:MM:SS". 24:00 is allowed for end.
  weekly: "MDAY HH:MM" or "MDAY HH:MM:SS", MDAY one of 'Mon', 'Tue' etc.
  monthly: "D HH:MM:SS", "-D HH:MM:SS", "D HH:MM", "-D HH:MM"
   D is the numeric day of the month, 1..31.  -D counts from the end of the month,
   -1 is the last day of the month, -2 the second to last etc.
  once: ISO8601 date time recommended,
   e.g. 2017-10-31T03:04:26+0000

outage.options: optional key=values to adjust NMIS' behaviour during an outage
outage.selector: any number of criteria for selecting devices for this outage
  selector keys: node.X or config.Y, node config or global config properties
  selector values: single string, /regex string/ or array or single strings.
  arrays must be given as separate indexed entries.
  all selectors must match for a node to be subject to the outage.

example: $thisprogram act=create-outage \\
outage.description='certain nodes are busy each month start' \\
outage.change_id='ticket #42' \\
outage.frequency=monthly outage.start="1 12:00" outage.end="1 13:30" \\
outage.selector.node.group.0="busybodies" \\
outage.selector.node.group.1="alsobad"\n\n|;

die $usage if ( !@ARGV || $ARGV[0] =~ /^-(h|\?|-help)$/ );
my $Q = NMISNG::Util::get_args_multi(@ARGV);

my $wantverbose = (NMISNG::Util::getbool($Q->{verbose}));
my $wantquiet  = NMISNG::Util::getbool($Q->{quiet});

my $customconfdir = $Q->{dir}? $Q->{dir}."/conf" : undef;
my $C      = NMISNG::Util::loadConfTable(dir => $customconfdir,
																				 debug => $Q->{debug},
																				 info => $Q->{info});
die "no config available!\n" if (ref($C) ne "HASH" or !keys %$C);

# the db config needs adjusting before dbcleanup is attempted: the aggregations
# often take longer than the default 5s...and that param cannot be set on live connections.
if ($Q->{act} eq "dbcleanup")
{
	$C->{db_query_timeout} = 1000*300;	# 5 minutes max
}

# log to stderr if debug or info are given
my $logfile = $C->{'<nmis_logs>'} . "/cli.log";
my $error = NMISNG::Util::setFileProtDiag(file => $logfile) if (-f $logfile);
warn "failed to set permissions: $error\n" if ($error);

# use debug, or info arg, or configured log_level
my $logger = NMISNG::Log->new( level => NMISNG::Log::parse_debug_level(
																 debug => $Q->{debug},
																 info => $Q->{info}) // $C->{log_level},
															 path  => (defined($Q->{debug}) || defined($Q->{info})? undef : $logfile));

# this opens a database connection
my $nmisng = NMISNG->new(
	config => $C,
	log    => $logger,
);

# for audit logging
my ($thislogin) = getpwuid($<); # only first field is of interest

# outage management first
if ($Q->{act} =~ /^outage[_-]help$/)
{
	print $outageusage;
	exit 0;
}
# overview of all or selected outages
elsif ($Q->{act} =~ /^list[_-]outages$/)
{
	my %filter;
	for my $maybe (keys %$Q)
	{
		next if ($maybe !~ /^(id|description|change_id|frequency|start|end|options\.nostats|selector.(config|node).[^=]+)$/);

		if ($Q->{$maybe} =~ m!^/(.*)/(i)?$!)
		{
			my ($re,$options) = ($1,$2);
			$filter{$maybe} = ($options? qr{$re}i : qr{$re});
		}
		else
		{
			$filter{$maybe} =  $Q->{$maybe};
		}
	}

	my $res = NMISNG::Outage::find_outages(filter => \%filter);
	die "Error: failed to find outages: $res->{error}\n" if (!$res->{success});

	if (!@{$res->{outages}})
	{
		print STDERR "No matching outages.\n" if (!$wantquiet);
		exit 0;
	}

	# uuids are 36c wide, align only if output is to tty
	my $fmt = (-t \*STDOUT? "%36s\t%16s\t%30s\t\%10s\t%20s\t%20s\n" : "%s\t%s\t%s\t%s\t%s\t%s\n");
	# header only if tty
	printf($fmt, "ID", "Change ID", "Description",
				 "Frequency", "Start", "End") if (-t \*STDOUT);

	for my $orec (@{$res->{outages}})
	{
		printf($fmt,
					 $orec->{id},
					 $orec->{change_id},
					 $orec->{description},
					 $orec->{frequency},
					 ($orec->{frequency} eq "once" && $orec->{start} =~ /^\d+(\.\d+)?$/?
						POSIX::strftime("%Y-%m-%dT%H:%M:%S", localtime($orec->{start})) : $orec->{start}),
					 ($orec->{frequency} eq "once" && $orec->{end} =~ /^\d+(\.\d+)?$/?
						POSIX::strftime("%Y-%m-%dT%H:%M:%S", localtime($orec->{end})) : $orec->{end})
					 , );

	}
}
# remove one outage by id
elsif ($Q->{act} =~ /^delete[_-]outage$/)
{
	my $outid = $Q->{"id"};
	die "Error: Cannot delete outage without id argument!\n\n$outageusage\n" if (!$outid);

	my $res = NMISNG::Outage::remove_outage(id => $outid, meta => { user => $thislogin });
	die "Error: failed to remove outage: $res->{error}\n" if (!$res->{success});
}
# show one outage structure in flattened form
elsif ($Q->{act} =~ /^show[_-]outage$/)
{
	my $outid = $Q->{"id"};
	die "Error: Cannot show outage without id argument!\n\n$outageusage\n" if (!$outid);

	my $res = NMISNG::Outage::find_outages(filter => { id => $outid });
	die "Error: Failed to lookup outage: $res->{error}" if (!$res->{success});
	# there can be at most one with this id
	my $theoneandonly = $res->{outages}->[0];
	die "Error: No outage with id $outid exists!\n" if (!$theoneandonly);

	my ($error, %flatearth) = NMISNG::Util::flatten_dotfields($theoneandonly);
	for my $k (sort keys %flatearth)
	{
		my $val = $flatearth{$k};
		print "$k=$flatearth{$k}\n";
	}
	exit 0;
}
elsif ($Q->{act} =~ /^update[_-]outage$/)
{
	# update: id required
	my $outid = $Q->{id};

	die "Error: Cannot update outage without id argument!\n\n$outageusage\n"
			if (!$outid);

	# look it up, amend with given values
	my $res = NMISNG::Outage::find_outages(filter => { id => $outid });
	die "Error: Failed to lookup outage: $res->{error}" if (!$res->{success});
	# there can be at most one with this id
	my $updateme = $res->{outages}->[0];
	die "Error: No outage with id $outid exists!\n" if (!$updateme);

	my $dosomething;
	for my $name (grep(/^outage\./, keys %$Q))
	{
		my $dotted = $name; $dotted =~ s/^outage\.//;
		$updateme->{$dotted} = (defined($Q->{$name}) && $Q->{$name} ne "")?
				$Q->{$name} : undef;
		++$dosomething;

		my $error = NMISNG::Util::translate_dotfields($updateme);
		die "Error: translation of arguments failed: $error\n" if ($error);
	}
	die "Error: No changes for outage \"$outid\"!\n" if (!$dosomething);

	$updateme->{id} = $outid;			# bsts...
	$res = NMISNG::Outage::update_outage(%$updateme, meta => { user => $thislogin });
	die "Error: Failed to update \"$outid\": $res->{error}\n" if (!$res->{success});
}
elsif ($Q->{act} =~ /^create[_-]outage$/)
{
	# create w/o args? show help
	die "Error: Cannot create outage without arguments!\n\n$outageusage\n"
			if (!grep(/^outage\./, keys %$Q));

	my ($addables,%createme);
	for my $name (grep(/^outage\./, keys %$Q))
	{
		my $dotted = $name; $dotted =~ s/^outage\.//;
		$createme{$dotted} = (defined($Q->{$name}) && $Q->{$name} ne "")?
				$Q->{$name} : undef;
		++$addables;

		my $error = NMISNG::Util::translate_dotfields(\%createme);
		die "Error: translation of arguments failed: $error\n" if ($error);
	}
	die "Error: No valid arguments for creating an outage!\n\n$outageusage\n" if (!$addables);
	# make sure the user doesn't pass a clashing id arg!
	$createme{id} //= $Q->{id} if (defined $Q->{id});
	if ($createme{id})
	{
		my $clash = NMISNG::Outage::find_outages(filter => { id => $createme{id} });
		die "Error: Failed to lookup outage: $clash->{error}" if (!$clash->{success});
		die "Error: Cannot create outage with id \"$createme{id}\": already exists!\n"
				if (@{$clash->{outages}});
	}

	my $res = NMISNG::Outage::update_outage(%createme, meta => { user => $thislogin });
	die "Error: Failed to create: $res->{error}\n" if (!$res->{success});

	# print the created id if not quiet, and without fluff if not tty
	print((-t \*STDOUT? "Created outage \"$res->{id}\"\n" : $res->{id}."\n"))
			if (!$wantquiet);
	exit 0;
}
elsif ($Q->{act} =~ /^check[_-]outages$/)
{
	my $nodeobj;									# particular node?

	if (my $nodename = $Q->{node} or my $uuid = $Q->{uuid})
	{
		my %nodesel;
		$nodesel{name} = $nodename if ($nodename);
		$nodesel{uuid} = $uuid if ($uuid);

		$nodeobj = $nmisng->node(%nodesel);
		die "Invalid node/uuid arguments, no matching node exists!\n"
				if (!$nodeobj);
	}

	my $when = $Q->{time} || time;
	if ($when !~ /^\d+(\.\d+)?$/)
	{
		$when = NMISNG::Util::parseDateTime($when) || NMISNG::Util::getUnixTime($when);
	}


	my $res = NMISNG::Outage::check_outages( node => $nodeobj, nmisng => $nmisng, time => $when);
	die "Failed to check outages: $res->{error}\n" if (!$res->{success});


	print "\nRelevant outages"
			.($nodeobj? (" for node ".$nodeobj->name.", "):"")
			." at time "
			.localtime($when).":\n";

	for (["Past:", "past"], ["Future:", "future"], ["Current: ", "current" ])
	{
		my ($tag, $source) = @$_;

		if (!@{$res->{$source}})
		{
			print "$tag None\n";
		}
		else
		{
			my @output;
			for my $match (@{$res->{$source}})
			{
				my $msg = "\n\t\"$match->{description}\" ($match->{id})\n\t$match->{frequency} from '"
						. ($match->{start} =~ /^\d+(\.\d+)?$/? scalar(localtime($match->{start})) : $match->{start})
						."' to '"
						. ($match->{end} =~ /^\d+(\.\d+)?$/? scalar(localtime($match->{end})) : $match->{end})."'";
				$msg .= "\n\t(actual '".localtime($match->{actual_start}). "' to '".localtime($match->{actual_end})."')"
						if ($match->{actual_start});
				push @output, $msg;
			}
			print "$tag ".join("\n\n", @output)."\n";
		}
	}
	print "\n";
	exit 0;
}

elsif ($Q->{act} eq "run-reports")
{
	my ($period, $reporttype) = @{$Q}{"period","type"};

	die "Unknown date=$period selected!\n$usage\n"
			if ($period !~ /^(day|week|month)$/i);
	die "Unknown report=$reporttype selected!\n$usage\n"
			if ($reporttype !~ /^(all|times|health|top10|outage|response|avail|port)$/);

	my $reportdir = $C->{report_root};
	NMISNG::Util::createDir($reportdir) if (!-d $reportdir);
	my ($start, $end, $outfile);
	my $time = time();

	# fixme9: is this warning still applicable at all?
	# attention: the file naming logic here must match purge_files() in cgi-bin/reports.pl,
	# or unwanted ancient reports will be left behind!
	if ($period eq 'day')
	{
		my ($s,$m,$h) = (localtime($time))[0..2];
		$end = $time-($s+($m*60)+($h*60*60));
		$start = $end - (60*60*24); # yesterday

		$outfile= POSIX::strftime("day-%d-%m-%Y-%a.html",localtime($start));
	}
	elsif ($period eq 'week')
	{
		my ($s,$m,$h,$wd) = (localtime($time))[0..2,6];
		$end = $time-($s+($m*60)+($h*60*60)+($wd*60*60*24));
		$start = $end - (60*60*24*7); # last weekend

		$outfile = POSIX::strftime("week-%d-%m-%Y-%a.html",localtime($start));
	}
	elsif ($period eq 'month')
	{
		my ($m,$y) = (localtime($time))[4,5];
		$end = timelocal(0,0,0,1,$m,$y);
		$m -= 1;
		if ($m < 0) {
			$m = 11; $y -= 1;
		}
		$start = timelocal(0,0,0,1,$m,$y);

		$outfile =  POSIX::strftime("month-%m-%Y.html",localtime($start));
	}

	my @todos = ($reporttype eq "all"? (qw(times health top10 outage response avail port)) : $reporttype);
	for my $thisreport (@todos)
	{
		my $file = "$reportdir/${thisreport}-${outfile}";
		my $status = system("$C->{'<nmis_cgi>'}/reports.pl", "report=$thisreport",
												"start=$start", "end=$end", "outfile=$file") >> 8;
		NMISNG::Util::logMsg("ERROR (report) generating report=$thisreport file=$file: $!") if ($status);
		NMISNG::Util::setFileProtDiag(file =>$file) if (-f $file);
	}
}
elsif ($Q->{act} eq "config-backup")
{
	my $backupdir = $C->{'<nmis_backups>'};

	if (!-d $backupdir)
	{
		mkdir($backupdir,0700) or die "Cannot create $backupdir: $!\n";
	}

	die "Cannot write to directory $backupdir, check permissions!\n"
			if (!-w $backupdir);
	die "Cannot read directory $backupdir, check permissions!\n"
			if (!-r $backupdir or !-x $backupdir);

	# now let's take a new backup...
	my $backupprefix = "nmis-config-backup-";
	my $backupfilename = "$backupdir/$backupprefix".POSIX::strftime("%Y-%m-%d-%H%M",localtime).".tar";

	# ...of _custom_ (and default models for good measure),
	# and configuration...
	my @relativepaths = (map { File::Spec->abs2rel($_, $C->{'<nmis_base>'}) }
											 ($C->{'<nmis_models>'},
												$C->{'<nmis_default_models>'},
												$C->{'<nmis_conf>'}));

	my $status = system("tar","-cf",$backupfilename,
											"-C", $C->{'<nmis_base>'},
											@relativepaths);
	if ($status == -1)
	{
		die "Failed to execute tar!\n";
	}
	elsif ($status & 127)
	{
		die "Backup failed, tar killed with signal ".($status & 127)."\n";
	}
	elsif ($status >> 8)
	{
		die "Backup failed, tar exited with exit code ".($status >> 8)."\n";
	}

	# ...and the various cron files
	my $td = File::Temp::tempdir(CLEANUP => 1);
	chdir $td or die "cannot chdir to $td: $!\n";
	mkdir("$td/cron",0755) or die "Cannot create $td/cron: $!\n";
	system("cp -a /etc/cron* cron/ 2>/dev/null");
	system("crontab -l -u root > cron/root_crontab 2>/dev/null");
	system("crontab -l -u nmis > cron/nmis_crontab 2>/dev/null");

	$status = system("tar","-rf",$backupfilename,"cron");
	if ($status == -1)
	{
		die "Failed to execute tar!\n";
	}
	elsif ($status & 127)
	{
		die "Backup failed, tar killed with signal ".($status & 127)."\n";
	}
	elsif ($status >> 8)
	{
		die "Backup failed, tar exited with exit code ".($status >> 8)."\n";
	}
	$status = system("gzip",$backupfilename);
	chdir("/");											# so that the tempdir can be cleaned up
	exit $status >> 8;
}
elsif ($Q->{act} eq 'purge')
{
	my $res = purge_files(simulate => $Q->{simulate});
	die "$res\n" if ($res);

	$res = NMISNG::Outage::purge_outages(nmisng => $nmisng, simulate => $Q->{simulate});
	die "$res->{error}\n" if (!$res->{success});
}
elsif ($Q->{act} eq "dbcleanup")
{
	my $res = dbcleanup(simulate => $Q->{simulate});
	die "$res\n" if ($res);
}
elsif ($Q->{act} eq 'noderefresh')
{
	noderefresh();
}
elsif ($Q->{act} eq "fixperms")
{
	if ($wantverbose)
	{
		print "Fixing the permissions for NMIS9 based on the configuration $C->{configfile}\nOperating on base directory: $C->{'<nmis_base>'}\nSetting owner to $C->{nmis_user}, group $C->{nmis_group}\n";
	}

	if ( $< != 0)
	{
		print "\nWARNING: Not running with root privileges, so this operation may not work fully!\n\n";
	}
	else
	{
		system("chown","-R","$C->{nmis_user}:$C->{nmis_group}", $C->{'<nmis_base>'});
		system("chmod","-R","g+rw", $C->{'<nmis_base>'});

		if ( $C->{'<nmis_base>'} ne $C->{'<nmis_data>'} )
		{
			system("chown","-R", "$C->{nmis_user}:$C->{nmis_group}",
						 $C->{'<nmis_data>'});

			system("chmod","-R","g+rw", $C->{'<nmis_data>'});
		}
	}

	# single depth directories
	my %done;
	for my $location ($C->{'<nmis_data>'}, # commonly same as base
										$C->{'<nmis_base>'},
										$C->{'<nmis_admin>'}, $C->{'<nmis_bin>'}, $C->{'<nmis_cgi>'},
										$C->{'<nmis_models>'},
										$C->{'<nmis_default_models>'},
										$C->{'<nmis_logs>'},
										$C->{'log_root'}, # should be the same as nmis_logs
										$C->{'config_logs'},
										$C->{'json_logs'},
										$C->{'<menu_base>'},
										$C->{'report_root'},
										$C->{'script_root'}, # commonly under nmis_conf
										$C->{'plugin_root'}, # ditto
										$C->{'<nmis_var>'}."/nmis_system/timestamps", )
	{
		next if ($done{$location});

		if (!-d $location)
		{
			print "Creating missing directory $location\n" if ($wantverbose);
			NMISNG::Util::createDir($location);
		}
		NMISNG::Util::setFileProtDirectory($location, "false");

		$done{$location} = 1;
	}

	# deeper dirs with recursion
	%done = ();
	for my $location ($C->{'<nmis_base>'}."/lib",
										$C->{'<nmis_conf>'},
										$C->{'<nmis_var>'},
										$C->{'<nmis_menu>'},
										$C->{'mib_root'},
										$C->{'database_root'},
										$C->{'web_root'}, )
	{
		next if ($done{$location});

		if (!-d $location)
		{
			print "Creating missing directory $location\n" if ($wantverbose);
			NMISNG::Util::createDir($location);
		}
		NMISNG::Util::setFileProtDirectory($location, "true");

		$done{$location} = 1;
	}

	# remove the selftest cache file to ensure it's regenerated;
	# otherwise we may show stale warnings about permissions that were already fixed
	unlink($C->{'<nmis_var>'}."/nmis_system/selftest.json");
}
elsif ($Q->{act} eq "groupsync")
{
	# iterate over nodes and add any new groups to the configuration
	# this is normally NOT automated, as groups are an administrative feature
	# for maintenance (as nodes in unlisted groups are active but not
	# shown in the gui)

	my $NT = Compat::NMIS::loadLocalNodeTable();    # only local nodes
	NMISNG::Util::dbg( "table Local Node loaded", 2 );

	# reread the config with a lock and unflattened
	my $fn = $C->{'<nmis_conf>'}. "/Config.nmis";
	my ( $rawC, $fh ) = NMISNG::Util::readFiletoHash(file => $fn, lock => 'true' );
	die "Error: failed to read config $fn!\n" if ( !$rawC or !keys %$rawC );

	my %oldgroups = map { $_ => 1 } ( split( /\s*,\s*/, $rawC->{system}->{group_list} ) );
	my %newgroups;
	for my $node ( keys %$NT )
	{
		my $thisgroup = $NT->{$node}->{group};
		next if ( $oldgroups{$thisgroup} );
		++$newgroups{$thisgroup};
	}

	print "Existing groups:\n\t", ( %oldgroups ? join( "\n\t", keys %oldgroups ) : "<None>" ),
	"\n\nNew groups to add:\n\t", ( %newgroups ? join( "\n\t", keys %newgroups ) : "<None>" ),
	"\n\n";

	if (%newgroups)
	{
		$rawC->{system}->{group_list} = join( ",", sort( keys %oldgroups, keys %newgroups ) );
		NMISNG::Util::writeHashtoFile( file => $fn, handle => $fh, data => $rawC );
	}
	else
	{
		close $fh;									# release lock
	}
}
else
{
	die $usage;
}
exit 0;

# this is a maintenance command for removing old, broken or unwanted files,
# replaces and extends the old admin/nmis_file_cleanup.sh
#
# args: simulate (default: false, if true only prints
# what it would do)
# returns: undef if ok, error message otherwise
sub purge_files
{
	my (%args) = @_;
	my %nukem;

	my $simulate = NMISNG::Util::getbool( $args{simulate} );

	NMISNG::Util::info("Starting to look for purgable files"
										 .($simulate? ", in simulation mode":"") );

	# config option, extension, where to look...
	my @purgatory = (
		{   ext          => qr/\.rrd$/,
			minage       => $C->{purge_rrd_after} || 30 * 86400,
			location     => $C->{database_root},
			also_empties => 1,
			description  => "Old RRD files",
		},
		{   ext          => qr/\.(tgz|tar\.gz)$/,
			minage       => $C->{purge_backup_after} || 30 * 86400,
			location     => $C->{'<nmis_backups>'},
			also_empties => 1,
			description  => "Old Backup files",
		},
		{
			# old nmis state files - legacy .nmis under var
			minage => $C->{purge_state_after} || 30 * 86400,
			ext => qr/\.nmis$/,
			location     => $C->{'<nmis_var>'},
			also_empties => 1,
			description  => "Legacy .nmis files",
		},
		{
			# old nmis state files - json files but only directly in var,
			# or in network or in service_status
			minage => $C->{purge_state_after} || 30 * 86400,
			location     => $C->{'<nmis_var>'},
			path         => qr!^$C->{'<nmis_var>'}/*(network|service_status)?/*[^/]+\.json$!,
			also_empties => 1,
			description  => "Old JSON state files",
		},
		{
			# old nmis state files - json files under nmis_system,
			# except auth_failure files
			minage => $C->{purge_state_after} || 30 * 86400,
			location     => $C->{'<nmis_var>'} . "/nmis_system",
			notpath      => qr!^$C->{'<nmis_var>'}/nmis_system/auth_failures/!,
			ext          => qr/\.json$/,
			also_empties => 1,
			description  => "Old internal JSON state files",
		},
		{
			# broken empty json files - don't nuke them immediately, they may be tempfiles!
			minage       => 3600,                       # 60 minutes seems a safe upper limit for tempfiles
			ext          => qr/\.json$/,
			location     => $C->{'<nmis_var>'},
			only_empties => 1,
			description  => "Empty JSON state files",
		},
		{   minage => $C->{purge_event_after} || 30 * 86400,
			path => qr!events/.+?/history/.+\.json$!,
			also_empties => 1,
			location     => $C->{'<nmis_var>'} . "/events",
			description  => "Old event history files",
		},
		{
			minage => $C->{purge_jsonlog_after} || 30 * 86400,
			also_empties => 1,
			ext          => qr/\.json/,
			location     => $C->{json_logs},
			description  => "Old JSON log files",
		},

		{
			minage => $C->{purge_jsonlog_after} || 30*86400,
			also_empties => 1,
			ext => qr/\.json/,
			location => $C->{config_logs},
			description => "Old node configuration JSON log files",
		},

		{
			minage => $C->{purge_reports_after} || 365*86400,
			also_empties => 0,
			ext => qr/\.html$/,
			location => $C->{report_root},
			description => "Very old report files",
		},

	);

	for my $rule (@purgatory)
	{
		next if ($rule->{minage} <= 0);	# purging can be disabled by setting the minage to -1
		my $olderthan = time - $rule->{minage};
		next if ( !$rule->{location} );
		NMISNG::Util::info("checking dir $rule->{location} for $rule->{description}");

		File::Find::find(
			{   wanted => sub {
					my $localname = $_;

					# don't need it at the moment my $dir = $File::Find::dir;
					my $fn   = $File::Find::name;
					my @stat = stat($fn);

					next
						if (
						!S_ISREG( $stat[2] )    # not a file
						or ( $rule->{ext}     and $localname !~ $rule->{ext} )    # not a matching ext
						or ( $rule->{path}    and $fn !~ $rule->{path} )          # not a matching path
						or ( $rule->{notpath} and $fn =~ $rule->{notpath} )
						);                                                        # or an excluded path

					# also_empties: purge by age or empty, versus only_empties: only purge empties
					if ( $rule->{only_empties} )
					{
						next if ( $stat[7] );                                     # size
					}
					else
					{
						next
							if (
							( $stat[7] or !$rule->{also_empties} )                # zero size allowed if empties is off
							and ( $stat[9] >= $olderthan )
							);                                                    # younger than the cutoff?
					}
					$nukem{$fn} = $rule->{description};
				},
				follow => 1,
			},
			$rule->{location}
		);
	}

	for my $fn ( sort keys %nukem )
	{
		my $shortfn = File::Spec->abs2rel( $fn, $C->{'<nmis_base>'} );
		if ($simulate)
		{
			print "purge: rule '$nukem{$fn}' matches $shortfn\n";
		}
		else
		{
			NMISNG::Util::info("removing $shortfn (rule '$nukem{$fn}')");
			unlink($fn) or return "Failed to unlink $fn: $!";
		}
	}
	NMISNG::Util::info("Purging complete");
	return;
}

# this is a maintenance command for removing invalid database material
# (old stuff is automatically done via TTL index on expire_at)
#
# args: simulate (default: false, if true only prints what it would do)
# returns: undef if ok, error message otherwise
sub dbcleanup
{
	my (%args) = @_;
	my %nukem;

	my $simulate = NMISNG::Util::getbool( $args{simulate} );
	# we want to remove:
	# all inventory entries whose node is gone,
 	# and all timed data whose inventory is gone.
	# note that for timed orphans we have no cluster_id;

	$logger->info("Starting Database cleanup");

	# first find ditchable inventories
	$logger->debug("Looking for orphaned inventory records");

	my $invcoll = $nmisng->inventory_collection;
	my ($goners, undef, $error) = NMISNG::DB::aggregate(
		collection => $invcoll,
		pre_count_pipeline => undef,
		count => undef,
		allowtempfiles => 1,
		post_count_pipeline => [
			# link inventory to parent node
			{ '$lookup' => { from => "nodes",
											 localField => "node_uuid",
											 foreignField => "uuid",
											 as =>  "parent"} },
			# then select the ones without parent
			{ '$match' => { parent => { '$size' => 0 } } },
			# then give me just the inventory ids
			{ '$project'  => { '_id' =>  1 } }]);

	if ($error)
	{
		$logger->error("inventory aggregation failed: $error");
		return "inventory aggregation failed: $error";
	}
	my @ditchables =  map { $_->{_id} } (@$goners);

	# second, remove those - possibly orphaning stuff that we should pick up
	if (!@ditchables)
	{
		$logger->debug("No orphaned inventory records detected.");
	}
	elsif ($simulate)
	{
		$logger->info("Cleanup would remove ".scalar(@ditchables). " orphaned inventory records, but not in simulation mode.");
	}
	else
	{
		my $res = NMISNG::DB::remove(collection => $invcoll,
																 query => NMISNG::DB::get_query(
																	 and_part => { _id => \@ditchables }));
		if (!$res->{success})
		{
			$logger->error("failed to remove inventory instances: $res->{error}");
			return "failed to remove inventory instances: $res->{error}";
		}
		$logger->info("Removed $res->{removed_records} orphaned inventory records.");
	}

	# third, determine what concepts exist, get their timed data collections
	# and verify those against the inventory - plus the latest_data look-aside-cache
	my $conceptnames = NMISNG::DB::distinct(collection => $nmisng->inventory_collection,
																					key => "concept");
	if (ref($conceptnames) ne "ARRAY")
	{
		$logger->error("failed to determine distinct concepts!");
		return "failed to determine distinct concepts!";
	}
	for my $concept ("latest_data", @$conceptnames)
	{
		my $timedcoll = $concept eq "latest_data"?
				$nmisng->latest_data_collection :
				$nmisng->timed_concept_collection(concept => $concept);
		next  if (!$timedcoll);		# timed_concept_collection already logs, ditto latest_data_collection

		my $collname = $timedcoll->name;

		$logger->debug("Looking for orphaned timed records for $concept");

		my ($goners, undef, $error) = NMISNG::DB::aggregate(
			collection => $timedcoll,
			pre_count_pipeline => undef,
			count => undef,
			allowtempfiles => 1,
			post_count_pipeline => [
				# link to inventory parent
				{ '$lookup' => { from => $invcoll->name,
											 localField => "inventory_id",
												 foreignField => "_id",
												 as =>  "parent"} },
				# then select the ones without parent
				{ '$match' => { parent => { '$size' => 0 } } },
				# then give me just the inventory ids
				{ '$project'  => { '_id' =>  1 } }]);
		if ($error)
		{
			$logger->error("$collname aggregation failed: $error");
			return "$collname aggregation failed: $error";
		}

		my @ditchables = map { $_->{_id} } (@$goners);
		if (!@ditchables)
		{
			$logger->debug("No orphaned $concept records detected.");
		}
		elsif ($simulate)
		{
			$logger->info("cleanup would remove ".scalar(@ditchables)
										. " orphaned timed $concept records, but not in simulation mode.");
		}
		else
		{
			my $res = NMISNG::DB::remove(collection => $timedcoll,
																	 query => NMISNG::DB::get_query(
																	 and_part => { _id => \@ditchables }));
			if (!$res->{success})
			{
				$logger->error("failed to remove $collname instances: $res->{error}");
				return "failed to remove $collname instances: $res->{error}";
			}
			$logger->info("removed $res->{removed_records} orphaned timed records for $concept.");
		}
	}

	$logger->info("Database cleanup complete");
	return undef;
}

# resave nodes, forces lastupdate to be new and all validation to be run
sub noderefresh
{
	my $updated = 0;
	# get all nodes
	my $md = $nmisng->get_nodes_model( name => $Q->{node} );
	my $object_ret = $md->objects();
	if( $object_ret->{success} )
	{
		foreach my $node ( @{$object_ret->{objects}} )
		{
			# tell the node it's dirty so the save happens
			$node->_dirty(1,"nothing");
			my ($op,$error) = $node->save();
			if( $op < 1 || $error )
			{
				print "Error saving: ".$node->name.", op:$op, error: $error"
			}
			else
			{
				$updated++;
			}
		}
	}
	else
	{
		print "Error making node objects: $object_ret->{error}\n";
	}
	print "total nodes: ".$md->count.", updated:$updated\n";
}
