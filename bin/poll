#!/usr/bin/perl
#
#  Copyright 1999-2014 Opmantek Limited (www.opmantek.com)
#
#  ALL CODE MODIFICATIONS MUST BE SENT TO CODE@OPMANTEK.COM
#
#  This file is part of Network Management Information System ("NMIS").
#
#  NMIS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  NMIS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with NMIS (most likely in a file named LICENSE).
#  If not, see <http://www.gnu.org/licenses/>
#
#  For further information on NMIS or for a license other than GPL please see
#  www.opmantek.com or email contact@opmantek.com
#
#  User group details:
#  http://support.opmantek.com/users/
#
# *****************************************************************************
use strict;
our $VERSION="9.0.0a";

if ( @ARGV == 1 && $ARGV[0] eq "--version" )
{
	print "version=$VERSION\n";
	exit 0;
}

# local modules live in <nmis-base>/lib
use FindBin;
use lib "$FindBin::Bin/../lib";


use Cwd qw();
use Time::HiRes;
use Socket;
use Net::SNMP qw(oid_lex_sort);
use Net::DNS;	# used for plotting major events on world map in 'Current Events' display
use Proc::ProcessTable;
use Proc::Queue ':all';
use Data::Dumper;
use File::Find;
use File::Spec;
use Clone;
use Carp::Assert;
# use Statistics::Lite qw(mean);
use POSIX qw(:sys_wait_h);
# this imports the LOCK_ *constants (eg. LOCK_UN, LOCK_EX), also the stat modes
use Fcntl qw(:DEFAULT :flock :mode);
use Errno qw(EAGAIN ESRCH EPERM);

use Compat::NMIS;
use Compat::Timing;

use NMISNG::Util;
use NMISNG::Ping;
use NMISNG::Sapi;
use Compat::IP;
use NMISNG::Notify;
use NMISNG::rrdfunc;

use NMISNG::MIB;
use NMISNG::Sys;


my $usage = "NMIS Polling Engine - Network Management Information System

Copyright (C) Opmantek Limited (www.opmantek.com)
This program comes with ABSOLUTELY NO WARRANTY;
This is free software licensed under GNU GPL, and you are welcome to
redistribute it under certain conditions; see www.opmantek.com or email
contact\@opmantek.com

NMIS version $Compat::NMIS::VERSION

Usage: $0 [option=value...]

options:
  type=<action>, default=collect
      collect   NMIS will collect all statistics (incl. Services)
      update    Update all the dynamic NMIS configuration
      threshold Calculate thresholds
      services  Run Services data collection only
      escalate  Run the escalation routine only ( debug use only)
      links     Update the Links.nmis file.
  [conf=<file name>]     Optional alternate configuation file in conf directory
  [node=<node name>]     Run operations on a single node;
  [group=<group name>]   Run operations on all nodes in the named group;
  [force=true|false]     Makes operations run from scratch, ignoring interval policies
  [debug=true|false|0-9] default=false - Show debugging information
  [mthread=true|false]   Enable Multithreading or not;
  [mthreaddebug=true|false] default=false - Extra debug for Multithreading code;
  [maxthreads=<1..XX>]   How many threads should nmis use, at most\n\n";

die $usage if (@ARGV == 1 && $ARGV[0] =~ /^(-h|--help|-\?)$/);

# Variables for command line munging
my %nvp = %{ NMISNG::Util::get_args_multi(@ARGV) };

# load configuration table, memorize startup time
my $starttime = Time::HiRes::time;

my $customconfdir = $nvp{dir}? $nvp{dir}."/conf": undef;

my $C = NMISNG::Util::loadConfTable( dir => $customconfdir,
																		 debug => $nvp{debug},
																		 info => $nvp{info} );
die "nmis cannot operate without config!\n" if ( ref($C) ne "HASH" );
NMISNG::rrdfunc::require_RRDs(config=>$C);

# and the status of the database dir, as reported by the selftest - 0 bad, 1 ok, undef unknown
# this is used by rrdfunc::createRRD(), so needs to be scoped suitably.
our $selftest_dbdir_status;
$selftest_dbdir_status = undef;

# check for global collection off or on
# useful for disabling nmis poll for server maintenance, nmis upgrades etc.
my $lockoutfile = $C->{'<nmis_conf>'} . "/NMIS_IS_LOCKED";

if ( -f $lockoutfile or NMISNG::Util::getbool( $C->{global_collect}, "invert" ) )
{
	# if nmis is locked, run a quick nondelay selftest so that we have something for the GUI
	my $varsysdir = $C->{'<nmis_var>'} . "/nmis_system";
	if ( !-d $varsysdir )
	{
		NMISNG::Util::createDir($varsysdir);
		NMISNG::Util::setFileProtDiag(file =>$varsysdir);
	}
	my $selftest_cache = "$varsysdir/selftest";

	my ( $allok, $tests ) = NMISNG::Util::selftest(
		config                 => $C,
		delay_is_ok            => 'false',
		report_database_status => \$selftest_dbdir_status,
		perms                  => 'false'
	);
	NMISNG::Util::writeHashtoFile(
		file => $selftest_cache,
		json => 1,
		data => {status => $allok, lastupdate => time, tests => $tests}
	);
	NMISNG::Util::info( "Selftest completed (status " . ( $allok ? "ok" : "FAILED!" ) . "), cache file written" );
	if ( -f $lockoutfile )
	{
		my $installerpresence = "/tmp/nmis_install_running";

		# installer should not need to lock this box for more than a few minutes
		if ( -f $installerpresence && ( stat($installerpresence) )[9] > time - 3600 )
		{
			NMISNG::Util::logMsg("INFO NMIS is currently disabled, installer is performing upgrade, exiting.");
			exit(0);
		}
		else
		{
			NMISNG::Util::logMsg("WARNING NMIS is currently disabled! Remove the file $lockoutfile to re-enable.");
			die "Attention: NMIS is currently disabled!\nRemove the file $lockoutfile to re-enable.\n\n";
		}
	}
	else
	{
		die
			"Attention: NMIS is currently disabled!\nSet the configuration variable \"global_collect\" to \"true\" to re-enable.\n\n";
	}
}

# note: 
my $type     = $nvp{type};
my $node     = $nvp{node};
my $group =  $nvp{group};
my $sleep    = $nvp{sleep};

### 2012-12-03 keiths, adding some model testing and debugging options.
my $model = NMISNG::Util::getbool( $nvp{model} );

# multiprocessing: commandline overrides config
my $mthread    = ( exists $nvp{mthread}    ? $nvp{mthread}    : $C->{nmis_mthread} )    || 0;
my $maxThreads = ( exists $nvp{maxthreads} ? $nvp{maxthreads} : $C->{nmis_maxthreads} ) || 1;

my $mthreadDebug = $nvp{mthreaddebug};    # cmdline only for this debugging flag

# park the list of collect/update plugins globally
my @active_plugins;

Proc::Queue::size($maxThreads); # changing limit of concurrent processes
Proc::Queue::trace(0);          # trace mode on
Proc::Queue::debug(0);          # debug is off
Proc::Queue::delay(0);

$type //= "collect";

print qq/
Copyright (C) Opmantek Limited (www.opmantek.com)
This program comes with ABSOLUTELY NO WARRANTY;
This is free software licensed under GNU GPL, and you are welcome to
redistribute it under certain conditions; see www.opmantek.com or email
contact\@opmantek.com

NMIS version $Compat::NMIS::VERSION

/ if $nvp{debug} or $nvp{info};


if ( $type =~ /^(collect|update|services)$/ )
{
	runThreads( type => $type, 
							node => $node, group => $group, 
							mthread => $mthread, mthreadDebug => $mthreadDebug );
}
elsif ( $type eq "escalate" ) { Compat::NMIS::new_nmisng->process_escalations(); printRunTime(); }    # included in type=collect
elsif ( $type eq "links" )      { Compat::NMIS::new_nmisng->update_links; } # included in type=update
elsif ( $type eq "threshold" )  { runThreshold($node,1); printRunTime(); }                   # USUALLY included in type=collect
else
{
	die $usage;
}
exit 0;


# run collection-type functions, possibly spread across multiple processes
sub runThreads
{
	my %args         = @_;
	my $type         = $args{type};
	my $node_select  = $args{node};
	my $group_select = $args{group};
	my $mthread      = NMISNG::Util::getbool( $args{mthread} );
	my $mthreadDebug = NMISNG::Util::getbool( $args{mthreadDebug} );

	
	die "Unknown operation type=$type, terminating!\n"
			if ($type !~ /^(update|collect|services)$/);
			
	NMISNG::Util::dbg("Starting, operation is $type");

	# do a selftest and cache the result, but not too often
	# this takes about five seconds (for the process stats)
	# however, DON'T do one if nmis is run in handle-just-this-node mode
	# which shouldn't be delayed at all. ditto for (possibly VERY) frequent type=services
	if ( !$node_select and $type ne "services" )
	{
		NMISNG::Util::info("Ensuring correct permissions on conf and model directories...");
		NMISNG::Util::setFileProtDirectory( $C->{'<nmis_conf>'},   1 );    # do recurse
		# that's the dir for custom models
		NMISNG::Util::createDir($C->{'<nmis_models>'}) if (!-d $C->{'<nmis_models>'});
		NMISNG::Util::setFileProtDirectory( $C->{'<nmis_models>'}, 0 );    # no recursion required
		# that's the dir of shipped=default models
		NMISNG::Util::setFileProtDirectory( $C->{'<nmis_default_models>'}, 0 );    # no recursion required


		my $varsysdir = $C->{'<nmis_var>'} . "/nmis_system";
		if ( !-d $varsysdir )
		{
			NMISNG::Util::createDir($varsysdir);
			NMISNG::Util::setFileProtDiag(file =>$varsysdir);
		}

		my $selftest_cache = "$varsysdir/selftest";


		# fixme9 consult schedule_selftest, schedule_permission_test
		# fixme9 make self-contained

		# check the current state, to see if a perms check is due? once every 2 hours
		my $laststate = NMISNG::Util::readFiletoHash( file => $selftest_cache, json => 1 );
		# check if a selftest is due? once every 15 minutes
		my $wantselftestnow = 1 if (ref($laststate) ne "HASH"
																|| !defined($laststate->{lastupdate})
																|| ($laststate->{lastupdate} + 900 < time));
		# check the current state, to see if a perms check is due? once every 2 hours
		my $wantpermsnow = 1 if (ref($laststate) ne "HASH"
														 || !defined($laststate->{lastupdate_perms})
														 || $laststate->{lastupdate_perms} + 7200 < time);

		if ($wantselftestnow)
		{
			NMISNG::Util::info("Starting selftest (takes about 5 seconds)...");

			my ( $allok, $tests ) = NMISNG::Util::selftest(
				config                 => $C,
				delay_is_ok            => 'true',
				perms                  => $wantpermsnow,
				report_database_status => \$selftest_dbdir_status
					);

		# keep the old permissions state if this test did not run a permissions test
		# hardcoded test name isn't great, though.
		if ( !$wantpermsnow )
		{
			$laststate ||= {tests => []};

			my ($oldstate) = grep( $_->[0] eq "Permissions",
														 @{$laststate->{tests}} );    # there will at most one
			if ( defined $oldstate )
			{
				my ($targetidx) = grep( $tests->[$_]->[0] eq "Permissions",
																( 0 .. $#{$tests} ) );
				if ( defined $targetidx )
				{
					$tests->[$targetidx] = $oldstate;
				}
				else
				{
					push @$tests, $oldstate;
				}
				$allok = 0 if ( $oldstate->[1] );                                         # not ok until that's cleared
			}
		}

			NMISNG::Util::writeHashtoFile(
				file => $selftest_cache,
				json => 1,
				data => {
					status           => $allok,
					lastupdate       => time,
					lastupdate_perms => (
					  $wantpermsnow ? time
						: $laststate    ? $laststate->{lastupdate_perms}
						:                 undef
							),
								tests => $tests
				}
					);
			NMISNG::Util::info( "Selftest completed (status " . ( $allok ? "ok" : "FAILED!" ) . "), cache file written" );
		}
		else
		{
			NMISNG::Util::info("Skipping selftest, last run at "
												 . NMISNG::Util::returnDateStamp($laststate->{lastupdate}));
		}
	}

	# load all the files we need here
	Compat::NMIS::loadEnterpriseTable() if $type eq 'update';    # load in cache
	NMISNG::Util::dbg( "table Enterprise loaded", 2 );

	my $NT = Compat::NMIS::loadLocalNodeTable();                 # only local nodes
	NMISNG::Util::dbg( "table Local Node loaded", 2 );

	my $C = NMISNG::Util::loadConfTable();    # config table from cache

	# load the fping results now and cache them for all child processes
	my $pt = NMISNG::Util::loadTable(dir=>'var',name=>'nmis-fping')
			if (NMISNG::Util::getbool($C->{daemon_fping_active}));
	NMISNG::Util::dbg("all relevant tables loaded");

	my $nmisng = Compat::NMIS::new_nmisng();
	runDaemons();    # (re)start daemon processes

	# the signal handler handles termination more-or-less gracefully,
	# and knows about critical sections
	$SIG{INT}  = \&catch_zap;
	$SIG{TERM} = \&catch_zap;
	$SIG{HUP}  = \&catch_zap;
	$SIG{ALRM} = \&catch_zap;

	my $nodecount = 0;
	my $maxprocs  = 1;    # this one

	NMISNG::Util::logMsg("INFO start of $type process");

	my $maxruntime = defined( $C->{max_child_runtime} )
			&& $C->{max_child_runtime} > 0 ? $C->{max_child_runtime} : 0;


	# what to work on? one or more named node; the members of a one ore more groups or all nodes
	# iff active and the polling policy agrees, that is...
	my @select;  
	push @select, { name => $node_select } if ((ref($node_select) eq "ARRAY") or (!ref($node_select) and $node_select));
	push @select, { group => $group_select }  if ((ref($group_select) eq "ARRAY") or (!ref($group_select) and $group_select));

	my $whattodo = $nmisng->find_due_nodes(type => $type,
																				 force => NMISNG::Util::getbool($nvp{force}),
																				 filters => \@select);

	die "Failed to find candidate nodes: $whattodo->{error}\n" if (!$whattodo->{success});
	if (ref($whattodo->{nodes}) ne "HASH" or !keys %{$whattodo->{nodes}})
	{
		NMISNG::Util::info("Found no nodes due for $type.");
		NMISNG::Util::logMsg("Found no nodes due for $type.");
		return;
	}
			
	my @list_of_handled_nodes;		# for any after_x_plugin() functions
	# logmsg not useful for services, separate per-service policy in force
	NMISNG::Util::logMsg("INFO Selected nodes for $type: "
											 .join(" ", sort map { $_->{name} } (values %{$whattodo->{nodes}}))) 
			if ($type ne "services");
	
	$mthread = 0 if (keys %{$whattodo->{nodes}} <= 1); # multiprocessing makes no sense with just one todo node

	# now perform process safety operations
	# test if there are any collect processes running for any of the todo nodes
	if ( $type eq 'collect' or $type eq "update")
	{
		# unrelated to process safety stuff but also for collect and update only
		@active_plugins = $nmisng->plugins;

		for my $onenode (keys %{$whattodo->{nodes}})
		{
			my $problematic = ref($whattodo->{processes}) eq "HASH" && ref($whattodo->{processes}->{$onenode}) eq "HASH"?
					$whattodo->{processes}->{$onenode} : {};
			
			next if (!keys %$problematic);

			# if this is a collect and if told to ignore running processes (ignore_running=1/t),
			# then only warn about processes and don't shoot them.
			if ($type eq "collect" and NMISNG::Util::getbool($nvp{ignore_running}))
			{
				for my $pid (keys %$problematic)
				{
					NMISNG::Util::logMsg("INFO ignoring old $type process $pid that is still running: $problematic->{$pid}->{node}, started at ".NMISNG::Util::returnDateStamp($problematic->{$pid}->{start}));
				}
			}
			else
			{
				my $eventconfig = NMISNG::Util::loadTable(dir => 'conf', name => 'Events');
				my $event = "NMIS runtime exceeded";
				my $thisevent_control = $eventconfig->{$event} || { Log => "true", Notify => "true", Status => "true"};
				
				# if not told otherwise, shoot the others politely
				my $needgrace;

				for my $pid (keys %$problematic)
				{
					next if ($pid <= 1 or $pid == $$);	# certainly not shooting init

					$needgrace = 1;
					print STDERR "Error: killing old NMIS $type process $pid ($problematic->{$pid}->{node}) which has not finished!\n"
							if ( !NMISNG::Util::getbool($C->{verbose_nmis_process_events},
																					"invert")); # === if ne false
					NMISNG::Util::logMsg("ERROR killing old NMIS $type process $pid ($problematic->{$pid}->{node}) which has not finished!");
					kill("TERM",$pid);
					
					# and raise an event to inform the operator - unless told NOT to
					# ie: either disable_nmis_process_events is set to true OR the event control Log property is set to false
					if ((!defined $C->{disable_nmis_process_events}
							 or !NMISNG::Util::getbool($C->{disable_nmis_process_events})
							 and NMISNG::Util::getbool($thisevent_control->{Log})))
					{
						# logging this event as the node name so it shows up as a problem with the node
						$nmisng->events->logEvent(node_name => $problematic->{$pid}->{node},
																			event => $event,
																			level => "Warning",
																			element => $problematic->{$pid}->{node},
																			details => "Killed process $pid, $type of $problematic->{$pid}->{node}, started at "
																			.NMISNG::Util::returnDateStamp($problematic->{$pid}->{start}));
					}
				}

				if ($needgrace) # give the others a moment to shut down cleanly
				{
					my $grace = 2;
					NMISNG::Util::logMsg("INFO sleeping for $grace seconds to let old NMIS processes clean up");
					sleep($grace);
				}
			}
		}
	}

	# ready for actual work, we hope...
	for my $uuid (keys %{$whattodo->{nodes}})
	{
		my $nodename = $whattodo->{nodes}->{$uuid}->{name};
		++$nodecount;
		push @list_of_handled_nodes, $nodename;

		# One process per node, until maxThreads is reached (then block and wait)
		if ($mthread)
		{
			my $pid=fork;
			if ( defined ($pid) and $pid==0)
			{
				srand();
				# this will be run only by the child
				print "CHILD $$-> I am a CHILD with the PID $$ processing $nodename ($uuid)\n"
						if ($mthreadDebug);
				
				# make sure this gets a NEW nmisng object, with NEW database handles!
				$nmisng = Compat::NMIS::new_nmisng(nocache => 1);
				my $node = $nmisng->node(uuid => $uuid);
				die "Failed to create node object for $nodename ($uuid)!\n" 
						if (ref($node) ne "NMISNG::Node");

				# don't run longer than X seconds
				alarm($maxruntime) if ($maxruntime);
				
				my @methodargs = (starttime => $starttime, force => NMISNG::Util::getbool($nvp{force}));
				push @methodargs, (wantsnmp => NMISNG::Util::getbool($nvp{force}) ||  $whattodo->{flavours}->{$uuid}->{snmp},
													 wantwmi => NMISNG::Util::getbool($nvp{force}) || $whattodo->{flavours}->{$uuid}->{wmi})
						if ($type eq "collect"); # flavours irrelevant for update

				$node->$type(@methodargs);
				
				# all the work in this thread is done now this child will die.
				print "CHILD $$-> $nodename ($uuid) is done, exiting\n"
						if ($mthreadDebug);
				exit 0;
			} # end of child
			else
			{
				# parent
				my $others = NMISNG::Util::find_nmis_processes(config => $C);
				my $procs_now = 1 + scalar keys %$others; # the current process isn't returned
				$maxprocs = $procs_now if $procs_now > $maxprocs;
			}
		}
		else
		{
			# just one node or no multi-processing wanted -> work in this process.
			alarm($maxruntime);

			my $node = $nmisng->node(uuid => $uuid);
			die "Failed to create node object for $nodename ($uuid)!\n" 
					if (ref($node) ne "NMISNG::Node");
			
			my @methodargs = (starttime => $starttime, force => NMISNG::Util::getbool($nvp{force}));
			# try both flavours if force is on
			push @methodargs, (wantsnmp => NMISNG::Util::getbool($nvp{force}) ||  $whattodo->{flavours}->{$uuid}->{snmp},
												 wantwmi => NMISNG::Util::getbool($nvp{force}) || $whattodo->{flavours}->{$uuid}->{wmi},)
					if ($type eq "collect"); # flavours irrelevant for update

			# would like to retain the non-collect/update cmdline...and restore it once done
			my $oldargs=$0;
			$node->$type(@methodargs);
			alarm(0) if ($maxruntime);
			$0=$oldargs;
		}
	}
	# outermost parent process: collects exit codes
	if ($mthread)
	{
		print "PARENT $$-> waiting for child processes to complete...\n"
						if ($mthreadDebug);
		# wait blockingly until all worker children are done
		1 while wait != -1;
	}

	my $collecttime = Time::HiRes::time();
	my $S;

	# on update prime the interface summary
	if ( $type eq "update" )
	{
		if ( !NMISNG::Util::getbool( $C->{disable_interfaces_summary} ) )
		{
			getIntfAllInfo();    # concatencate all the interface info in <nmis_var>/nmis-interfaces.xxxx
			$nmisng->update_links;
		}
	}

	# some collect post-processing
	elsif ( $type eq "collect")
	{
		$S = NMISNG::Sys->new;           # object nmis-system
		$S->init();

		NMISNG::Util::dbg("Starting runMetrics");
		runMetrics( sys => $S );

		# thresholds can be run: independent (=t_p_n and t_p_c false), post-collect (=t_p_n false, t_p_c true),
		# or combined with collect (t_p_n true, t_p_c ignored)
		if ( !NMISNG::Util::getbool( $C->{threshold_poll_node} ) )
		{
			# not false
			if ( !NMISNG::Util::getbool( $C->{threshold_poll_cycle}, "invert" ) )
			{
				NMISNG::Util::dbg("Starting runThreshold (for all selected nodes)");
				# the 0 here tells it that it's running in a collect cycle
				# fixme9: teach this to run on N nodes, not all and not just one!
				runThreshold(undef, 0);
			}
			else
			{
				NMISNG::Util::dbg("Skipping runThreshold with configuration 'threshold_poll_cycle' = $C->{'threshold_poll_cycle'}");
			}
		}

		NMISNG::Util::dbg("Starting escalation processing");
		$nmisng->process_escalations;

		# nmis collect runtime, process counts and save
		my $D = {};
		$D->{collect}{value}  = $collecttime - $starttime;
		$D->{collect}{option} = 'gauge,0:U';
		$D->{total}{value}    = Time::HiRes::time() - $starttime;
		$D->{total}{option}   = 'gauge,0:U';

		my $nr_processes = 1
			+ scalar %{&NMISNG::Util::find_nmis_processes( config => $C )};  # current one isn't returned by find_nmis_processes
		$D->{nr_procs} = {
			option => "gauge,0:U",
			value  => $nr_processes
		};
		$D->{max_procs} = {
			option => "gauge,0:U",
			value  => $maxprocs
		};

		if (!$S->create_update_rrd( data => $D, type => "nmis" ))
		{
			NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
		}
	}

	if ( $type eq "collect" or $type eq "update" )
	{
		my $pollTimer = Compat::Timing->new;

		# now run all after_{collect,update}_plugin() functions, regardless of whether
		# this was a one-node or all-nodes run
		for my $plugin (@active_plugins)
		{
			my $funcname = $plugin->can("after_${type}_plugin");
			next if ( !$funcname );

			# prime the global sys object, if this was an update run or a one-node collect
			if ( !$S )
			{
				$S = NMISNG::Sys->new;    # the nmis-system object
				$S->init();
			}

			NMISNG::Util::dbg("Running after_$type plugin $plugin");
			NMISNG::Util::logMsg("Running after_$type plugin $plugin");
			$nmisng->log->logprefix("$plugin ");
			my ( $status, @errors );
			eval { ( $status, @errors ) = &$funcname( sys => $S,
																								config => $C,
																								nodes => \@list_of_handled_nodes,
																								nmisng => $nmisng, ); };
			$nmisng->log->logprefix(undef);
			if ( $status >= 2 or $status < 0 or $@ )
			{
				NMISNG::Util::logMsg("Error: Plugin $plugin failed to run: $@") if ($@);
				for my $err (@errors)
				{
					NMISNG::Util::logMsg("Error: Plugin $plugin: $err");
				}
			}
			elsif ( $status == 1 )    # changes were made, need to re-save info file
			{
				NMISNG::Util::dbg("Plugin $plugin indicated success, updating nmis-system file");
				$S->writeNodeInfo;
			}
			elsif ( $status == 0 )
			{
				NMISNG::Util::dbg("Plugin $plugin indicated no changes");
			}
		}
		NMISNG::Util::logMsg( "Poll Time: After $type Plugins " . $pollTimer->elapTime() )
			if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) );
	}

	NMISNG::Util::logMsg("INFO end of $type process");

	if ( $nvp{info} or $nvp{debug} or $mthreadDebug )
	{
		my $endTime = sprintf( "%.2f", Time::HiRes::time() - $starttime );
		my $stats = NMISNG::rrdfunc::getUpdateStats();
		print "\n"
			. NMISNG::Util::returnTime()
			. " Number of Data Points: $stats->{datapoints}, Sum of Bytes: $stats->{databytes}, RRDs updated: $stats->{rrdcount}, Nodes with Updates: $stats->{nodecount}\n";
		print "\n" . NMISNG::Util::returnTime . " End of $0 Processed $nodecount nodes ran for $endTime seconds.\n\n";
	}

	NMISNG::Util::dbg("Finished");
	return;
}

# generic signal handler, but with awareness of code in critical sections
# also handles SIGALARM, which we cop if the process has run out of time
sub catch_zap
{
	my $rs = $_[0];

	# if we've run out of our allocated run time, raise an event to inform the operator
	# unless told NOT to... fixme: we can't check the events control table here as that might block.
	if ($rs eq "ALRM"
		and (  !defined $C->{disable_nmis_process_events}
			or !NMISNG::Util::getbool( $C->{disable_nmis_process_events} ) )
		)
	{
		Compat::NMIS::new_nmisng->events->logEvent(
			node_name    => $C->{server_name},
			event   => "NMIS runtime exceeded",
			level   => "Warning",
			element => undef,
			details => "Process $$, $0, has exceeded its max run time and is terminating"
		);
	}

	# do a graceful shutdown if in critical, and if this is the FIRST interrupt
	my $pending_ints = NMISNG::Util::interrupt_pending;    # scalar ref
	if ( NMISNG::Util::in_critical_section && !$$pending_ints )
	{
		# do NOT lock the logfile
		NMISNG::Util::logMsg( "INFO process in critical section, marking as signal $rs pending", 1 );
		++$$pending_ints;
	}
	else
	{
		# do NOT lock the logfile
		NMISNG::Util::logMsg( "INFO Process $$ ($0) was killed by signal $rs", 1 );
		die "Process $$ ($0) was killed by signal $rs\n"
				if (!NMISNG::Util::getbool($C->{verbose_nmis_process_events},"invert")); # === if ne false
		exit 0;
	}
}

#====================================================================================


#=========================================================================================

# fixme9 rework required! no longer reachable at all!


# this function runs ONLY NON-SNMP services!
# args: only name (node name)
# returns: nothing
sub doServices
{
	my (%args) = @_;
	my $name = $args{name};

	NMISNG::Util::info("================================");
	NMISNG::Util::info("Starting services, node $name");

	# lets change our name for process runtime checking
	$0 = "poll-services-$name";

	my $S = NMISNG::Sys->new;
	$S->init( name => $name );

	my $catchall_inventory = $S->inventory(concept => 'catchall');
	$S->nmisng->log->fatal("Failed to load catchall inventory for node:$name") && return if(!$catchall_inventory);
	# catchall uses 'live' data which is a direct reference to the data because it's too easy to
	# end up with stale/wrong data with all the functions using it
	my $catchall_data = $catchall_inventory->data_live();

	# look for any current outages with options.nostats set,
	# and set a marker in catchall so that updaterrd writes nothing but 'U'
	my $outageres = NMISNG::Outage::check_outages(node => $S->nmisng_node, time => time);
	if (!$outageres->{success})
	{
		$S->nmisng->log->error("Failed to check outage status for $name: $outageres->{error}");
	}
	else
	{
		$catchall_data->{admin}->{outage_nostats} = ( List::Util::any { ref($_->{options}) eq "HASH"
																																				&& $_->{options}->{nostats} }
																									@{$outageres->{current}}) ? 1:0;
	}

	$S->readNodeView;    # init does not load the node view, but runservices updates view data!
	runServices( sys => $S, snmp => 'false' );

	# we have to update the node view file, or newly added service status info will be lost/missed...
	$S->writeNodeView;

	return;
}









#=========================================================================================














#=========================================================================================





#=========================================================================================


#=========================================================================================








#=========================================================================================

# this generates the data for nmis-interfaces.json,
# NOTE: this should not be required for NMISNG
sub getIntfAllInfo
{
	my $index;
	my $tmpDesc;
	my $intHash;
	my %interfaceInfo;

	### 2013-08-30 keiths, restructured to avoid creating and loading large Interface summaries
	if ( NMISNG::Util::getbool( $C->{disable_interfaces_summary} ) )
	{
		NMISNG::Util::logMsg("getIntfAllInfo disabled with disable_interfaces_summary=$C->{disable_interfaces_summary}");
		return;
	}

	NMISNG::Util::dbg("Starting");

	NMISNG::Util::dbg("Getting Interface Info from all nodes");

	my $nmisng = Compat::NMIS::new_nmisng();
	my $get_node_uuids = $nmisng->get_node_uuids( filter => { cluster_id => $C->{cluster_id} } );
	# Write a node entry for each node
	foreach my $node_uuid ( sort @$get_node_uuids )
	{

		my $nmisng_node = $nmisng->node( uuid => $node_uuid );
		my $node_name = $nmisng_node->name();
		my $configuration = $nmisng_node->configuration;
		if ( NMISNG::Util::getbool( $configuration->{active} ) and NMISNG::Util::getbool( $configuration->{collect} ) )
		{
			# ony grab active interfaces
			my $ids = $nmisng_node->get_inventory_ids(concept => 'interface', filter => { enabled => 1, historic => 0});
			NMISNG::Util::dbg( "ADD node=$node_name", 3 );
			NMISNG::Util::logMsg("INFO empty interface info file of node $node_name") if(!$ids || @$ids < 1);
			foreach my $id ( @$ids )
			{
				my ($inventory,$error_message) = $nmisng_node->inventory( _id => $id );

				$nmisng->log->error("Failed to get inventory, error_message:$error_message") && next
					if(!$inventory);

				my $data = $inventory->data();
				$tmpDesc = &NMISNG::Util::convertIfName( $data->{ifDescr} );

				$intHash = "$node_name-$tmpDesc";

				NMISNG::Util::dbg( "$node_name $tmpDesc hash=$intHash $data->{ifDescr}", 3 );

				if ( $data->{ifDescr} ne "" )
				{
					NMISNG::Util::dbg( "Add node=$node_name interface=$data->{ifDescr}", 2 );
					my $source = $data;
					my $dest = $interfaceInfo{$intHash} ||= {};

					$dest->{node} = $node_name;
					# TODO: revive this if we still need this function
					# $dest->{sysName} = $info->{system}->{sysName};

					for my $copyme (
						qw(ifIndex ifDescr collect real ifType ifSpeed ifAdminStatus
						ifOperStatus ifLastChange Description display_name portModuleIndex portIndex portDuplex portIfIndex
						portSpantreeFastStart vlanPortVlan portAdminSpeed)
						)
					{
						$dest->{$copyme} = $source->{$copyme};
					}

					my $cnt = 1;
					while ( defined( $source->{"ipAdEntAddr$cnt"} ) )
					{
						for my $copymeprefix (qw(ipAdEntAddr ipAdEntNetMask ipSubnet ipSubnetBits))
						{
							my $copyme = $copymeprefix . $cnt;
							$dest->{$copyme} = $source->{$copyme};
						}
						$cnt++;
					}
				}
			}

		}
	}    # foreach $linkname
	     # Write the interface table out.
	NMISNG::Util::dbg("Writing Interface Info from all nodes");
	NMISNG::Util::writeTable( dir => 'var', name => "nmis-interfaces", data => \%interfaceInfo );
	NMISNG::Util::dbg("Finished");
}

#=========================================================================================



#=========================================================================================



#=========================================================================================

### Adding overall network metrics collection and updates
sub runMetrics
{
	my %args = @_;
	my $S    = $args{sys};

	my $GT = Compat::NMIS::loadGroupTable();

	my %groupSummary;
	my $data;
	my $group;
	my $status;

	my $pollTimer = Compat::Timing->new;

	NMISNG::Util::dbg("Starting");

	# Doing the whole network - this defaults to -8 hours span
	my $groupSummary = Compat::NMIS::getGroupSummary();
	$status                      = Compat::NMIS::overallNodeStatus;
	$status                      = Compat::NMIS::statusNumber($status);
	$data->{reachability}{value} = $groupSummary->{average}{reachable};
	$data->{availability}{value} = $groupSummary->{average}{available};
	$data->{responsetime}{value} = $groupSummary->{average}{response};
	$data->{health}{value}       = $groupSummary->{average}{health};
	$data->{status}{value}       = $status;
	$data->{intfCollect}{value}  = $groupSummary->{average}{intfCollect};
	$data->{intfColUp}{value}    = $groupSummary->{average}{intfColUp};
	$data->{intfAvail}{value}    = $groupSummary->{average}{intfAvail};


	# RRD options
	$data->{reachability}{option} = "gauge,0:100";
	$data->{availability}{option} = "gauge,0:100";
	### 2014-03-18 keiths, setting maximum responsetime to 30 seconds.
	$data->{responsetime}{option} = "gauge,0:30000";
	$data->{health}{option}       = "gauge,0:100";
	$data->{status}{option}       = "gauge,0:100";
	$data->{intfCollect}{option}  = "gauge,0:U";
	$data->{intfColUp}{option}    = "gauge,0:U";
	$data->{intfAvail}{option}    = "gauge,0:U";

	NMISNG::Util::dbg("Doing Network Metrics database reach=$data->{reachability}{value} avail=$data->{availability}{value} resp=$data->{responsetime}{value} health=$data->{health}{value} status=$data->{status}{value}"
	);

	my $db = $S->create_update_rrd( data => $data, type => "metrics", item => 'network' );
	if ( !$db )
	{
		NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
	}

	foreach $group ( sort keys %{$GT} )
	{
		$groupSummary = Compat::NMIS::getGroupSummary( group => $group );
		$status                      = Compat::NMIS::overallNodeStatus( group => $group );
		$status                      = Compat::NMIS::statusNumber($status);
		$data->{reachability}{value} = $groupSummary->{average}{reachable};
		$data->{availability}{value} = $groupSummary->{average}{available};
		$data->{responsetime}{value} = $groupSummary->{average}{response};
		$data->{health}{value}       = $groupSummary->{average}{health};
		$data->{status}{value}       = $status;
		$data->{intfCollect}{value}  = $groupSummary->{average}{intfCollect};
		$data->{intfColUp}{value}    = $groupSummary->{average}{intfColUp};
		$data->{intfAvail}{value}    = $groupSummary->{average}{intfAvail};

		NMISNG::Util::dbg("Doing group=$group Metrics database reach=$data->{reachability}{value} avail=$data->{availability}{value} resp=$data->{responsetime}{value} health=$data->{health}{value} status=$data->{status}{value}"
		);
		#
		$db = $S->create_update_rrd( data => $data, type => "metrics", item => $group );
		if ( !$db )
		{
			NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
		}
	}
	NMISNG::Util::dbg("Finished");

	NMISNG::Util::logMsg( "Poll Time: " . $pollTimer->elapTime() )
		if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) );

}    # end runMetrics

#=========================================================================================



#=========================================================================================

# starts up fpingd and/or opslad if desired and none present
# args: none
# returns: nothing
sub runDaemons
{
	my $C = NMISNG::Util::loadConfTable();

	# nothing to do, let's not waste any time on checking
	return  if (!NMISNG::Util::getbool($C->{daemon_fping_active})
							&& !NMISNG::Util::getbool($C->{daemon_ipsla_active}));

	NMISNG::Util::dbg("Starting");

	# check process table for presence of either
	my ($fpingd_found, $ipslad_found);

	my $pt = new Proc::ProcessTable();
	foreach my $pentry (@{$pt->table})
	{
		# fpingd is identifyable only by cmdline
		$fpingd_found = 1 if ($pentry->cmndline =~ $C->{daemon_fping_filename});
		$ipslad_found = 1 if ($pentry->fname eq $C->{daemon_ipsla_filename});
		last if ($fpingd_found && $ipslad_found);
	}


  # start fast ping daemon if desired and none is running,
	# or if the one that is running is in bad shape
	if (NMISNG::Util::getbool($C->{daemon_fping_active}))
	{
		my $fping_data_age = NMISNG::Util::mtimeFile(dir => 'var', name => 'nmis-fping');
		my $staleafter = $C->{daemon_fping_maxage} || 900; # nothing in 15 minutes?
		my $data_too_old = (time - $fping_data_age) > $staleafter;

		if ($data_too_old or !$fpingd_found)
		{
			NMISNG::Util::logMsg( !$fpingd_found? "INFO no $C->{daemon_fping_filename} running, will start one"
														: "INFO $C->{daemon_fping_filename} seems dead, last file update at $fping_data_age, will restart");

			my $fpingpath  = $C->{'<nmis_bin>'}."/".$C->{daemon_fping_filename};
			if (!-x $fpingpath)
			{
				NMISNG::Util::logMsg("ERROR cannot start fpingd, $fpingpath not executable!");
			}
			else
			{
				system($fpingpath, "restart=true");
				NMISNG::Util::logMsg("INFO launched $C->{daemon_fping_filename} daemon");
			}
		}
	}

	# ipsla daemon desired and in need of being started?
	if ( NMISNG::Util::getbool($C->{daemon_ipsla_active}) && !$ipslad_found)
	{
    if ( -x "$C->{'<nmis_bin>'}/$C->{daemon_ipsla_filename}" )
		{
			system("$C->{'<nmis_bin>'}/$C->{daemon_ipsla_filename}");
			NMISNG::Util::logMsg("INFO launched $C->{daemon_ipsla_filename} as daemon");
		}
		else
		{
			NMISNG::Util::logMsg("ERROR cannot run daemon $C->{'<nmis_bin>'}/$C->{daemon_ipsla_filename},$!");
		}
	}

	NMISNG::Util::dbg("Finished");
}

#=========================================================================================




#=========================================================================================

# run threshold calculation operation on all or one node, in a single loop
# args:
#   node - (optional),
#   running_independently - set to 1 if not in collect/outer loop that will do saves
# returns: nothing
# 
# fixme9: won't be able to run 'at end  of collect'
# fixme9: needs to be taught to run for N nodes which are not all and not just a single one!
sub runThreshold
{
	my ($node,$running_independently) = @_;

	# check global_threshold not explicitely set to false
	if ( !NMISNG::Util::getbool( $C->{global_threshold}, "invert" ) )
	{
		my $node_select;
		if ($node)
		{
			die "Invalid node=$node: No node of that name\n"
				if ( !( $node_select = Compat::NMIS::checkNodeName($node) ) );
		}

		Compat::NMIS::new_nmisng->doThresholdsAndCreateStatus( name => $node_select, 
																													 table => doSummaryBuild( name => $node_select ), 
																													 running_independently => $running_independently );
	}
	else
	{
		NMISNG::Util::dbg("Skipping runThreshold with configuration 'global_threshold' = $C->{'global_threshold'}");
	}
}

# fixme9: useful? required?
# fixme9: unclear what data is saved, and why under node name not uuid?
#
# collects (using getSummaryStats) and returns summary stats
# for one or all nodes, also writes two debug files.
#
# args: name (optional)
# returns: summary stats hash
sub doSummaryBuild
{
	my (%args) = @_;
	my $node = $args{name};

	my $nmisng = Compat::NMIS::new_nmisng();
	NMISNG::Util::dbg("Start of Summary Build");

	# load one requestd node or all node objects
	my %filter = ( active => 1, collect => 1 ); # only nodes both active and flagged for collect are relevant here
	$filter{name} = $node if ($node);
	my $selected = $nmisng->get_nodes_model(filter => \%filter);
	die "failed to lookup nodes: ".$selected->error."\n" if ($selected->error);

	my $res = $selected->objects;
	die "failed to instantiate nodes: $res->{error}\n" if (!$res->{success});
	
	my %stshlth;
	my %stats;
	my %stsintf;

	foreach my $nodeobj (@{$res->{objects}})
	{
		my $nd = $nodeobj->name;

		my $S = NMISNG::Sys->new;
		next if ( !$S->init( node => $nodeobj, snmp => 'false' ) ); # fixme: why not terminal?

		
		my $M  = $S->mdl;       # model ref
		my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

		next if NMISNG::Util::getbool( $catchall_data->{nodedown} );
		
		# oke, look for requests in summary of Model
		foreach my $tp ( keys %{$M->{summary}{statstype}} )
		{
			next if ( !exists $M->{system}->{rrd}->{$tp}->{threshold} );
			my $threshold_period = $nmisng->_threshold_period( subconcept => $tp );

			# check whether this is an indexed section, ie. whether there are multiple instances with
			# their own indices
			# fixme: this is wrong, $tp should be either graphtype OR section
			my @instances = $S->getTypeInstances( graphtype => $tp, section => $tp );
			if (@instances)
			{
				foreach my $i (@instances)
				{
					my $sts = Compat::NMIS::getSummaryStats(
						sys   => $S,
						type  => $tp,
						start => $threshold_period,
						end   => 'now',
						index => $i
							);
					
					# save all info from %sts for threshold run
					foreach ( keys %{$sts->{$i}} ) { $stats{$nd}{$tp}{$i}{$_} = $sts->{$i}{$_}; }

					foreach my $nm ( keys %{$M->{summary}{statstype}{$tp}{sumname}} )
					{
						$stshlth{ $catchall_data->{nodeType} }{$nd}{$nm}{$i}{Description}
						=  "WHAT GOES HERE? NI->label makes no sense";#$NI->{label}{$tp}{$i};    # descr
						# check if threshold level available, thresholdname must be equal to type
						if ( exists $M->{threshold}{name}{$tp} )
						{
							( $stshlth{ $catchall_data->{nodeType} }{$nd}{$nm}{$i}{level}, undef, undef )
									= $nmisng->getThresholdLevel( sys => $S, thrname => $tp, stats => $sts, index => $i );
						}
						
						# save values
						foreach my $stsname ( @{$M->{summary}{statstype}{$tp}{sumname}{$nm}{stsname}} )
						{
							$stshlth{ $catchall_data->{nodeType} }{$nd}{$nm}{$i}{$stsname} = $sts->{$i}{$stsname};
							NMISNG::Util::dbg("stored summary health node=$nd type=$tp name=$stsname index=$i value=$sts->{$i}{$stsname}"
									);
						}
					}
				}
			}

			# non-indexed
			else
			{
				my $dbname = $S->makeRRDname( graphtype => $tp );
				if ( $dbname && -r $dbname )
				{
					my $sts = Compat::NMIS::getSummaryStats( sys => $S, type => $tp, start => $threshold_period, end => 'now' );
					
					# save all info from %sts for threshold run
					foreach ( keys %{$sts} ) { $stats{$nd}{$tp}{$_} = $sts->{$_}; }
					
					# check if threshold level available, thresholdname must be equal to type
					if ( exists $M->{threshold}{name}{$tp} )
					{
						( $stshlth{ $catchall_data->{nodeType} }{$nd}{"${tp}_level"}, undef, undef )
								= $nmisng->getThresholdLevel( sys => $S, thrname => $tp, stats => $sts, index => '' );
					}
					foreach my $nm ( keys %{$M->{summary}{statstype}{$tp}{sumname}} )
					{
						foreach my $stsname ( @{$M->{summary}{statstype}{$tp}{sumname}{$nm}{stsname}} )
						{
							$stshlth{ $catchall_data->{nodeType} }{$nd}{$stsname} = $sts->{$stsname};
							NMISNG::Util::dbg("stored summary health node=$nd type=$tp name=$stsname value=$sts->{$stsname}");
						}
					}
				}
			}
			
			# reset the threshold period, may have been changed to threshold_period-<something>
			my $tp = "interface";
			$threshold_period = $nmisng->_threshold_period( subconcept => $tp );
			
			# this could maybe use the model and get collect right away as that's
			# all it seems to be used for right now
			my $ids = $nodeobj->get_inventory_ids( concept => 'interface', filter => { enabled => 1, historic => 0 } );
			# get all collected interfaces
			foreach my $id (@$ids)
			{
				my ($intf_inventory,$intf_error) = $nodeobj->inventory( _id => $id );
				my $data = $intf_inventory->data();
				my $index = $data->{index};
				
				my $sts = Compat::NMIS::getSummaryStats(
					sys   => $S,
					type  => $tp,
					start => $threshold_period,
					end   => time(),
					index => $index
						);
				foreach ( keys %{$sts->{$index}} )
				{
					$stats{$nd}{interface}{$index}{$_} = $sts->{$index}{$_};
				}    # save for threshold
				
				# copy all stats into the stsintf info.
				foreach ( keys %{$sts->{$index}} ) { $stsintf{"${index}.$S->{name}"}{$_} = $sts->{$index}{$_}; }
			}
		}
	}

	# these two tables are produced ONLY for debugging, they're not used by nmis
	NMISNG::Util::writeTable( dir => 'var', name => "nmis-summaryintf15m",   data => \%stsintf );
	NMISNG::Util::writeTable( dir => 'var', name => "nmis-summaryhealth15m", data => \%stshlth );
	NMISNG::Util::dbg("Finished");

	return \%stats;    # input for threshold process
}


sub printRunTime
{
	my $endTime = sprintf( "%.2f", Time::HiRes::time() - $starttime );
	NMISNG::Util::info("End of $0, type=$type ran for $endTime seconds.\n");
}


# *****************************************************************************
# Copyright (C) Opmantek Limited (www.opmantek.com)
# This program comes with ABSOLUTELY NO WARRANTY;
# This is free software licensed under GNU GPL, and you are welcome to
# redistribute it under certain conditions; see www.opmantek.com or email
# contact@opmantek.com
# *****************************************************************************
