#!/usr/bin/perl
#
#  Copyright 1999-2014 Opmantek Limited (www.opmantek.com)
#
#  ALL CODE MODIFICATIONS MUST BE SENT TO CODE@OPMANTEK.COM
#
#  This file is part of Network Management Information System ("NMIS").
#
#  NMIS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  NMIS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with NMIS (most likely in a file named LICENSE).
#  If not, see <http://www.gnu.org/licenses/>
#
#  For further information on NMIS or for a license other than GPL please see
#  www.opmantek.com or email contact@opmantek.com
#
#  User group details:
#  http://support.opmantek.com/users/
#
# *****************************************************************************
use strict;
our $VERSION="9.0.0a";

if ( @ARGV == 1 && $ARGV[0] eq "--version" )
{
	print "version=$VERSION\n";
	exit 0;
}

# local modules live in <nmis-base>/lib
use FindBin;
use lib "$FindBin::Bin/../lib";


use Cwd qw();
use Time::HiRes;
use Socket;
use Net::DNS;	# used for plotting major events on world map in 'Current Events' display
use Proc::ProcessTable;
use Proc::Queue ':all';
use Data::Dumper;
use File::Find;
use File::Spec;
use Clone;
use Carp::Assert;

use POSIX qw(:sys_wait_h);
# this imports the LOCK_ *constants (eg. LOCK_UN, LOCK_EX), also the stat modes
use Fcntl qw(:DEFAULT :flock :mode);
use Errno qw(EAGAIN ESRCH EPERM);

use NMISNG::Util;
use NMISNG::Sys;

use Compat::NMIS;
use Compat::Timing;

my $usage = "NMIS Polling Engine - Network Management Information System

Copyright (C) Opmantek Limited (www.opmantek.com)
This program comes with ABSOLUTELY NO WARRANTY;
This is free software licensed under GNU GPL, and you are welcome to
redistribute it under certain conditions; see www.opmantek.com or email
contact\@opmantek.com

NMIS version $Compat::NMIS::VERSION

Usage: $0 [option=value...]

options:
  type=<action>, default=collect
      collect   NMIS will collect all statistics (incl. Services)
      update    Update all the dynamic NMIS configuration
      threshold Calculate thresholds
      services  Run Services data collection only
      escalate  Run the escalation routine only ( debug use only)
  [conf=<file name>]     Optional alternate configuation file in conf directory
  [node=<node name>]     Run operations on a single node;
  [group=<group name>]   Run operations on all nodes in the named group;
  [force=true|false]     Makes operations run from scratch, ignoring interval policies
  [debug=true|false|0-9] default=false - Show debugging information
  [mthread=true|false]   Enable Multithreading or not;
  [mthreaddebug=true|false] default=false - Extra debug for Multithreading code;
  [maxthreads=<1..XX>]   How many threads should nmis use, at most\n\n";

die $usage if (@ARGV == 1 && $ARGV[0] =~ /^(-h|--help|-\?)$/);

# Variables for command line munging
my %nvp = %{ NMISNG::Util::get_args_multi(@ARGV) };

# load configuration table, memorize startup time
my $starttime = Time::HiRes::time;

my $customconfdir = $nvp{dir}? $nvp{dir}."/conf": undef;

my $C = NMISNG::Util::loadConfTable( dir => $customconfdir,
																		 debug => $nvp{debug},
																		 info => $nvp{info} );
die "nmis cannot operate without config!\n" if ( ref($C) ne "HASH" );
NMISNG::rrdfunc::require_RRDs(config=>$C);

# and the status of the database dir, as reported by the selftest - 0 bad, 1 ok, undef unknown
# this is used by rrdfunc::createRRD(), so needs to be scoped suitably.
our $selftest_dbdir_status;
$selftest_dbdir_status = undef;

# check for global collection off or on
# useful for disabling nmis poll for server maintenance, nmis upgrades etc.
my $lockoutfile = $C->{'<nmis_conf>'} . "/NMIS_IS_LOCKED";

if ( -f $lockoutfile )
{
	# if nmis is locked, run a quick nondelay selftest so that we have something for the GUI
	my $varsysdir = $C->{'<nmis_var>'} . "/nmis_system";
	if ( !-d $varsysdir )
	{
		NMISNG::Util::createDir($varsysdir);
		NMISNG::Util::setFileProtDiag(file =>$varsysdir);
	}
	my $selftest_cache = "$varsysdir/selftest";

	my ( $allok, $tests ) = NMISNG::Util::selftest(
		config                 => $C,
		delay_is_ok            => 'false',
		report_database_status => \$selftest_dbdir_status,
		perms                  => 'false'
	);
	NMISNG::Util::writeHashtoFile(
		file => $selftest_cache,
		json => 1,
		data => {status => $allok, lastupdate => time, tests => $tests}
	);
	NMISNG::Util::info( "Selftest completed (status " . ( $allok ? "ok" : "FAILED!" ) . "), cache file written" );

	my $installerpresence = "/tmp/nmis_install_running";
	# installer should not need to lock this box for more than a few minutes
	if ( -f $installerpresence && ( stat($installerpresence) )[9] > time - 3600 )
	{
		NMISNG::Util::logMsg("INFO NMIS is currently disabled, installer is performing upgrade, exiting.");
		exit(0);
	}
	else
	{
		NMISNG::Util::logMsg("WARNING NMIS is currently disabled! Remove the file $lockoutfile to re-enable.");
		die "Attention: NMIS is currently disabled!\nRemove the file $lockoutfile to re-enable.\n\n";
	}
}

my $type     = $nvp{type};
my $node     = $nvp{node};
my $group =  $nvp{group};

### 2012-12-03 keiths, adding some model testing and debugging options.
my $model = NMISNG::Util::getbool( $nvp{model} );

# multiprocessing: commandline overrides config
my $mthread    = ( exists $nvp{mthread}    ? $nvp{mthread}    : $C->{nmis_mthread} )    || 0;
my $maxThreads = ( exists $nvp{maxthreads} ? $nvp{maxthreads} : $C->{nmis_maxthreads} ) || 1;
my $mthreadDebug = $nvp{mthreaddebug};    # cmdline only for this debugging flag

Proc::Queue::size($maxThreads); # changing limit of concurrent processes
Proc::Queue::trace(0);          # trace mode on
Proc::Queue::debug(0);          # debug is off
Proc::Queue::delay(0);

$type //= "collect";

print qq/
Copyright (C) Opmantek Limited (www.opmantek.com)
This program comes with ABSOLUTELY NO WARRANTY;
This is free software licensed under GNU GPL, and you are welcome to
redistribute it under certain conditions; see www.opmantek.com or email
contact\@opmantek.com

NMIS version $Compat::NMIS::VERSION

/ if $nvp{debug} or $nvp{info};


if ( $type =~ /^(collect|update|services)$/ )
{
	runThreads( type => $type,
							node => $node, group => $group,
							mthread => $mthread, mthreadDebug => $mthreadDebug );
}
elsif ( $type eq "escalate" ) { Compat::NMIS::new_nmisng->process_escalations(); printRunTime(); }    # included in type=collect
elsif ( $type eq "threshold" )  { runThreshold(node => $node, group => $group); printRunTime(); } # normally part of type=collect
else
{
	die $usage;
}
exit 0;


# run collection-type functions, possibly spread across multiple processes
sub runThreads
{
	my %args         = @_;
	my $type         = $args{type};
	my $node_select  = $args{node};
	my $group_select = $args{group};
	my $mthread      = NMISNG::Util::getbool( $args{mthread} );
	my $mthreadDebug = NMISNG::Util::getbool( $args{mthreadDebug} );


	die "Unknown operation type=$type, terminating!\n"
			if ($type !~ /^(update|collect|services)$/);

	NMISNG::Util::dbg("Starting, operation is $type");

	# do a selftest and cache the result, but not too often
	# this takes about five seconds (for the process stats)
	# however, DON'T do one if nmis is run in handle-just-this-node mode
	# which shouldn't be delayed at all. ditto for (possibly VERY) frequent type=services
	# fixme9: goes away in daemon
	my $cachefileage = (stat("$C->{'<nmis_var>'}/nmis_system/selftest.json"))[9]; 
	if ( !$node_select and $type ne "services" 
			 and (time - $cachefileage > 900) )
	{
		NMISNG::Util::info("Starting selftest (takes about 5 seconds)...");
		
		my ( $allok, $tests ) = NMISNG::Util::selftest(
			config                 => $C,
			delay_is_ok            => 1,
			perms                  => (time - $cachefileage > 7200),
			report_database_status => \$selftest_dbdir_status
				);

		NMISNG::Util::info( "Selftest completed (status " . ( $allok ? "ok" : "FAILED!" ) . ")" );
	}

	# load all the files we need here
	Compat::NMIS::loadEnterpriseTable() if $type eq 'update';    # load in cache
	NMISNG::Util::dbg( "table Enterprise loaded", 2 );

	my $NT = Compat::NMIS::loadLocalNodeTable();                 # only local nodes
	NMISNG::Util::dbg( "table Local Node loaded", 2 );

	my $C = NMISNG::Util::loadConfTable();    # config table from cache

	# load the fping results now and cache them for all child processes
	my $pt = NMISNG::Util::loadTable(dir=>'var',name=>'nmis-fping')
			if (NMISNG::Util::getbool($C->{daemon_fping_active}));
	NMISNG::Util::dbg("all relevant tables loaded");

	my $nmisng = Compat::NMIS::new_nmisng();
	runDaemons();    # (re)start daemon processes

	# the signal handler handles termination more-or-less gracefully,
	# and knows about critical sections
	$SIG{INT}  = \&catch_zap;
	$SIG{TERM} = \&catch_zap;
	$SIG{HUP}  = \&catch_zap;
	$SIG{ALRM} = \&catch_zap;

	my $nodecount = 0;
	my $maxprocs  = 1;    # this one

	NMISNG::Util::logMsg("INFO start of $type process");

	my $maxruntime = defined( $C->{max_child_runtime} )
			&& $C->{max_child_runtime} > 0 ? $C->{max_child_runtime} : 0;


	# what to work on? one or more named node; the members of a one ore more groups or all nodes
	# iff active and the polling policy agrees, that is...
	my @select;
	push @select, { name => $node_select } if ((ref($node_select) eq "ARRAY") or (!ref($node_select) and $node_select));
	push @select, { group => $group_select }  if ((ref($group_select) eq "ARRAY") or (!ref($group_select) and $group_select));

	my $whattodo = $nmisng->find_due_nodes(type => $type,
																				 force => NMISNG::Util::getbool($nvp{force}),
																				 filters => \@select);

	die "Failed to find candidate nodes: $whattodo->{error}\n" if (!$whattodo->{success});
	if (ref($whattodo->{nodes}) ne "HASH" or !keys %{$whattodo->{nodes}})
	{
		NMISNG::Util::info("Found no nodes due for $type.");
		NMISNG::Util::logMsg("Found no nodes due for $type.");
		return;
	}

	my @list_of_handled_nodes;		# for any after_x_plugin() functions
	# logmsg not useful for services, separate per-service policy in force
	NMISNG::Util::logMsg("INFO Selected nodes for $type: "
											 .join(" ", sort map { $_->{name} } (values %{$whattodo->{nodes}})))
			if ($type ne "services");

	$mthread = 0 if (keys %{$whattodo->{nodes}} <= 1); # multiprocessing makes no sense with just one todo node

	my @active_plugins;
	# now perform process safety operations
	# test if there are any collect processes running for any of the todo nodes
	if ( $type eq 'collect' or $type eq "update")
	{
		# unrelated to process safety stuff but also for collect and update only
		@active_plugins = $nmisng->plugins;

		for my $onenode (keys %{$whattodo->{nodes}})
		{
			my $problematic = ref($whattodo->{processes}) eq "HASH" && ref($whattodo->{processes}->{$onenode}) eq "HASH"?
					$whattodo->{processes}->{$onenode} : {};

			next if (!keys %$problematic);

			# if this is a collect and if told to ignore running processes (ignore_running=1/t),
			# then only warn about processes and don't shoot them.
			if ($type eq "collect" and NMISNG::Util::getbool($nvp{ignore_running}))
			{
				for my $pid (keys %$problematic)
				{
					NMISNG::Util::logMsg("INFO ignoring old $type process $pid that is still running: $problematic->{$pid}->{node}, started at ".NMISNG::Util::returnDateStamp($problematic->{$pid}->{start}));
				}
			}
			else
			{
				my $eventconfig = NMISNG::Util::loadTable(dir => 'conf', name => 'Events');
				my $event = "NMIS runtime exceeded";
				my $thisevent_control = $eventconfig->{$event} || { Log => "true", Notify => "true", Status => "true"};

				# if not told otherwise, shoot the others politely
				my $needgrace;

				for my $pid (keys %$problematic)
				{
					next if ($pid <= 1 or $pid == $$);	# certainly not shooting init

					$needgrace = 1;
					print STDERR "Error: killing old NMIS $type process $pid ($problematic->{$pid}->{node}) which has not finished!\n"
							if ( !NMISNG::Util::getbool($C->{verbose_nmis_process_events},
																					"invert")); # === if ne false
					NMISNG::Util::logMsg("ERROR killing old NMIS $type process $pid ($problematic->{$pid}->{node}) which has not finished!");
					kill("TERM",$pid);

					# and raise an event to inform the operator - unless told NOT to
					# ie: either disable_nmis_process_events is set to true OR the event control Log property is set to false
					if ((!defined $C->{disable_nmis_process_events}
							 or !NMISNG::Util::getbool($C->{disable_nmis_process_events})
							 and NMISNG::Util::getbool($thisevent_control->{Log})))
					{
						# logging this event as the node name so it shows up as a problem with the node
						$nmisng->events->logEvent(node_name => $problematic->{$pid}->{node},
																			event => $event,
																			level => "Warning",
																			element => $problematic->{$pid}->{node},
																			details => "Killed process $pid, $type of $problematic->{$pid}->{node}, started at "
																			.NMISNG::Util::returnDateStamp($problematic->{$pid}->{start}));
					}
				}

				if ($needgrace) # give the others a moment to shut down cleanly
				{
					my $grace = 2;
					NMISNG::Util::logMsg("INFO sleeping for $grace seconds to let old NMIS processes clean up");
					sleep($grace);
				}
			}
		}
	}

	# ready for actual work, we hope...
	for my $uuid (keys %{$whattodo->{nodes}})
	{
		my $nodename = $whattodo->{nodes}->{$uuid}->{name};
		++$nodecount;
		push @list_of_handled_nodes, $nodename;

		# One process per node, until maxThreads is reached (then block and wait)
		if ($mthread)
		{
			my $pid=fork;
			if ( defined ($pid) and $pid==0)
			{
				srand();
				# this will be run only by the child
				print "CHILD $$-> I am a CHILD with the PID $$ processing $nodename ($uuid)\n"
						if ($mthreadDebug);

				# make sure this gets a NEW nmisng object, with NEW database handles!
				$nmisng = Compat::NMIS::new_nmisng(nocache => 1);
				my $node = $nmisng->node(uuid => $uuid);
				die "Failed to create node object for $nodename ($uuid)!\n"
						if (ref($node) ne "NMISNG::Node");

				# don't run longer than X seconds
				alarm($maxruntime) if ($maxruntime);

				my @methodargs = (starttime => $starttime, force => NMISNG::Util::getbool($nvp{force}));
				push @methodargs, (wantsnmp => NMISNG::Util::getbool($nvp{force}) ||  $whattodo->{flavours}->{$uuid}->{snmp},
													 wantwmi => NMISNG::Util::getbool($nvp{force}) || $whattodo->{flavours}->{$uuid}->{wmi})
						if ($type eq "collect"); # flavours irrelevant for update

				$node->$type(@methodargs);

				# all the work in this thread is done now this child will die.
				print "CHILD $$-> $nodename ($uuid) is done, exiting\n"
						if ($mthreadDebug);
				exit 0;
			} # end of child
			else
			{
				# parent
				my $others = NMISNG::Util::find_nmis_processes(config => $C);
				my $procs_now = 1 + scalar keys %$others; # the current process isn't returned
				$maxprocs = $procs_now if $procs_now > $maxprocs;
			}
		}
		else
		{
			# just one node or no multi-processing wanted -> work in this process.
			alarm($maxruntime);

			my $node = $nmisng->node(uuid => $uuid);
			die "Failed to create node object for $nodename ($uuid)!\n"
					if (ref($node) ne "NMISNG::Node");

			my @methodargs = (starttime => $starttime, force => NMISNG::Util::getbool($nvp{force}));
			# try both flavours if force is on
			push @methodargs, (wantsnmp => NMISNG::Util::getbool($nvp{force}) ||  $whattodo->{flavours}->{$uuid}->{snmp},
												 wantwmi => NMISNG::Util::getbool($nvp{force}) || $whattodo->{flavours}->{$uuid}->{wmi},)
					if ($type eq "collect"); # flavours irrelevant for update

			# would like to retain the non-collect/update cmdline...and restore it once done
			my $oldargs=$0;
			$node->$type(@methodargs);
			alarm(0) if ($maxruntime);
			$0=$oldargs;
		}
	}
	# outermost parent process: collects exit codes
	if ($mthread)
	{
		print "PARENT $$-> waiting for child processes to complete...\n"
						if ($mthreadDebug);
		# wait blockingly until all worker children are done
		1 while wait != -1;
	}

	my $collecttime = Time::HiRes::time();
	my $S;

	# fixme9: switch the 'last op' timestamp to opstatus in db!
	my $markerfile = $C->{'<nmis_var>'}."/nmis_system/timestamps/$type";
	if (!-f $markerfile)
	{
		open(F, ">$markerfile") && close(F);
	}
	utime(undef,undef, $markerfile);
	
	# some collect post-processing
	if ( $type eq "collect")
	{
		NMISNG::Util::dbg("Starting Metrics computation");
		$nmisng->compute_metrics();
		NMISNG::Util::dbg("Starting escalation processing");
		$nmisng->process_escalations;

		# nmis collect runtime, process counts and save
		my $D = {};
		$D->{collect}{value}  = $collecttime - $starttime;
		$D->{collect}{option} = 'gauge,0:U';
		$D->{total}{value}    = Time::HiRes::time() - $starttime;
		$D->{total}{option}   = 'gauge,0:U';

		my $nr_processes = 1
			+ scalar %{&NMISNG::Util::find_nmis_processes( config => $C )};  # current one isn't returned by find_nmis_processes
		$D->{nr_procs} = {
			option => "gauge,0:U",
			value  => $nr_processes
		};
		$D->{max_procs} = {
			option => "gauge,0:U",
			value  => $maxprocs
		};

		my $S = NMISNG::Sys->new();
		$S->init();
		if (!$S->create_update_rrd( data => $D, type => "nmis" ))
		{
			NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
		}
	}

	if ( $type eq "collect" or $type eq "update" )
	{
		my $pollTimer = Compat::Timing->new;

		# now run all after_{collect,update}_plugin() functions, regardless of whether
		# this was a one-node or all-nodes run
		for my $plugin (@active_plugins)
		{
			my $funcname = $plugin->can("after_${type}_plugin");
			next if ( !$funcname );

			# prime the global sys object, if this was an update run or a one-node collect
			if ( !$S )
			{
				$S = NMISNG::Sys->new;    # the nmis-system object
				$S->init();
			}

			NMISNG::Util::dbg("Running after_$type plugin $plugin");
			NMISNG::Util::logMsg("Running after_$type plugin $plugin");
			$nmisng->log->logprefix("$plugin ");
			my ( $status, @errors );
			eval { ( $status, @errors ) = &$funcname( sys => $S,
																								config => $C,
																								nodes => \@list_of_handled_nodes,
																								nmisng => $nmisng, ); };
			$nmisng->log->logprefix(undef);
			if ( $status >= 2 or $status < 0 or $@ )
			{
				NMISNG::Util::logMsg("Error: Plugin $plugin failed to run: $@") if ($@);
				for my $err (@errors)
				{
					NMISNG::Util::logMsg("Error: Plugin $plugin: $err");
				}
			}
			elsif ( $status == 1 )    # changes were made, need to re-save info file
			{
				NMISNG::Util::dbg("Plugin $plugin indicated success, updating nmis-system file");
				$S->writeNodeInfo;
			}
			elsif ( $status == 0 )
			{
				NMISNG::Util::dbg("Plugin $plugin indicated no changes");
			}
		}
		NMISNG::Util::logMsg( "Poll Time: After $type Plugins " . $pollTimer->elapTime() )
			if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) );
	}

	NMISNG::Util::logMsg("INFO end of $type process");

	if ( $nvp{info} or $nvp{debug} or $mthreadDebug )
	{
		my $endTime = sprintf( "%.2f", Time::HiRes::time() - $starttime );
		my $stats = NMISNG::rrdfunc::getUpdateStats();
		print "\n"
			. NMISNG::Util::returnTime()
			. " Number of Data Points: $stats->{datapoints}, Sum of Bytes: $stats->{databytes}, RRDs updated: $stats->{rrdcount}, Nodes with Updates: $stats->{nodecount}\n";
		print "\n" . NMISNG::Util::returnTime . " End of $0 Processed $nodecount nodes ran for $endTime seconds.\n\n";
	}

	NMISNG::Util::dbg("Finished");
	return;
}

# generic signal handler, but with awareness of code in critical sections
# also handles SIGALARM, which we cop if the process has run out of time
sub catch_zap
{
	my $rs = $_[0];

	# if we've run out of our allocated run time, raise an event to inform the operator
	# unless told NOT to... fixme: we can't check the events control table here as that might block.
	if ($rs eq "ALRM"
		and (  !defined $C->{disable_nmis_process_events}
			or !NMISNG::Util::getbool( $C->{disable_nmis_process_events} ) )
		)
	{
		Compat::NMIS::new_nmisng->events->logEvent(
			node_name    => $C->{server_name},
			event   => "NMIS runtime exceeded",
			level   => "Warning",
			element => undef,
			details => "Process $$, $0, has exceeded its max run time and is terminating"
		);
	}

	# do a graceful shutdown if in critical, and if this is the FIRST interrupt
	my $pending_ints = NMISNG::Util::interrupt_pending;    # scalar ref
	if ( NMISNG::Util::in_critical_section && !$$pending_ints )
	{
		# do NOT lock the logfile
		NMISNG::Util::logMsg( "INFO process in critical section, marking as signal $rs pending", 1 );
		++$$pending_ints;
	}
	else
	{
		# do NOT lock the logfile
		NMISNG::Util::logMsg( "INFO Process $$ ($0) was killed by signal $rs", 1 );
		die "Process $$ ($0) was killed by signal $rs\n"
				if (!NMISNG::Util::getbool($C->{verbose_nmis_process_events},"invert")); # === if ne false
		exit 0;
	}
}



#=========================================================================================


# starts up fpingd and/or opslad if desired and none present
# args: none
# returns: nothing
sub runDaemons
{
	my $C = NMISNG::Util::loadConfTable();

	# nothing to do, let's not waste any time on checking
	return  if (!NMISNG::Util::getbool($C->{daemon_fping_active})
							&& !NMISNG::Util::getbool($C->{daemon_ipsla_active}));

	NMISNG::Util::dbg("Starting");

	# check process table for presence of either
	my ($fpingd_found, $ipslad_found);

	my $pt = new Proc::ProcessTable();
	foreach my $pentry (@{$pt->table})
	{
		# fpingd is identifyable only by cmdline
		$fpingd_found = 1 if ($pentry->cmndline =~ $C->{daemon_fping_filename});
		$ipslad_found = 1 if ($pentry->fname eq $C->{daemon_ipsla_filename});
		last if ($fpingd_found && $ipslad_found);
	}


  # start fast ping daemon if desired and none is running,
	# or if the one that is running is in bad shape
	if (NMISNG::Util::getbool($C->{daemon_fping_active}))
	{
		my $fping_data_age = NMISNG::Util::mtimeFile(dir => 'var', name => 'nmis-fping');
		my $staleafter = $C->{daemon_fping_maxage} || 900; # nothing in 15 minutes?
		my $data_too_old = (time - $fping_data_age) > $staleafter;

		if ($data_too_old or !$fpingd_found)
		{
			NMISNG::Util::logMsg( !$fpingd_found? "INFO no $C->{daemon_fping_filename} running, will start one"
														: "INFO $C->{daemon_fping_filename} seems dead, last file update at $fping_data_age, will restart");

			my $fpingpath  = $C->{'<nmis_bin>'}."/".$C->{daemon_fping_filename};
			if (!-x $fpingpath)
			{
				NMISNG::Util::logMsg("ERROR cannot start fpingd, $fpingpath not executable!");
			}
			else
			{
				system($fpingpath, "restart=true");
				NMISNG::Util::logMsg("INFO launched $C->{daemon_fping_filename} daemon");
			}
		}
	}

	# ipsla daemon desired and in need of being started?
	if ( NMISNG::Util::getbool($C->{daemon_ipsla_active}) && !$ipslad_found)
	{
    if ( -x "$C->{'<nmis_bin>'}/$C->{daemon_ipsla_filename}" )
		{
			system("$C->{'<nmis_bin>'}/$C->{daemon_ipsla_filename}");
			NMISNG::Util::logMsg("INFO launched $C->{daemon_ipsla_filename} as daemon");
		}
		else
		{
			NMISNG::Util::logMsg("ERROR cannot run daemon $C->{'<nmis_bin>'}/$C->{daemon_ipsla_filename},$!");
		}
	}

	NMISNG::Util::dbg("Finished");
}

#=========================================================================================




#=========================================================================================

# run threshold calculation operation on the given nodes, in a single loop
# args: node, group (selectors)
# returns: nothing
sub runThreshold
{
	my (%args) = @_;

	if (!NMISNG::Util::getbool($C->{global_threshold}))
	{
		NMISNG::Util::dbg("Skipping runThreshold because configuration 'global_threshold' is set to false");
		return;
	}

	my ($node_select, $group_select) = @args{"node","group"};
	my @selectors;
	push @selectors, { name => $node_select } if ((ref($node_select) eq "ARRAY") or (!ref($node_select) and $node_select));
	push @selectors, { group => $group_select }  if ((ref($group_select) eq "ARRAY") or (!ref($group_select) and $group_select));

	my $nmisng = Compat::NMIS::new_nmisng();
	my $selected = $nmisng->expand_node_selection(@selectors);
	die "Failed to lookup nodes: ".$selected->error."\n" if ($selected->error);

	# anything to do?
	return if (!$selected->count);

	my $gimme = $selected->objects;
	die "Failed to instantiate nodes: $gimme->{error}\n"
			if (!$gimme->{success});

	for my $nodeobj (@{$gimme->{objects}})
	{
		my $S = NMISNG::Sys->new();
		die "failed to instantiate Sys!\n" if (!$S->init(node => $nodeobj));

		$nmisng->compute_thresholds(sys => $S, running_independently => 1);
	}
}

sub printRunTime
{
	my $endTime = sprintf( "%.2f", Time::HiRes::time() - $starttime );
	NMISNG::Util::info("End of $0, type=$type ran for $endTime seconds.\n");
}


# *****************************************************************************
# Copyright (C) Opmantek Limited (www.opmantek.com)
# This program comes with ABSOLUTELY NO WARRANTY;
# This is free software licensed under GNU GPL, and you are welcome to
# redistribute it under certain conditions; see www.opmantek.com or email
# contact@opmantek.com
# *****************************************************************************
