#!/usr/bin/perl
#
#  Copyright 1999-2014 Opmantek Limited (www.opmantek.com)
#
#  ALL CODE MODIFICATIONS MUST BE SENT TO CODE@OPMANTEK.COM
#
#  This file is part of Network Management Information System ("NMIS").
#
#  NMIS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  NMIS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with NMIS (most likely in a file named LICENSE).
#  If not, see <http://www.gnu.org/licenses/>
#
#  For further information on NMIS or for a license other than GPL please see
#  www.opmantek.com or email contact@opmantek.com
#
#  User group details:
#  http://support.opmantek.com/users/
#
# *****************************************************************************
use strict;
our $VERSION="9.0.0a";

# local modules live in <nmis-base>/lib
use FindBin;
use lib "$FindBin::Bin/../lib";

use URI::Escape;
use Cwd qw();
use Time::HiRes;
use Socket;
use Net::SNMP qw(oid_lex_sort);
use Net::DNS;	# used for plotting major events on world map in 'Current Events' display
use Proc::ProcessTable;
use Proc::Queue ':all';
use Data::Dumper;
use File::Find;
use File::Spec;
use Statistics::Lite qw(mean);
use POSIX qw(:sys_wait_h);

# this imports the LOCK_ *constants (eg. LOCK_UN, LOCK_EX), also the stat modes
use Fcntl qw(:DEFAULT :flock :mode);
use Errno qw(EAGAIN ESRCH EPERM);

use Compat::NMIS;
use Compat::Connect;
use Compat::Timing;

use NMISNG::Util;
use NMISNG::Ping;
use NMISNG::Sapi;
use Compat::IP;
use NMISNG::Notify;
use NMISNG::rrdfunc;
use Compat::DBfunc;							# fixme9: should be removed

use NMISNG::MIB;
use NMISNG::Sys;

# Variables for command line munging
my %nvp = %{ NMISNG::Util::get_args_multi(@ARGV) };

# load configuration table, memorize startup time
my $starttime = Time::HiRes::time;

my $customconfdir = $nvp{dir}? $nvp{dir}."/conf": undef;

my $C = NMISNG::Util::loadConfTable( dir => $customconfdir,
																		 debug => $nvp{debug},
																		 info => $nvp{info} );
die "nmis cannot operate without config!\n" if ( ref($C) ne "HASH" );
NMISNG::rrdfunc::require_RRDs(config=>$C);

# and the status of the database dir, as reported by the selftest - 0 bad, 1 ok, undef unknown
# this is used by rrdfunc::createRRD(), so needs to be scoped suitably.
our $selftest_dbdir_status;
$selftest_dbdir_status = undef;

# check for global collection off or on
# useful for disabling nmis poll for server maintenance, nmis upgrades etc.
my $lockoutfile = $C->{'<nmis_conf>'} . "/NMIS_IS_LOCKED";

if ( -f $lockoutfile or NMISNG::Util::getbool( $C->{global_collect}, "invert" ) )
{
	# if nmis is locked, run a quick nondelay selftest so that we have something for the GUI
	my $varsysdir = $C->{'<nmis_var>'} . "/nmis_system";
	if ( !-d $varsysdir )
	{
		NMISNG::Util::createDir($varsysdir);
		NMISNG::Util::setFileProtDiag(file =>$varsysdir);
	}
	my $selftest_cache = "$varsysdir/selftest";

	my ( $allok, $tests ) = NMISNG::Util::selftest(
		config                 => $C,
		delay_is_ok            => 'false',
		report_database_status => \$selftest_dbdir_status,
		perms                  => 'false'
	);
	NMISNG::Util::writeHashtoFile(
		file => $selftest_cache,
		json => 1,
		data => {status => $allok, lastupdate => time, tests => $tests}
	);
	NMISNG::Util::info( "Selftest completed (status " . ( $allok ? "ok" : "FAILED!" ) . "), cache file written" );
	if ( -f $lockoutfile )
	{
		my $installerpresence = "/tmp/nmis_install_running";

		# installer should not need to lock this box for more than a few minutes
		if ( -f $installerpresence && ( stat($installerpresence) )[9] > time - 3600 )
		{
			NMISNG::Util::logMsg("INFO NMIS is currently disabled, installer is performing upgrade, exiting.");
			exit(0);
		}
		else
		{
			NMISNG::Util::logMsg("WARNING NMIS is currently disabled! Remove the file $lockoutfile to re-enable.");
			die "Attention: NMIS is currently disabled!\nRemove the file $lockoutfile to re-enable.\n\n";
		}
	}
	else
	{
		die
			"Attention: NMIS is currently disabled!\nSet the configuration variable \"global_collect\" to \"true\" to re-enable.\n\n";
	}
}

# all arguments are now stored in nvp (name value pairs)
my $type     = $nvp{type};
my $node     = $nvp{node};
my $rmefile  = $nvp{rmefile};
my $runGroup = $nvp{group};
my $sleep    = $nvp{sleep};

### 2012-12-03 keiths, adding some model testing and debugging options.
my $model = NMISNG::Util::getbool( $nvp{model} );

# multiprocessing: commandline overrides config
my $mthread    = ( exists $nvp{mthread}    ? $nvp{mthread}    : $C->{nmis_mthread} )    || 0;
my $maxThreads = ( exists $nvp{maxthreads} ? $nvp{maxthreads} : $C->{nmis_maxthreads} ) || 1;

my $mthreadDebug = $nvp{mthreaddebug};    # cmdline only for this debugging flag

# park the list of collect/update plugins globally
my @active_plugins;

Proc::Queue::size($maxThreads); # changing limit of concurrent processes
Proc::Queue::trace(0);          # trace mode on
Proc::Queue::debug(0);          # debug is off
Proc::Queue::delay(0);

$type //= "collect";

print qq/
Copyright (C) Opmantek Limited (www.opmantek.com)
This program comes with ABSOLUTELY NO WARRANTY;
This is free software licensed under GNU GPL, and you are welcome to
redistribute it under certain conditions; see www.opmantek.com or email
contact\@opmantek.com

NMIS version $Compat::NMIS::VERSION

/ if $nvp{debug} or $nvp{info};


if ( $type =~ /^(collect|update|services)$/ )
{
	runThreads( type => $type, node => $node, mthread => $mthread, mthreadDebug => $mthreadDebug );
}
elsif ( $type eq "escalate" ) { runEscalate(); printRunTime(); }    # included in type=collect


elsif ( $type eq "links" )      { runLinks(); }                                            # included in type=update
elsif ( $type eq "summary" )    { nmisSummary(); printRunTime(); }                         # MIGHT BE included in type=collect
elsif ( $type eq "rme" )        { Compat::NMIS::loadRMENodes($rmefile); }
elsif ( $type eq "threshold" )  { runThreshold($node,1); printRunTime(); }                   # USUALLY included in type=collect
elsif ( $type eq "master" )     { nmisMaster(); printRunTime(); }                          # MIGHT be included in type=collect


else
{
		print qq!

NMIS Polling Engine - Network Management Information System

Copyright (C) Opmantek Limited (www.opmantek.com)
This program comes with ABSOLUTELY NO WARRANTY;
This is free software licensed under GNU GPL, and you are welcome to
redistribute it under certain conditions; see www.opmantek.com or email
contact\@opmantek.com

NMIS version $Compat::NMIS::VERSION

Usage: $0 <type=action> [option=value...]

command line options are:
  type=<option>
    Where <option> is one of the following:
      collect   NMIS will collect all statistics (incl. Services)
      update    Update all the dynamic NMIS configuration
      threshold Calculate thresholds
      services  Run Services data collection only
      master    Run NMIS Master Functions
      escalate  Run the escalation routine only ( debug use only)
      links     Generate the links.csv file.
      rme       Read and generate a node.csv file from a Ciscoworks RME file
  [conf=<file name>]     Optional alternate configuation file in conf directory
  [node=<node name>]     Run operations on a single node;
  [group=<group name>]   Run operations on all nodes in the named group;
  [force=true|false]     Makes operations run from scratch, ignoring interval policies
  [debug=true|false|0-9] default=false - Show debugging information
  [rmefile=<file name>]  RME file to import.
  [mthread=true|false]   default=$C->{nmis_mthread} - Enable Multithreading or not;
  [mthreaddebug=true|false] default=false - Extra debug for Multithreading code;
  [maxthreads=<1..XX>]  default=$C->{nmis_maxthreads} - How many threads should nmis use, at most\n
!;

	exit 1;
}
exit 0;


# run collection-type functions, possibly spread across multiple processes
sub runThreads
{
	my %args         = @_;
	my $type         = $args{type};
	my $node_select  = $args{'node'};
	my $mthread      = NMISNG::Util::getbool( $args{mthread} );
	my $mthreadDebug = NMISNG::Util::getbool( $args{mthreadDebug} );

	NMISNG::Util::dbg("Starting, operation is $type");

	# do a selftest and cache the result, but not too often
	# this takes about five seconds (for the process stats)
	# however, DON'T do one if nmis is run in handle-just-this-node mode
	# which shouldn't be delayed at all. ditto for (possibly VERY) frequent type=services
	if ( !$node_select and $type ne "services" )
	{
		NMISNG::Util::info("Ensuring correct permissions on conf and model directories...");
		NMISNG::Util::setFileProtDirectory( $C->{'<nmis_conf>'},   1 );    # do recurse
		# that's the dir for custom models
		NMISNG::Util::createDir($C->{'<nmis_models>'}) if (!-d $C->{'<nmis_models>'});
		NMISNG::Util::setFileProtDirectory( $C->{'<nmis_models>'}, 0 );    # no recursion required
		# that's the dir of shipped=default models
		NMISNG::Util::setFileProtDirectory( $C->{'<nmis_default_models>'}, 0 );    # no recursion required


		my $varsysdir = $C->{'<nmis_var>'} . "/nmis_system";
		if ( !-d $varsysdir )
		{
			NMISNG::Util::createDir($varsysdir);
			NMISNG::Util::setFileProtDiag(file =>$varsysdir);
		}

		my $selftest_cache = "$varsysdir/selftest";

		# check the current state, to see if a perms check is due? once every 2 hours
		my $laststate = NMISNG::Util::readFiletoHash( file => $selftest_cache, json => 1 );
		# check if a selftest is due? once every 15 minutes
		my $wantselftestnow = 1 if (ref($laststate) ne "HASH"
																|| !defined($laststate->{lastupdate})
																|| ($laststate->{lastupdate} + 900 < time));
		# check the current state, to see if a perms check is due? once every 2 hours
		my $wantpermsnow = 1 if (ref($laststate) ne "HASH"
														 || !defined($laststate->{lastupdate_perms})
														 || $laststate->{lastupdate_perms} + 7200 < time);

		if ($wantselftestnow)
		{
			NMISNG::Util::info("Starting selftest (takes about 5 seconds)...");

			my ( $allok, $tests ) = NMISNG::Util::selftest(
				config                 => $C,
				delay_is_ok            => 'true',
				perms                  => $wantpermsnow,
				report_database_status => \$selftest_dbdir_status
					);

		# keep the old permissions state if this test did not run a permissions test
		# hardcoded test name isn't great, though.
		if ( !$wantpermsnow )
		{
			$laststate ||= {tests => []};

			my ($oldstate) = grep( $_->[0] eq "Permissions",
														 @{$laststate->{tests}} );    # there will at most one
			if ( defined $oldstate )
			{
				my ($targetidx) = grep( $tests->[$_]->[0] eq "Permissions",
																( 0 .. $#{$tests} ) );
				if ( defined $targetidx )
				{
					$tests->[$targetidx] = $oldstate;
				}
				else
				{
					push @$tests, $oldstate;
				}
				$allok = 0 if ( $oldstate->[1] );                                         # not ok until that's cleared
			}
		}

			NMISNG::Util::writeHashtoFile(
				file => $selftest_cache,
				json => 1,
				data => {
					status           => $allok,
					lastupdate       => time,
					lastupdate_perms => (
					  $wantpermsnow ? time
						: $laststate    ? $laststate->{lastupdate_perms}
						:                 undef
							),
								tests => $tests
				}
					);
			NMISNG::Util::info( "Selftest completed (status " . ( $allok ? "ok" : "FAILED!" ) . "), cache file written" );
		}
		else
		{
			NMISNG::Util::info("Skipping selftest, last run at "
												 . NMISNG::Util::returnDateStamp($laststate->{lastupdate}));
		}
	}

	# load all the files we need here
	Compat::NMIS::loadEnterpriseTable() if $type eq 'update';    # load in cache
	NMISNG::Util::dbg( "table Enterprise loaded", 2 );

	my $NT = Compat::NMIS::loadLocalNodeTable();                 # only local nodes
	NMISNG::Util::dbg( "table Local Node loaded", 2 );

	my $C = NMISNG::Util::loadConfTable();    # config table from cache

	# check if the fping results look sensible
	# compare nr of pingable active nodes against the fping results
	if ( NMISNG::Util::getbool( $C->{daemon_fping_active} ) )
	{
		my $pt = NMISNG::Util::loadTable( dir => 'var', name => 'nmis-fping' );    # load fping table in cache
		my $cnt_pt = keys %{$pt};

		my $active_ping = grep( NMISNG::Util::getbool( $_->{active} ) && NMISNG::Util::getbool( $_->{ping} ), values %{$NT} );

		# missing more then 10 nodes that should have been pinged?
		NMISNG::Util::logMsg("ERROR fping table missing too many entries, count fping=$cnt_pt count nodes=$active_ping")
				if ( $cnt_pt + 10 < $active_ping );
	}
	NMISNG::Util::dbg("all relevant tables loaded");

	my $nmisng = Compat::NMIS::new_nmisng();

	my $debug_global = $C->{debug};
	my $debug        = $C->{debug};
	my $PIDFILE;
	my $pid;

	runDaemons();    # (re)start daemon processes

	# the signal handler handles termination more-or-less gracefully,
	# and knows about critical sections
	$SIG{INT}  = \&catch_zap;
	$SIG{TERM} = \&catch_zap;
	$SIG{HUP}  = \&catch_zap;
	$SIG{ALRM} = \&catch_zap;

	my $nodecount = 0;
	my $maxprocs  = 1;    # this one

	my $meth;
	if ( $type eq "update" )
	{
		$meth = \&doUpdate;
	}
	elsif ( $type eq "collect" )
	{
		$meth = \&doCollect;
	}
	elsif ( $type eq "services" )
	{
		$meth = \&doServices;
	}
	else
	{
		die "Unknown operation type=$type, terminating!\n";
	}
	NMISNG::Util::logMsg("INFO start of $type process");

	# update the operation start/stop timestamp
	NMISNG::Util::update_operations_stamp( type => $type,
																				 start => $starttime, stop => undef );
	my $maxruntime = defined( $C->{max_child_runtime} )
			&& $C->{max_child_runtime} > 0 ? $C->{max_child_runtime} : 0;

	my (@list_of_handled_nodes,		# for any after_x_plugin() functions
			@todo_nodes,							# for the actual update/polling work
			@cand_nodes,
			%whichflavours);					# attempt smmp, wmi or both


	# what to work on? one named node, or the nodes that are members of a given group or all nodes
	# iff active and the polling policy agrees, that is...
	@cand_nodes = ref($node_select) eq "ARRAY"? @$node_select : $node_select ? $node_select
			: $runGroup? grep($_->{group} eq $runGroup, keys %$NT) : sort keys %$NT;

	# get the polling policies and translate into seconds (for rrd file options)
	my $policies = NMISNG::Util::loadTable(dir => 'conf',
																				 name => "Polling-Policy") || {};
	my %intervals = ( default => { ping=> 60, snmp => 300, wmi => 300 });
	# translate period specs X.Ys, A.Bm, etc. into seconds
	for my $polname (keys %$policies)
	{
		next if (ref($policies->{$polname}) ne "HASH");
		for my $subtype (qw(snmp wmi ping))
		{
			my $interval = $policies->{$polname}->{$subtype};
			if ($interval =~ /^\s*(\d+(\.\d+)?)([smhd])$/)
			{
				my ($rawvalue, $unit) = ($1, $3);
				$interval = $rawvalue * ($unit eq 'm'? 60 : $unit eq 'h'? 3600
																 : $unit eq 'd'? 86400 : 1);
			}
			$intervals{$polname}->{$subtype} = $interval; # now in seconds
		}
	}

	# find all other nmis processes of the same type
	my $otherprocesses = NMISNG::Util::find_nmis_processes(type => $type, config => $C)
			if ($type eq "update" or $type eq "collect"); # relevant only for these
	my %problematic;

	if ($type eq "update" or $type eq "services")
	{
		@todo_nodes = grep(NMISNG::Util::getbool($NT->{$_}->{active}),
											 @cand_nodes);
	}
	else
	{
		# find out what nodes are due as per polling policy - also honor force,
		# and any in-progress polling that hasn't finished yet

		# unfortunately we require each candidate node's nodeinfo/catchall data to make the
		# candidate-or-not decision...
		#	fixme9 should we add the node uuid as filter?
		my $accessor = $nmisng->get_inventory_model(concept => "catchall",
																								cluster_id => $C->{cluster_id});
		# node information, by node uuid
		my %node_info_ro = map { ($_->{node_uuid} => $_->{data}) } (@{$accessor->data});

		my $now = time;
		for my $maybe (@cand_nodes)
		{
			next if (ref($NT->{$maybe}) ne "HASH" or !NMISNG::Util::getbool($NT->{$maybe}->{active}));
			# save it back for the xyz-node file, and cgi-bin/network...
			my $polname = ($NT->{$maybe}->{polling_policy} ||= "default");
			NMISNG::Util::dbg("Node $maybe is using polling policy \"$polname\"");

			my $ninfo = $node_info_ro{ $NT->{$maybe}->{uuid} } // {};

			my $lastpolicy = $ninfo->{last_polling_policy};
			my $lastsnmp = $ninfo->{last_poll_snmp};
			my $lastwmi = $ninfo->{last_poll_wmi};

			# that's it for completed polls - for in-progress uncompleted
			# we need other time logic,
			# overriding these markers from the active process' start time
			my @isinprogress = grep($otherprocesses->{$_}->{node} &&
															$otherprocesses->{$_}->{node} eq $maybe,
															keys %$otherprocesses);
			map { $problematic{$maybe} = $_; } (@isinprogress);

			if (!NMISNG::Util::getbool($nvp{force}) and @isinprogress)
			{
				# there should be at most one, we ignore any unexpected others
				my $otherstart = $otherprocesses->{ $isinprogress[0] }->{start};
				NMISNG::Util::dbg("Node $maybe: collect in progress, using process start $otherstart instead of last_poll markers");
				$lastsnmp = $lastwmi = $otherstart;
				$lastpolicy = $polname;	# and no policy change triggering either...
			}

			# handle the case of a changed polling policy: move all rrd files
			# out of the way, and poll now
			# note that this does NOT work with non-standard common-database structures
			if (defined($lastpolicy) && $lastpolicy ne $polname)
			{
				NMISNG::Util::logMsg("Node $maybe is changing polling policy, from \"$lastpolicy\" to \"$polname\", due for polling at $now");
				my $lcnode = lc($maybe);
				my $curdir = $C->{'database_root'}."/nodes/$lcnode";
				my $backupdir = "$curdir.policy-$lastpolicy.".time();

				if (!-d $curdir)
				{
					NMISNG::Util::logMsg("WARN Node $maybe doesn't have RRD files under $curdir!");
				}
				else
				{
					rename($curdir,$backupdir)
							or NMISNG::Util::logMsg("WARN failed to mv rrd files for $maybe: $!");
				}
				push @todo_nodes, $maybe;
				$whichflavours{$maybe}->{wmi} = $whichflavours{$maybe}->{snmp} = 1; # and ignore the last-xyz markers
			}
			elsif (NMISNG::Util::getbool($nvp{force}))
			{
				NMISNG::Util::dbg("force is enabled, Node $maybe will be polled at $now");
				push @todo_nodes, $maybe;
				$whichflavours{$maybe}->{wmi} = $whichflavours{$maybe}->{snmp} = 1; # and ignore the last-xyz markers
			}
			# nodes that have not been pollable since forever: run at most once hourly
			elsif (!$ninfo->{nodeModel} or $ninfo->{nodeModel} eq "Model")
			{
				my $lasttry = $ninfo->{last_poll} // 0;
				my $nexttry = ($lasttry && ($now - $lasttry) <= 30*86400)? ($lasttry + 3600 * 0.95) : $now;
				NMISNG::Util::dbg("Node $maybe has no valid nodeModel, never polled successfully, demoting to hourly check, last attempt $lasttry, next $nexttry");
				if ($nexttry <= $now)
				{
					push @todo_nodes, $maybe;
					$whichflavours{$maybe}->{wmi} = $whichflavours{$maybe}->{snmp} = 1;
				}
			}
			# logic for collect now or later: candidate if no past successful collect whatsoever,
			# or if either of the two worked and was done long enough ago.
			#
			# if no history is known for a source, then disregard it for the now-or-later logic
			# but DO enable it for trying!
			# note that collect=false, i.e. ping-only nodes need to be excepted,
			elsif (!defined($lastsnmp) && !defined($lastwmi)
						 && NMISNG::Util::getbool($NT->{$maybe}->{collect}))
			{
				NMISNG::Util::dbg("Node $maybe has neither last_poll_snmp nor last_poll_wmi, due for poll at $now");
				push @todo_nodes, $maybe;
				$whichflavours{$maybe}->{wmi} = $whichflavours{$maybe}->{snmp} = 1;
			}
			else
			{
				# for collect false/pingonly nodes the single 'generic' collect run counts,
				# and the 'snmp' policy is applied
				if (!NMISNG::Util::getbool($NT->{$maybe}->{collect}))
				{
					$lastsnmp = $ninfo->{last_poll} // 0;
					NMISNG::Util::dbg("Node $maybe is non-collecting, applying snmp policy to last check at $lastsnmp");
				}

				# accept delta-previous-now interval if it's at least 95% of the configured interval
				# strict 100% would mean that we might skip a full interval when polling takes longer
				my $nextsnmp = ($lastsnmp // 0) + $intervals{$polname}->{snmp} * 0.95;
				my $nextwmi = ($lastwmi // 0) + $intervals{$polname}->{wmi} * 0.95;

				# only flavours which worked in the past contribute to the now-or-later logic
				if ((defined($lastsnmp) && $nextsnmp <= $now )
						|| (defined($lastwmi) && $nextwmi <= $now))
				{
					NMISNG::Util::dbg("Node $maybe is due for poll at $now, last snmp: ".($lastsnmp//"never")
							.", last wmi: ".($lastwmi//"never")
							. ", next snmp: ".($lastsnmp ? (($now - $nextsnmp)."s ago"):"n/a")
							.", next wmi: ".($lastwmi? (($now - $nextwmi)."s ago"):"n/a"));
					push @todo_nodes, $maybe;

					# but if we've decided on polling, then DO try flavours that have not worked in the past!
					# nextwmi <= now also covers the case of undefined lastwmi...
					$whichflavours{$maybe}->{wmi} = ($nextwmi <= $now);
					$whichflavours{$maybe}->{snmp} = ($nextsnmp <= $now);
				}
				else
				{
					NMISNG::Util::dbg("Node $maybe is NOT due for poll at $now, last snmp: "
														.($lastsnmp//"never")
														.", last wmi: ".($lastwmi//"never")
														. ", next snmp: ".($lastsnmp? $nextsnmp :"n/a")
														.", next wmi: ".($lastwmi? $nextwmi :"n/a"));
				}
			}
		}
	}

	# anything to do?
	if (!@todo_nodes)
	{
		NMISNG::Util::info("Found no nodes due for $type.");
		NMISNG::Util::logMsg("Found no nodes due for $type.");
		return;
	}

	# logmsg not useful for services, separate per-service policy in force
	NMISNG::Util::logMsg("INFO Selected nodes for $type: "
											 .join(" ", sort @todo_nodes)) if ($type ne "services");

	$mthread = 0 if (@todo_nodes <= 1); # multiprocessing makes no sense with just one todo node

	# now perform process safety operations
	# test if there are any collect processes running for any of the todo nodes
	# for updates, just test
	### updates can run past 5 mins, BUT no two updates should run at the same time
	### for potentially frequent type=services we don't do any of these.
	if ( $type eq 'collect' or $type eq "update")
	{
		# unrelated but also for collect and update only
		@active_plugins = &load_plugins;

		# if this is a collect and if told to ignore running processes (ignore_running=1/t),
		# then only warn about processes and don't shoot them.
		if ($type eq "collect" and NMISNG::Util::getbool($nvp{ignore_running}))
		{
			for my $pid (keys %$otherprocesses)
			{
				NMISNG::Util::logMsg("INFO ignoring old $type process $pid that is still running: $otherprocesses->{$pid}->{node}, started at ".NMISNG::Util::returnDateStamp($otherprocesses->{$pid}->{start}));
			}
		}
		else
		{
			my $eventconfig = NMISNG::Util::loadTable(dir => 'conf', name => 'Events');
			my $event = "NMIS runtime exceeded";
			my $thisevent_control = $eventconfig->{$event} || { Log => "true", Notify => "true", Status => "true"};

			# if not told otherwise, shoot the others politely
			my $needgrace;
			for my $node (@todo_nodes)
			{
				my $pid = $problematic{$node};
				next if (!$pid);

				$needgrace = 1;
				print STDERR "Error: killing old NMIS $type process $pid ($otherprocesses->{$pid}->{node}) which has not finished!\n";
				NMISNG::Util::logMsg("ERROR killing old NMIS $type process $pid ($otherprocesses->{$pid}->{node}) which has not finished!");
				kill("TERM",$pid);

				# and raise an event to inform the operator - unless told NOT to
				# ie: either disable_nmis_process_events is set to true OR the event control Log property is set to false
				if ((!defined $C->{disable_nmis_process_events}
						 or !NMISNG::Util::getbool($C->{disable_nmis_process_events})
						 and NMISNG::Util::getbool($thisevent_control->{Log})))
				{
					# logging this event as the node name so it shows up as a problem with the node
					Compat::NMIS::logEvent(node => $otherprocesses->{$pid}->{node},
																 event => $event,
																 level => "Warning",
																 element => $otherprocesses->{$pid}->{node},
																 details => "Killed process $pid, $type of $otherprocesses->{$pid}->{node}, started at "
																 .NMISNG::Util::returnDateStamp($otherprocesses->{$pid}->{start}));
				}
			}

			if ($needgrace) # give the others a moment to shut down cleanly
			{
				my $grace = 2;
				NMISNG::Util::logMsg("INFO sleeping for $grace seconds to let old NMIS processes clean up");
				sleep($grace);
			}
		}
	}

	for my $onenode (@todo_nodes)
	{
		++$nodecount;
		push @list_of_handled_nodes, $onenode;

		# One process per node, until maxThreads is reached (then block and wait)
		if ($mthread)
		{
			my $pid=fork;
			if ( defined ($pid) and $pid==0)
			{
				srand();
				# this will be run only by the child
				print "CHILD $$-> I am a CHILD with the PID $$ processing $onenode\n"
						if ($mthreadDebug);

				# make sure this gets a NEW nmisng object, with NEW database handles!
				$nmisng = Compat::NMIS::new_nmisng(nocache => 1);

				# don't run longer than X seconds
				alarm($maxruntime) if ($maxruntime);
				my @methodargs = ( name => $onenode,
													 policy => $intervals{$NT->{$onenode}->{polling_policy} || "default"} );
				# try both flavours if force is on
				push @methodargs, (wantsnmp => NMISNG::Util::getbool($nvp{force}) ||  $whichflavours{$onenode}->{snmp},
													 wantwmi => NMISNG::Util::getbool($nvp{force}) || $whichflavours{$onenode}->{wmi})
						if ($type eq "collect"); # flavours irrelevant for update
				&$meth(@methodargs);


				# all the work in this thread is done now this child will die.
				print "CHILD $$-> $onenode is done, exiting\n"
						if ($mthreadDebug);
				exit 0;
			} # end of child
			else
			{
				# parent
				my $others = NMISNG::Util::find_nmis_processes(config => $C);
				my $procs_now = 1 + scalar keys %$others; # the current process isn't returned
				$maxprocs = $procs_now if $procs_now > $maxprocs;
			}
		}
		else
		{
			# just one node or no multi-processing wanted -> work in this process.
			alarm($maxruntime);
			my @methodargs = ( name => $onenode,
												 policy => $intervals{$NT->{$onenode}->{polling_policy} || "default"} );
			# try both flavours if force is on
			push @methodargs, (wantsnmp => NMISNG::Util::getbool($nvp{force}) ||  $whichflavours{$onenode}->{snmp},
												 wantwmi => NMISNG::Util::getbool($nvp{force}) || $whichflavours{$onenode}->{wmi},)
					if ($type eq "collect"); # flavours irrelevant for update

			# would like to retain the non-collect/update cmdline...and restore it once done
			my $oldargs=$0;
			&$meth(@methodargs);
			alarm(0) if ($maxruntime);
			$0=$oldargs;
		}
	}
	# outermost parent process: collects exit codes
	if ($mthread)
	{
		print "PARENT $$-> waiting for child processes to complete...\n"
						if ($mthreadDebug);
		# wait blockingly until all worker children are done
		1 while wait != -1;
	}

	my $collecttime = Time::HiRes::time();
	my $S;

	# on update prime the interface summary
	if ( $type eq "update" )
	{
		if ( !NMISNG::Util::getbool( $C->{disable_interfaces_summary} ) )
		{
			getIntfAllInfo();    # concatencate all the interface info in <nmis_var>/nmis-interfaces.xxxx
			runLinks();
		}
	}

	# some collect post-processing
	elsif ( $type eq "collect")
	{
		$S = NMISNG::Sys->new;           # object nmis-system
		$S->init();

		# do some masterly type things
		if ( !NMISNG::Util::getbool( $C->{'nmis_master_poll_cycle'},"invert")  # if not false
				 && NMISNG::Util::getbool( $C->{server_master} ) )
		{
			my $pollTimer = Compat::Timing->new;

			NMISNG::Util::dbg("Starting nmisMaster");
			nmisMaster();
			NMISNG::Util::logMsg( "Poll Time: nmisMaster, " . $pollTimer->elapTime() )
			if (NMISNG::Util::getbool($C->{log_polling_time}) );
		}

		# calculate and cache the summary stats
		if (!NMISNG::Util::getbool($C->{'nmis_summary_poll_cycle'},"invert") # if not false
				&& NMISNG::Util::getbool($C->{cache_summary_tables}))
		{
			NMISNG::Util::dbg("Starting nmisSummary");

			# fixme9: catchall needs to be written before this runs as it loads the data
			# locally, it has no $S
			nmisSummary(update_operations_stamp => 1);
		}

		NMISNG::Util::dbg("Starting runMetrics");
		runMetrics( sys => $S );

		# thresholds can be run: independent (=t_p_n and t_p_c false), post-collect (=t_p_n false, t_p_c true),
		# or combined with collect (t_p_n true, t_p_c ignored)
		if ( !NMISNG::Util::getbool( $C->{threshold_poll_node} ) )
		{
			# not false
			if ( !NMISNG::Util::getbool( $C->{threshold_poll_cycle}, "invert" ) )
			{
				NMISNG::Util::dbg("Starting runThreshold (for all selected nodes)");
				# the 0 here tells it that it's running in a collect cycle
				# fixme9: teach this to run on N nodes, not all and not just one!
				runThreshold(undef, 0);
			}
			else
			{
				NMISNG::Util::dbg("Skipping runThreshold with configuration 'threshold_poll_cycle' = $C->{'threshold_poll_cycle'}");
			}
		}

		NMISNG::Util::dbg("Starting runEscalate");
		runEscalate();

		# nmis collect runtime, process counts and save
		my $D = {};
		$D->{collect}{value}  = $collecttime - $starttime;
		$D->{collect}{option} = 'gauge,0:U';
		$D->{total}{value}    = Time::HiRes::time() - $starttime;
		$D->{total}{option}   = 'gauge,0:U';

		my $nr_processes = 1
			+ scalar %{&NMISNG::Util::find_nmis_processes( config => $C )};  # current one isn't returned by find_nmis_processes
		$D->{nr_procs} = {
			option => "gauge,0:U",
			value  => $nr_processes
		};
		$D->{max_procs} = {
			option => "gauge,0:U",
			value  => $maxprocs
		};

		if (!$S->create_update_rrd( data => $D, type => "nmis" ))
		{
			NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
		}
	}

	if ( $type eq "collect" or $type eq "update" )
	{
		my $pollTimer = Compat::Timing->new;

		# now run all after_{collect,update}_plugin() functions, regardless of whether
		# this was a one-node or all-nodes run
		for my $plugin (@active_plugins)
		{
			my $funcname = $plugin->can("after_${type}_plugin");
			next if ( !$funcname );

			# prime the global sys object, if this was an update run or a one-node collect
			if ( !$S )
			{
				$S = NMISNG::Sys->new;    # the nmis-system object
				$S->init();
			}

			NMISNG::Util::dbg("Running after_$type plugin $plugin");
			NMISNG::Util::logMsg("Running after_$type plugin $plugin");
			$S->nmisng->log->logprefix("$plugin ");
			my ( $status, @errors );
			eval { ( $status, @errors ) = &$funcname( sys => $S,
																								config => $C,
																								nodes => \@list_of_handled_nodes,
																								nmisng => $S->nmisng, ); };
			$S->nmisng->log->logprefix(undef);
			if ( $status >= 2 or $status < 0 or $@ )
			{
				NMISNG::Util::logMsg("Error: Plugin $plugin failed to run: $@") if ($@);
				for my $err (@errors)
				{
					NMISNG::Util::logMsg("Error: Plugin $plugin: $err");
				}
			}
			elsif ( $status == 1 )    # changes were made, need to re-save info file
			{
				NMISNG::Util::dbg("Plugin $plugin indicated success, updating nmis-system file");
				$S->writeNodeInfo;
			}
			elsif ( $status == 0 )
			{
				NMISNG::Util::dbg("Plugin $plugin indicated no changes");
			}
		}
		NMISNG::Util::logMsg( "Poll Time: After $type Plugins " . $pollTimer->elapTime() )
			if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) );
	}

	NMISNG::Util::logMsg("INFO end of $type process");

	if ( $C->{info} or $debug or $mthreadDebug )
	{
		my $endTime = sprintf( "%.2f", Time::HiRes::time() - $starttime );
		my $stats = NMISNG::rrdfunc::getUpdateStats();
		print "\n"
			. NMISNG::Util::returnTime()
			. " Number of Data Points: $stats->{datapoints}, Sum of Bytes: $stats->{databytes}, RRDs updated: $stats->{rrdcount}, Nodes with Updates: $stats->{nodecount}\n";
		print "\n" . NMISNG::Util::returnTime . " End of $0 Processed $nodecount nodes ran for $endTime seconds.\n\n";
	}

	NMISNG::Util::update_operations_stamp( type => $type, start => $starttime, stop => Time::HiRes::time() );

	NMISNG::Util::dbg("Finished");
	return;
}

# generic signal handler, but with awareness of code in critical sections
# also handles SIGALARM, which we cop if the process has run out of time
sub catch_zap
{
	my $rs = $_[0];

	# if we've run out of our allocated run time, raise an event to inform the operator
	# unless told NOT to... fixme: we can't check the events control table here as that might block.
	if ($rs eq "ALRM"
		and (  !defined $C->{disable_nmis_process_events}
			or !NMISNG::Util::getbool( $C->{disable_nmis_process_events} ) )
		)
	{
		Compat::NMIS::logEvent(
			node    => $C->{server_name},
			event   => "NMIS runtime exceeded",
			level   => "Warning",
			element => undef,
			details => "Process $$, $0, has exceeded its max run time and is terminating"
		);
	}

	# do a graceful shutdown if in critical, and if this is the FIRST interrupt
	my $pending_ints = NMISNG::Util::interrupt_pending;    # scalar ref
	if ( NMISNG::Util::in_critical_section && !$$pending_ints )
	{
		# do NOT lock the logfile
		NMISNG::Util::logMsg( "INFO process in critical section, marking as signal $rs pending", 1 );
		++$$pending_ints;
	}
	else
	{
		# do NOT lock the logfile
		NMISNG::Util::logMsg( "INFO Process $$ ($0) was killed by signal $rs", 1 );
		die "Process $$ ($0) was killed by signal $rs\n";
	}
}

#====================================================================================

# perform update operation for ONE node
# args: name, required
# returns: nothing
#
# note: update must not (and does not) skip nodes with collect=false; function is not run if active=false.
sub doUpdate
{
	my %args = @_;
	my $name = $args{name};

	my $C = NMISNG::Util::loadConfTable();

	my $updatetimer = Compat::Timing->new;

	NMISNG::Util::dbg("================================");
	NMISNG::Util::dbg("Starting update, node $name");

	# Check for existing update LOCK
	if ( NMISNG::Util::existsPollLock( type => "update", conf => $C->{conf}, node => $name ) )
	{
		print STDERR "Error: update lock exists for $name which has not finished!\n";
		NMISNG::Util::logMsg("WARNING update lock exists for $name which has not finished!");
		return;
	}

	# create the update lock now.
	my $lockHandle = NMISNG::Util::createPollLock( type => "update", conf => $C->{conf}, node => $name );

	# lets change our name, always, for process runtime checking
	$0 = "poll-update-$name";

	my $S = NMISNG::Sys->new;    # create system object
	                     # loads old node NMISNG::Util::info (unless force is active), and the DEFAULT(!) model (always!),
	                     # and primes the sys object for snmp/wmi ops


	if ( !$S->init( name => $name, update => 'true', force => $nvp{force} ) )
	{
		NMISNG::Util::logMsg( "ERROR ($name) init failed: " . $S->status->{error} );    # fixme: why isn't this terminal?
	}

	# this is the first time catchall is accessed, handle error here, all others will assume it works
	my $catchall_inventory = $S->inventory(concept => 'catchall');
	$S->nmisng->log->fatal("Failed to load catchall inventory for node:$node") && return if(!$catchall_inventory);
	# catchall uses 'live' data which is a direct reference to the data because it's too easy to
	# end up with stale/wrong data with all the functions using it
	my $catchall_data = $catchall_inventory->data_live();

	NMISNG::Util::dbg("node=$name "
			. join( " ",
			( map { "$_=" . $catchall_data->{$_} } (qw(group nodeType nodedown snmpdown wmidown)) ),
			( map { "$_=" . $S->status->{$_} } (qw(snmp_enabled wmi_enabled)) ) )
	);

	# this uses the node config loaded by init, and updates the node info table
	# (model and nodetype set only if missing)
	$S->copyModelCfgInfo( type => 'all' );

	my $NC = $S->ndcfg;

	if ( !NMISNG::Util::getbool( $nvp{force} ) )
	{
		$S->readNodeView;    # from prev. run, but only if force isn't active
	}
	else
	{
		# make all things historic, they can bring them back if they want
		$S->nmisng_node->bulk_update_inventory_historic();
	}

	# prime default values, overridden if we can find anything better
	$catchall_data->{nodeModel} ||= 'Generic';
	$catchall_data->{nodeType}  ||= 'generic';

	# if reachable then we can update the model and get rid of the default we got from init above
	# fixme: not true unless node is ALSO marked as collect, or getnodeinfo will not do anything model-related
	if ( runPing( sys => $S ) )
	{
		# snmp-enabled node? then try to create a session obj
		# (but as snmp is still predominantly udp it won't connect yet!)
		$S->open(
			timeout      => $C->{snmp_timeout},
			retries      => $C->{snmp_retries},
			max_msg_size => $C->{snmp_max_msg_size},

			# how many oids/pdus per bulk request, or let net::snmp guess a value
			max_repetitions => $catchall_data->{max_repetitions} || $C->{snmp_max_repetitions} || undef,

			# how many oids per simple get request (for getarray), or default (no guessing)
			oidpkt => $catchall_data->{max_repetitions} || $C->{snmp_max_repetitions} || 10
		) if ( $S->status->{snmp_enabled} );

		# failed already?
		if ( $S->status->{snmp_error} )
		{
			NMISNG::Util::logMsg( "ERROR SNMP session open to $node failed: " . $S->status->{snmp_error} );
			$S->disable_source("snmp");
		}

		# this will try all enabled sources, 0 only if none worked
		# it also disables sys sources that don't work!
		if ( getNodeInfo( sys => $S ) )
		{
			# getnodeinfo has deleted the interface info, need to rebuild from scratch
			if ( NMISNG::Util::getbool( $NC->{node}{collect} ) )
			{
				if ( getIntfInfo( sys => $S ) )
				{
					NMISNG::Util::dbg("node=$S->{name} role=$catchall_data->{roleType} type=$catchall_data->{nodeType}");
					NMISNG::Util::dbg("vendor=$catchall_data->{nodeVendor} model=$catchall_data->{nodeModel} interfaces=$catchall_data->{ifNumber}"
					);

					if ($model)
					{
						print
							"MODEL $S->{name}: role=$catchall_data->{roleType} type=$catchall_data->{nodeType} sysObjectID=$catchall_data->{sysObjectID} sysObjectName=$catchall_data->{sysObjectName}\n";
						print "MODEL $S->{name}: sysDescr=$catchall_data->{sysDescr}\n";
						print
							"MODEL $S->{name}: vendor=$catchall_data->{nodeVendor} model=$catchall_data->{nodeModel} interfaces=$catchall_data->{ifNumber}\n";
					}
				}

				# fixme: why no error handling for getintfinfo?
				getSystemHealthInfo( sys => $S ) if defined $S->{mdl}{systemHealth};
				getCBQoS( sys => $S, update => 1 );

			}
			else
			{
				NMISNG::Util::dbg("node is set to collect=false, not collecting any info");
			}
		}
		$S->close;    # close snmp session if one is open
		$catchall_data->{last_update} = time();
	}

	my $reachdata
		= runReach( sys => $S, delayupdate => 1 );    # don't let it make the rrd update, we want to add updatetime!
	$S->writeNodeView;                                # save node view info in file var/$NI->{name}-view.xxxx
	$S->writeNodeInfo;                                # save node info in file var/$NI->{name}-node.xxxx
	$catchall_inventory->save();											# ensure the plugins don't end up with utterly stale data

	# done with the standard work, now run any plugins that offer update_plugin()
	for my $plugin (@active_plugins)
	{
		my $funcname = $plugin->can("update_plugin");
		next if ( !$funcname );

		NMISNG::Util::dbg("Running update plugin $plugin with node $name");
		my ( $status, @errors );
		$S->nmisng->log->logprefix("$plugin ");
		eval { ( $status, @errors ) = &$funcname( node => $name,
																							sys => $S,
																							config => $C,
																							nmisng => $S->nmisng, ); };
		$S->nmisng->log->logprefix(undef);
		if ( $status >= 2 or $status < 0 or $@ )
		{
			NMISNG::Util::logMsg("Error: Plugin $plugin failed to run: $@") if ($@);
			for my $err (@errors)
			{
				NMISNG::Util::logMsg("Error: Plugin $plugin: $err");
			}
		}
		elsif ( $status == 1 )    # changes were made, need to re-save the view and info files
		{
			NMISNG::Util::dbg("Plugin $plugin indicated success, updating node and view files");
			$S->writeNodeView;
			$S->writeNodeInfo;
			$catchall_inventory->save();
		}
		elsif ( $status == 0 )
		{
			NMISNG::Util::dbg("Plugin $plugin indicated no changes");
		}
	}

	my $updatetime = $updatetimer->elapTime();
	NMISNG::Util::info("updatetime for $name was $updatetime");
	$reachdata->{updatetime} = {value => $updatetime, option => "gauge,0:U," . ( 86400 * 3 )};

	# parrot the previous reading's poll time
	my $prevval = "U";
	if ( my $rrdfilename = $S->makeRRDname( graphtype => "health" ) )
	{
		my $infohash = RRDs::info($rrdfilename);
		$prevval = $infohash->{'ds[polltime].last_ds'} if ( defined $infohash->{'ds[polltime].last_ds'} );
	}
	$reachdata->{polltime} = {value => $prevval, option => "gauge,0:U,"};

	# runReach makes sure this is created
	my $inventory = $S->inventory( concept => 'health' );
	if ( !$S->create_update_rrd( data => $reachdata, type => "health", inventory => $inventory ) )
	{
		NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
	}
	else
	{
		my $pit = {};
		my $previous_pit = $inventory->get_newest_timed_data();
		NMISNG::Inventory::parse_rrd_update_data( $reachdata, $pit, $previous_pit, 'health' );
		my $stats = nodeSummaryStats(C => $C,S => $S, inventory => $inventory, catchall_data => $catchall_data);
		my $error = $inventory->add_timed_data( data => $pit, derived_data => $stats, subconcept => 'health',
																						time => $catchall_data->{last_poll}, delay_insert => 1 );
		NMISNG::Util::logMsg("ERROR: timed data adding for health failed: $error") if ($error);
		# $inventory->data($data);
		$inventory->save();
	}
	$S->close;

	$catchall_inventory->save();
	NMISNG::Util::releasePollLock( handle => $lockHandle, type => "update", conf => $C->{conf}, node => $name );

	if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) )
	{

		NMISNG::Util::logMsg("Poll Time: $name, $catchall_data->{nodeModel}, $updatetime");
	}
	NMISNG::Util::info("Finished");
	return;
}

#=========================================================================================

# a function to load the available code plugins,
# returns the list of package names that have working plugins
sub load_plugins
{
	my @activeplugins;

	# check for plugins enabled and the dir
	return () if ( !NMISNG::Util::getbool( $C->{plugins_enabled} )
		or !$C->{plugin_root}
		or !-d $C->{plugin_root} );

	if ( !opendir( PD, $C->{plugin_root} ) )
	{
		NMISNG::Util::logMsg("Error: cannot open plugin dir $C->{plugin_root}: $!");
		return ();
	}
	my @candidates = grep( /\.pm$/, readdir(PD) );
	closedir(PD);

	for my $candidate (@candidates)
	{
		my $packagename = $candidate;
		$packagename =~ s/\.pm$//;

		# read it and check that it has precisely one matching package line
		NMISNG::Util::dbg("Checking candidate plugin $candidate");
		if ( !open( F, $C->{plugin_root} . "/$candidate" ) )
		{
			NMISNG::Util::logMsg("Error: cannot open plugin file $candidate: $!");
			next;
		}
		my @plugindata = <F>;
		close F;
		my @packagelines = grep( /^\s*package\s+[a-zA-Z0-9_:-]+\s*;\s*$/, @plugindata );
		if ( @packagelines > 1 or $packagelines[0] !~ /^\s*package\s+$packagename\s*;\s*$/ )
		{
			NMISNG::Util::logMsg("Plugin $candidate doesn't have correct \"package\" declaration. Ignoring.");
			next;
		}

		# do the actual load and eval
		eval { require $C->{plugin_root} . "/$candidate"; };
		if ($@)
		{
			NMISNG::Util::logMsg("Ignoring plugin $candidate as it isn't valid perl: $@");
			next;
		}

		# we're interested if one or more of the supported plugin functions are provided
		push @activeplugins, $packagename
			if ( $packagename->can("update_plugin")
			or $packagename->can("collect_plugin")
			or $packagename->can("after_collect_plugin")
			or $packagename->can("after_update_plugin") );
	}

	return sort @activeplugins;
}

# this function runs ONLY NON-SNMP services!
# args: only name (node name)
# returns: nothing
sub doServices
{
	my (%args) = @_;
	my $name = $args{name};

	NMISNG::Util::info("================================");
	NMISNG::Util::info("Starting services, node $name");

	# lets change our name for process runtime checking
	$0 = "poll-services-$name";

	my $S = NMISNG::Sys->new;
	$S->init( name => $name );

	$S->readNodeView;    # init does not load the node view, but runservices updates view data!
	runServices( sys => $S, snmp => 'false' );

	# we have to update the node view file, or newly added service status info will be lost/missed...
	$S->writeNodeView;

	return;
}

# perform collect run on ONE node
sub doCollect
{
	my %args = @_;
	my ($name,$wantsnmp,$wantwmi, $policy) = @args{"name","wantsnmp","wantwmi","policy"};


	my $pollTimer = Compat::Timing->new;

	NMISNG::Util::info("================================");
	NMISNG::Util::info("Starting collect, node $name, want SNMP: ".($wantsnmp?"yes":"no")
			 .", want WMI: ".($wantwmi?"yes":"no"));

	# Check for both update and collect locks - but update lock existence is NOT
	# an error when we're polling frequently!
	if ( NMISNG::Util::existsPollLock( type => "update", conf => $C->{conf}, node => $name ) )
	{
		NMISNG::Util::logMsg("INFO skipping collect for node $node because of active update lock");
		return;
	}
	if ( NMISNG::Util::existsPollLock( type => "collect", conf => $C->{conf}, node => $name ) )
	{
		print STDERR "Error: collect lock exists for $name which has not finished!\n";
		NMISNG::Util::logMsg("WARNING collect lock exists for $name which has not finished!");
		return;
	}

	# create the poll lock now.
	my $lockHandle = NMISNG::Util::createPollLock( type => "collect", conf => $C->{conf}, node => $name );

	# lets change our name, so a ps will report who we are
	$0 = "poll-collect-$name";

	my $S = NMISNG::Sys->new;
	if ( !$S->init( name => $name,
									snmp => $wantsnmp,
									wmi => $wantwmi,
									policy => $policy,
									debug => $C->{debug} ) )
	{
		NMISNG::Util::dbg( "Sys init for $name failed: "
				. join( ", ", map { "$_=" . $S->status->{$_} } (qw(error snmp_error wmi_error)) ) );

		NMISNG::Util::info("no info available of node $name, switching to update operation instead");
		doUpdate( name => $name );
		NMISNG::Util::info("Finished update instead of collect");
		return;                          # collect has to wait until a next run
	}

	my $configuration = $S->nmisng_node->configuration();
	my $catchall_inventory = $S->inventory( concept => 'catchall' );
	my $catchall_data = $catchall_inventory->data_live();

	NMISNG::Util::dbg( "node=$name "
			. join( " ", map { "$_=" . $catchall_data->{$_} } (qw(group nodeType nodedown snmpdown wmidown)) ) );

	# update node info data, merge in the node's configuration (which was loaded by sys' init)
	$S->copyModelCfgInfo( type => 'all' );

	$S->readNodeView;    # s->init does NOT load that, but we need it as we're overwriting some view info

	# run an update if no update poll time is known
	if ( !exists( $catchall_data->{last_update} ) or !$catchall_data->{last_update} )
	{
		NMISNG::Util::info("no cached node data available, running an update now");
		doUpdate( name => $name );
		NMISNG::Util::info("update done, continue with collect");
	}

	NMISNG::Util::info("node=$catchall_data->{name} role=$catchall_data->{roleType} type=$catchall_data->{nodeType}");
	NMISNG::Util::info("vendor=$catchall_data->{nodeVendor} model=$catchall_data->{nodeModel} interfaces=$catchall_data->{ifNumber}");

	# are we meant to and able to talk to the node?
	# runping sets the last_poll marker - fixme9: no idea why
	if ( runPing( sys => $S, time_marker => $starttime ) && NMISNG::Util::getbool( $configuration->{collect} ) )
	{
	# snmp-enabled node? then try to create a session obj (but as snmp is still predominantly udp it won't connect yet!)
		$S->open(
			timeout      => $C->{snmp_timeout},
			retries      => $C->{snmp_retries},
			max_msg_size => $C->{snmp_max_msg_size},

			# how many oids/pdus per bulk request, or let net::snmp guess a value
			max_repetitions => $catchall_data->{max_repetitions} || $C->{snmp_max_repetitions} || undef,

			# how many oids per simple get request for getarray, or default (no guessing)
			oidpkt => $catchall_data->{max_repetitions} || $C->{snmp_max_repetitions} || 10
		) if ( $S->status->{snmp_enabled} );

		# failed already?
		if ( $S->status->{snmp_error} )
		{
			NMISNG::Util::logMsg( "ERROR SNMP session open to $node failed: " . $S->status->{snmp_error} );
			$S->disable_source("snmp");
		}

		# returns 1 if one or more sources have worked, also updates snmp/wmi down states in nodeinfo/catchall
		# and sets the relevant last_poll_xyz markers
		my $updatewasok = updateNodeInfo(sys=>$S, time_marker => $starttime);
		my $curstate = $S->status;    # updatenodeinfo does NOT disable faulty sources!

	# was snmp ok? should we bail out? note that this is interpreted to apply to ALL sources being down simultaneously,
	# NOT just snmp. otherwise a wmi-only node would never be polled.
	# fixme: likely needs companion wmi_stop_polling_on_error, and both criteria would need to be satisfied for stopping
		if (    NMISNG::Util::getbool( $C->{snmp_stop_polling_on_error} )
			and NMISNG::Util::getbool( $catchall_data->{snmpdown} )
			and NMISNG::Util::getbool( $catchall_data->{wmidown} ) )
		{
			NMISNG::Util::logMsg(
				"Polling stopped for $catchall_data->{name} because SNMP and WMI had errors, snmpdown=$catchall_data->{snmpdown} wmidown=$catchall_data->{wmidown}"
			);
		}
		elsif ($updatewasok)    # at least some info was retrieved by wmi or snmp
		{
			if ( $model or $C->{info} )
			{
				print
					"MODEL $S->{name}: role=$catchall_data->{roleType} type=$catchall_data->{nodeType} sysObjectID=$catchall_data->{sysObjectID} sysObjectName=$catchall_data->{sysObjectName}\n";
				print "MODEL $S->{name}: sysDescr=$catchall_data->{sysDescr}\n";
				print
					"MODEL $S->{name}: vendor=$catchall_data->{nodeVendor} model=$catchall_data->{nodeModel} interfaces=$catchall_data->{ifNumber}\n";
			}

			# at this point we need to tell sys that dead sources are to be ignored
			for my $source (qw(snmp wmi))
			{
				if ( $curstate->{"${source}_error"} )
				{
					$S->disable_source($source);
				}
			}
			# if runping hasn't set the last_poll marker, set it here unconditionally
			# remember when the collect poll last completed (doesn't mean successfully!),
			# this isn't saved  until later so set it early so functions can use it
			$catchall_data->{last_poll} = $starttime;

			# fixme: why no error handling for any of these?

			# get node data and store in rrd
			getNodeData( sys => $S );

			# get intf data and store in rrd
			my $ids = $S->nmisng_node->get_inventory_ids( concept => 'interface' );
			getIntfData( sys => $S ) if( @$ids > 0);
			getSystemHealthData( sys => $S );

			getCBQoS( sys => $S );

			runServer( sys => $S );

			# Custom Alerts
			runAlerts( sys => $S ) if defined $S->{mdl}{alerts};

		}
		else
		{
			my $msg = "updateNodeInfo for $name failed: "
				. join( ", ", map { "$_=" . $S->status->{$_} } (qw(error snmp_error wmi_error)) );
			NMISNG::Util::logMsg("ERROR $msg");
			NMISNG::Util::info("Error: $msg");
		}
	}

	# Need to poll services under all circumstances, i.e. if no ping, or node down or set to no collect
	# but try snmp services only if snmp is actually ok
	runServices( sys => $S, snmp => NMISNG::Util::getbool( $catchall_data->{snmpdown} ) ? 'false' : 'true' );

	runCheckValues( sys => $S );

	# don't let runreach perform the rrd update, we want to add the polltime to it!
	my $reachdata = runReach( sys => $S, delayupdate => 1 );

	# compute thresholds with the node, if configured to do so
	if ( NMISNG::Util::getbool( $C->{threshold_poll_node} ) )
	{
		doThresholdsAndCreateStatus( name => $S->{name}, sys => $S, table => {} );
	}

	$S->writeNodeView;
	$S->writeNodeInfo;
	$catchall_inventory->save();

	# done with the standard work, now run any plugins that offer collect_plugin()
	for my $plugin (@active_plugins)
	{
		my $funcname = $plugin->can("collect_plugin");
		next if ( !$funcname );

		NMISNG::Util::dbg("Running collect plugin $plugin with node $name");
		my ( $status, @errors );
		$S->nmisng->log->logprefix("$plugin ");
		eval { ( $status, @errors ) = &$funcname( node => $name,
																							sys => $S,
																							config => $C,
																							nmisng => $S->nmisng ); };
		$S->nmisng->log->logprefix(undef);
		if ( $status >= 2 or $status < 0 or $@ )
		{
			NMISNG::Util::logMsg("Error: Plugin $plugin failed to run: $@") if ($@);
			for my $err (@errors)
			{
				NMISNG::Util::logMsg("Error: Plugin $plugin: $err");
			}
		}
		elsif ( $status == 1 )    # changes were made, need to re-save the view and info files
		{
			NMISNG::Util::dbg("Plugin $plugin indicated success, updating node and view files");
			$S->writeNodeView;
			$S->writeNodeInfo;
			$catchall_inventory->save();
		}
		elsif ( $status == 0 )
		{
			NMISNG::Util::dbg("Plugin $plugin indicated no changes");
		}
	}
	my $polltime = $pollTimer->elapTime();
	NMISNG::Util::info("polltime for $name was $polltime");
	$reachdata->{polltime} = {value => $polltime, option => "gauge,0:U"};

	# parrot the previous reading's update time
	my $prevval = "U";
	if ( my $rrdfilename = $S->makeRRDname( graphtype => "health" ) )
	{
		my $infohash = RRDs::info($rrdfilename);
		$prevval = $infohash->{'ds[updatetime].last_ds'} if ( defined $infohash->{'ds[updatetime].last_ds'} );
	}
	$reachdata->{updatetime} = {value => $prevval, option => "gauge,0:U," . ( 86400 * 3 )};

	# runReach makes sure this is created
	my $inventory = $S->inventory( concept => 'health' );
	if ( !$S->create_update_rrd( data => $reachdata, type => "health", inventory => $inventory ) )
	{
		NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
	}
	else
	{
		my $pit = {};
		my $previous_pit = $inventory->get_newest_timed_data();
		NMISNG::Inventory::parse_rrd_update_data( $reachdata, $pit, $previous_pit, 'health' );
		my $stats = nodeSummaryStats(C => $C,S => $S, inventory => $inventory, catchall_data => $catchall_data);
		my $error = $inventory->add_timed_data( data => $pit, derived_data => $stats, subconcept => 'health',
																						time => $catchall_data->{last_poll}, delay_insert => 1 );
		NMISNG::Util::logMsg("ERROR: timed data adding for health failed: $error") if ($error);
		# $inventory->data($data);
		$inventory->save();
	}
	$S->close;

	$catchall_inventory->save();
	NMISNG::Util::releasePollLock( handle => $lockHandle, type => "collect", conf => $C->{conf}, node => $name );

	if ( NMISNG::Util::getbool( $C->{log_polling_time} ) )
	{
		NMISNG::Util::logMsg("Poll Time: $name, $catchall_data->{nodeModel}, $polltime");
	}
	NMISNG::Util::info("Finished");
	return;
}

# normally a daemon fpingd is running (if set in NMIS config) and stores the result in var/nmis-fping.xxxx
# if node info missing then ping.pm is used
# returns: 1 if pingable, 0 otherwise
sub runPing
{
	my %args = @_;
	my $S    = $args{sys};
	my $V    = $S->view;      # node view data
	my $RI   = $S->reach;     # reach table
	my $NC   = $S->ndcfg;     # node config

	my $time_marker = $args{time_marker} || time;

	my $catchall_data = $S->inventory(concept => 'catchall')->data_live();


	my ( $ping_min, $ping_avg, $ping_max, $ping_loss, $pingresult );

	# setup log filter for getNodeInfo() - fixme why is that done here?
	$S->snmp->logFilterOut(qr/no response from/)
		if ( $S->snmp && NMISNG::Util::getbool( $catchall_data->{snmpdown} ) );

	# preset view of node status
	$V->{system}{status_value} = 'unknown';
	$V->{system}{status_title} = 'Node Status';
	$V->{system}{status_color} = '#0F0';

	if ( NMISNG::Util::getbool( $NC->{node}{ping} ) )
	{
		my $PT;

		# use fastping info if its meant to be available, and actually is
		if (   NMISNG::Util::getbool( $C->{daemon_fping_active} )
			&& ( $PT = NMISNG::Util::loadTable( dir => 'var', name => 'nmis-fping' ) )
			&& exists( $PT->{$NC->{node}{name}}{loss} ) )
		{
			# copy values
			$ping_avg   = $PT->{$NC->{node}{name}}{avg};
			$ping_loss  = $PT->{$NC->{node}{name}}{loss};
			$pingresult = ( $ping_loss < 100 ) ? 100 : 0;
			NMISNG::Util::info("INFO ($S->{name}) PING min/avg/max = $ping_min/$ping_avg/$ping_max ms loss=$ping_loss%");
		}
		else
		{
			# fallback to internal/synchronous system
			my $retries = $C->{ping_retries} ? $C->{ping_retries} : 3;
			my $timeout = $C->{ping_timeout} ? $C->{ping_timeout} : 300;
			my $packet  = $C->{ping_packet}  ? $C->{ping_packet}  : 56;
			my $host = $NC->{node}{host};          # ip name/adress of node

			NMISNG::Util::info("Pinging $S->{name} ($host) with timeout=$timeout retries=$retries packet=$packet");

			( $ping_min, $ping_avg, $ping_max, $ping_loss ) = NMISNG::Ping::ext_ping( $host, $packet, $retries, $timeout );
			$pingresult = defined $ping_min ? 100 : 0;    # ping_min is undef if unreachable.

		}

		# at this point ping_{min,avg,max,loss} and pingresult are all set

		# in the fpingd case all up/down events are handled by it
		if ( !NMISNG::Util::getbool( $C->{daemon_fping_active} ) )
		{
			if ($pingresult)
			{
				# up
				# are the nodedown status and event db out of sync?
				if ( not NMISNG::Util::getbool( $catchall_data->{nodedown} ) and Compat::NMIS::eventExist( $catchall_data->{name}, "Node Down", "" ) )
				{
					my $result = Compat::NMIS::checkEvent(
						sys     => $S,
						event   => "Node Down",
						level   => "Normal",
						element => "",
						details => "Ping failed"
					);
					NMISNG::Util::info("Fixing Event DB error: $S->{name}, Event DB says Node Down but nodedown said not.");
				}
				else
				{
					# note: up event is handled regardless of snmpdown/pingonly/snmponly, which the
					# frontend Compat::NMIS::nodeStatus() takes proper care of.
					NMISNG::Util::info("$S->{name} is PINGABLE min/avg/max = $ping_min/$ping_avg/$ping_max ms loss=$ping_loss%");
					HandleNodeDown(
						sys     => $S,
						type    => "node",
						up      => 1,
						details => "Ping avg=$ping_avg loss=$ping_loss%"
					);
				}
			}
			else
			{
				# down - log if not already down
				NMISNG::Util::logMsg("ERROR ($S->{name}) ping failed") if ( !NMISNG::Util::getbool( $catchall_data->{nodedown} ) );
				HandleNodeDown( sys => $S, type => "node", details => "Ping failed" );
			}
		}

		$RI->{pingavg}    = $ping_avg;     # results for sub runReach
		$RI->{pingresult} = $pingresult;
		$RI->{pingloss}   = $ping_loss;

		# info for web page
		$V->{system}{lastUpdate_value} = NMISNG::Util::returnDateStamp();
		$V->{system}{lastUpdate_title} = 'Last Update';

		# fixme9: why is that set by runping, ever?
		$catchall_data->{last_poll}   = $time_marker;
		delete $catchall_data->{lastCollectPoll}; # replaced by last_poll
	}
	else
	{
		NMISNG::Util::info("$S->{name} ping not requested");
		$RI->{pingresult} = $pingresult = 100;    # results for sub runReach
		$RI->{pingavg}    = 0;
		$RI->{pingloss}   = 0;
	}

	if ($pingresult)
	{
		$V->{system}{status_value} = 'reachable' if ( NMISNG::Util::getbool( $NC->{node}{ping} ) );
		$V->{system}{status_color} = '#0F0';
		$catchall_data->{nodedown}    = 'false';
	}
	else
	{
		$V->{system}{status_value} = 'unreachable';
		$V->{system}{status_color} = 'red';
		$catchall_data->{nodedown}    = 'true';

		# workaround for opCharts not using right data
		$catchall_data->{nodestatus} = 'unreachable';
	}

	NMISNG::Util::info(     "Finished with exit="
			. ( $pingresult ? 1 : 0 )
			. ", nodedown=$catchall_data->{nodedown} nodestatus=$catchall_data->{nodestatus}" );

	return ( $pingresult ? 1 : 0 );
}

# gets node info by snmp/wmi, determines node's model if it can
# this is only run during update type ops (or if we switch to that type on the go)
#
# args: sys
# returns: 1 if _something_ worked, 0 if all a/v collection mechanisms failed
#
# attention: this deletes the interface info if other steps successful
# attention: this function disables all sys' sources that indicate any errors on loadnodeNMISNG::Util::info()!
#
# fixme: this thing is an utter mess logic-wise and urgently needs a rewrite
sub getNodeInfo
{
	my (%args) = @_;
	my $S    = $args{sys};
	my $RI   = $S->reach;          # reach table
	my $V    = $S->view;           # web view
	my $M    = $S->mdl;            # model table
	my $NC   = $S->ndcfg;          # node config
	my $SNMP = $S->snmp;           # snmp object
	my $C    = NMISNG::Util::loadConfTable();    # system config

	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	my $exit = 0;                  # assume failure by default
	$RI->{snmpresult} = $RI->{wmiresult} = 0;

	NMISNG::Util::info("Starting");

	# fixme: unclean access to internal property,
	# fixme also fails if we've switched to updating this node on the go!
	if ( NMISNG::Util::getbool( $S->{update} )
		and !NMISNG::Util::getbool( $NC->{node}{collect} ) )    # rebuild
	{
		delete $V->{interface};
	}

	my $oldstate = $S->status;                    # what did we start with for snmp_enabled, wmi_enabled?
	my $curstate;

	# if collect is off, only nodeconf overrides are loaded
	if ( NMISNG::Util::getbool( $NC->{node}{collect} ) )
	{
		# get basic node info by snmp or wmi: sysDescr, sysObjectID, sysUpTime etc

		# this is normally with the DEFAULT model from Model.nmis
		# fixme: not true if switched to update op on the go!
		my $firstloadok = $S->loadNodeInfo();

		# source that hasn't worked? disable immediately
		$curstate = $S->status;
		for my $source (qw(snmp wmi))
		{
			if ( $curstate->{"${source}_error"} )
			{
				$S->disable_source($source);

				# copy over the error so that we can figure out that this source is indeed down,
				# not just disabled from the get-go
				$oldstate->{"${source}_error"} = $curstate->{"${source}_error"};
			}
		}

		if ($firstloadok)
		{

			# snmp: continue processing if at least a couple of entries are valid.
			if ( $catchall_data->{sysDescr} and $catchall_data->{sysObjectID} )
			{
				my $enterpriseTable = Compat::NMIS::loadEnterpriseTable();    # table is already cached

				# if the vendors product oid file is loaded, this will give product name.
				$catchall_data->{sysObjectName} = NMISNG::MIB::oid2name( $catchall_data->{sysObjectID} );

				NMISNG::Util::info("sysObjectId=$catchall_data->{sysObjectID}, sysObjectName=$catchall_data->{sysObjectName}");
				NMISNG::Util::info("sysDescr=$catchall_data->{sysDescr}");

				# Decide on vendor name.
				my @x = split( /\./, $catchall_data->{sysObjectID} );
				my $i = $x[6];

				# Special handling for devices with bad sysObjectID, e.g. Trango
				if ( not $i )
				{
					$i = $catchall_data->{sysObjectID};
				}

				if ( $enterpriseTable->{$i}{Enterprise} ne "" )
				{
					$catchall_data->{nodeVendor} = $enterpriseTable->{$i}{Enterprise};
				}
				else
				{
					$catchall_data->{nodeVendor} = "Universal";
				}
				NMISNG::Util::dbg("oid index $i, Vendor is $catchall_data->{nodeVendor}");
			}

			# iff snmp is a dud, look at some wmi properties
			elsif ( $catchall_data->{winbuild} && $catchall_data->{winosname} && $catchall_data->{winversion} )
			{
				NMISNG::Util::info("winosname=$catchall_data->{winosname} winversion=$catchall_data->{winversion}");

				# synthesize something compatible with what win boxes spit out via snmp:
				# i'm too lazy to also wmi-poll Manufacturer and strip off the 'corporation'
				$catchall_data->{nodeVendor} = "Microsoft";

				# the winosname is not the same/enough
				$catchall_data->{sysDescr}
					= $catchall_data->{winosname} . " Windows Version " . $catchall_data->{winversion};
				$catchall_data->{sysName} = $catchall_data->{winsysname};
			}

			# but if neither worked, do not continue processing anything model-related!
			if ( $catchall_data->{sysDescr} or !$catchall_data->{nodeVendor} )
			{
				# fixme: the auto-model decision should be made FIRST, before doing any loadNMISNG::Util::info(),
				# this function's logic needs a complete rewrite
				if ( $NC->{node}{model} eq 'automatic' || $NC->{node}{model} eq "" )
				{
					# get nodeModel based on nodeVendor and sysDescr (real or synthetic)
					$catchall_data->{nodeModel} = $S->selectNodeModel();    # select and save name in node info table
					NMISNG::Util::info("selectNodeModel returned model=$catchall_data->{nodeModel}");

					$catchall_data->{nodeModel} ||= 'Default';              # fixme why default and not generic?
				}
				else
				{
					$catchall_data->{nodeModel} = $NC->{node}{model};
					NMISNG::Util::info("node model=$catchall_data->{nodeModel} set by node config");
				}

				NMISNG::Util::dbg("about to loadModel model=$catchall_data->{nodeModel}");
				$S->loadModel( model => "Model-$catchall_data->{nodeModel}" );

				# now we know more about the host, nodetype and model have been positively determined,
				# so we'll force-overwrite those values
				$S->copyModelCfgInfo( type => 'overwrite' );

				# add web page info
				delete $V->{system} if NMISNG::Util::getbool( $S->{update} );    # rebuild; fixme unclean access to internal property

				$V->{system}{status_value}  = 'reachable';
				$V->{system}{status_title}  = 'Node Status';
				$V->{system}{status_color}  = '#0F0';
				$V->{system}{sysName_value} = $catchall_data->{sysName};
				$V->{system}{sysName_title} = 'System Name';

				$V->{system}{sysObjectName_value}   = $catchall_data->{sysObjectName};
				$V->{system}{sysObjectName_title}   = 'Object Name';
				$V->{system}{nodeVendor_value}      = $catchall_data->{nodeVendor};
				$V->{system}{nodeVendor_title}      = 'Vendor';
				$V->{system}{group_value}           = $catchall_data->{group};
				$V->{system}{group_title}           = 'Group';
				$V->{system}{customer_value}        = $catchall_data->{customer};
				$V->{system}{customer_title}        = 'Customer';
				$V->{system}{location_value}        = $catchall_data->{location};
				$V->{system}{location_title}        = 'Location';
				$V->{system}{businessService_value} = $catchall_data->{businessService};
				$V->{system}{businessService_title} = 'Business Service';
				$V->{system}{serviceStatus_value}   = $catchall_data->{serviceStatus};
				$V->{system}{serviceStatus_title}   = 'Service Status';
				$V->{system}{notes_value}           = $catchall_data->{notes};
				$V->{system}{notes_title}           = 'Notes';

				# make sure any required data from network_viewNode_field_list gets added.
				my @viewNodeFields = split( ",", $C->{network_viewNode_field_list} );
				foreach my $field (@viewNodeFields)
				{
					if ( defined $catchall_data->{$field}
						and
						( not defined $V->{system}{"${field}_value"} or not defined $V->{system}{"${field}_title"} ) )
					{
						$V->{system}{"${field}_title"} = $field;
						$V->{system}{"${field}_value"} = $catchall_data->{$field};
					}
				}

				# update node info table a second time, but now with the actually desired model
				# fixme: see logic problem above, should not have to do both
				my $secondloadok = $S->loadNodeInfo();

				# source that hasn't worked? disable immediately
				$curstate = $S->status;
				for my $source (qw(snmp wmi))
				{
					$S->disable_source($source) if ( $curstate->{"${source}_error"} );
				}

				if ($secondloadok)
				{
					# sysuptime is only a/v if snmp, with wmi we have synthesize it as wintime-winboottime
					# it's also mangled on the go
					makesysuptime($S);
					$V->{system}{sysUpTime_value} = $catchall_data->{sysUpTime};

					$catchall_data->{server} = $C->{server_name};

					# pull / from VPN3002 system descr
					$catchall_data->{sysDescr} =~ s/\// /g;

					# collect DNS location info.
					getDNSloc( sys => $S );

					# PIX failover test
					checkPIX( sys => $S );

					$exit = 1;    # done
				}
				else
				{
					NMISNG::Util::logMsg("ERROR loadNodeInfo with specific model failed!");
				}
			}
			else
			{
				NMISNG::Util::info("ERROR could retrieve sysDescr or winosname, cannot determine model!");
			}
		}
		else                      # fixme unclear why this reaction to failed getnodeinfo?
		{
			# load the model prev found
			$S->loadModel( model => "Model-$catchall_data->{nodeModel}" ) if ( $catchall_data->{nodeModel} ne '' );
		}
	}
	else
	{
		NMISNG::Util::dbg("node $S->{name} is marked collect is 'false'");
		$exit = 1;                # done
	}

	# get and apply any nodeconf override if such exists for this node
	my $nodename = $catchall_data->{name};
	my ( $errmsg, $override ) = Compat::NMIS::get_nodeconf( node => $nodename )
		if ( Compat::NMIS::has_nodeconf( node => $nodename ) );
	NMISNG::Util::logMsg("ERROR $errmsg") if $errmsg;
	$override ||= {};

	if ( $override->{sysLocation} )
	{
		$catchall_data->{sysLocation} = $V->{system}{sysLocation_value} = $override->{sysLocation};
		NMISNG::Util::info("Manual update of sysLocation by nodeConf");
	}

	if ( $override->{sysContact} )
	{
		$catchall_data->{sysContact} = $V->{system}{sysContact_value} = $override->{sysContact};
		NMISNG::Util::dbg("Manual update of sysContact by nodeConf");
	}

	if ( $override->{nodeType} )
	{
		$catchall_data->{nodeType} = $override->{nodeType};
	}
	else
	{
		delete $catchall_data->{nodeType};
	}

	# process the overall results, set node states etc.
	for my $source (qw(snmp wmi))
	{
		# $curstate should be state as of last loadNMISNG::Util::info() op

		# we can call a source ok iff we started with it enabled, still enabled,
		# and the (second) loadnodeinfo didn't turn up any trouble for this source
		if (   $oldstate->{"${source}_enabled"}
			&& $curstate->{"${source}_enabled"}
			&& !$curstate->{"${source}_error"} )
		{
			$RI->{"${source}result"} = 100;
			my $sourcename = uc($source);

			# happy, clear previous source down flag and event (if any)
			HandleNodeDown( sys => $S, type => $source, up => 1, details => "$sourcename ok" );
		}

		# or fire down event if it was enabled but didn't work
		# ie. if it's no longer enabled and has an error saved in oldstate or a new one
		elsif ($oldstate->{"${source}_enabled"}
			&& !$curstate->{"${source}_enabled"}
			&& ( $oldstate->{"${source}_error"} || $curstate->{"${source}_error"} ) )
		{
			HandleNodeDown(
				sys     => $S,
				type    => $source,
				details => $curstate->{"${source}_error"} || $oldstate->{"${source}_error"}
			);
		}
	}

	if ($exit)
	{
		# add web page info
		$V->{system}{timezone_value}  = $catchall_data->{timezone};
		$V->{system}{timezone_title}  = 'Time Zone';
		$V->{system}{nodeModel_value} = $catchall_data->{nodeModel};
		$V->{system}{nodeModel_title} = 'Model';
		$V->{system}{nodeType_value}  = $catchall_data->{nodeType};
		$V->{system}{nodeType_title}  = 'Type';
		$V->{system}{roleType_value}  = $catchall_data->{roleType};
		$V->{system}{roleType_title}  = 'Role';
		$V->{system}{netType_value}   = $catchall_data->{netType};
		$V->{system}{netType_title}   = 'Net';

		# get the current ip address if the host property was a name
		if ( ( my $addr = Compat::NMIS::resolveDNStoAddr( $catchall_data->{host} ) ) )
		{
			$catchall_data->{host_addr}      = $addr;    # cache it
			$V->{system}{host_addr_value} = $addr;
			$V->{system}{host_addr_value} .= " ($catchall_data->{host})" if ( $addr ne $catchall_data->{host} );
			$V->{system}{host_addr_title} = 'IP Address';
		}
		else
		{
			$catchall_data->{host_addr}    = '';
			$V->{system}{host_addr_value} = "N/A";
			$V->{system}{host_addr_title} = 'IP Address';
		}
	}
	else
	{
		# node status info web page
		$V->{system}{status_title} = 'Node Status';
		if ( NMISNG::Util::getbool( $NC->{node}{ping} ) )
		{
			$V->{system}{status_value} = 'degraded';
			$V->{system}{status_color} = '#FFFF00';
		}
		else
		{
			$V->{system}{status_value} = 'unreachable';
			$V->{system}{status_color} = 'red';
		}
	}

	NMISNG::Util::info( "Finished with exit=$exit "
			. join( " ", map { "$_=" . $catchall_data->{$_} } (qw(nodedown snmpdown wmidown)) ) );

	return $exit;
}

sub getDNSloc
{
	my %args = @_;
	my $S    = $args{sys};        # node object
	my $C    = NMISNG::Util::loadConfTable();
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	NMISNG::Util::dbg("Starting");

	# collect DNS location info. Update this info every update pass.
	$catchall_data->{loc_DNSloc} = "unknown";
	my $tmphostname = $catchall_data->{host};
	if ( NMISNG::Util::getbool( $C->{loc_from_DNSloc} ))
	{
		my ( $rr, $lat, $lon );
		my $res = Net::DNS::Resolver->new;
		if ( $tmphostname =~ /\d+\.\d+\.\d+\.\d+/ )
		{
			# find reverse lookup as this is an ip
			my $query = $res->query( "$tmphostname", "PTR" );
			if ($query)
			{
				foreach $rr ( $query->answer )
				{
					next unless $rr->type eq "PTR";
					$tmphostname = $rr->ptrdname;
					NMISNG::Util::dbg("DNS Reverse query $tmphostname");
				}
			}
			else
			{
				NMISNG::Util::dbg("ERROR, DNS Reverse query failed: $res->errorstring");
			}
		}

		#look up loc for hostname
		my $query = $res->query( "$tmphostname", "LOC" );
		if ($query)
		{
			foreach $rr ( $query->answer )
			{
				next unless $rr->type eq "LOC";
				( $lat, $lon ) = $rr->latlon;
				$catchall_data->{loc_DNSloc} = $lat . "," . $lon . "," . $rr->altitude;
				NMISNG::Util::dbg("Location from DNS LOC query is $catchall_data->{loc_DNSloc}");
			}
		}
		else
		{
			NMISNG::Util::dbg("ERROR, DNS Loc query failed: $res->errorstring");
		}
	}    # end DNSLoc
	     # if no DNS based location information found - look at sysLocation in router.....
	     # longitude,latitude,altitude,location-text
	if ( NMISNG::Util::getbool( $C->{loc_from_sysLoc} ) and $catchall_data->{loc_DNSloc} eq "unknown" )
	{
		if ( $catchall_data->{sysLocation} =~ /$C->{loc_sysLoc_format}/ )
		{
			$catchall_data->{loc_DNSloc} = $catchall_data->{sysLocation};
			NMISNG::Util::dbg("Location from device sysLocation is $catchall_data->{loc_DNSloc}");
		}
	}    # end sysLoc
	NMISNG::Util::dbg("Finished");
	return 1;
}

# verifies a cisco ciscoEnvMonSupplyState-style power status,
# raises/clears event if required, updates view a little
sub checkPower
{
	my %args = @_;
	my $S    = $args{sys};
	my $V    = $S->view;
	my $M    = $S->mdl;
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();
	NMISNG::Util::info("Starting");

	my $attr = $args{attr};

	NMISNG::Util::info("Start with attribute=$attr");

	delete $V->{system}{"${attr}_value"};

	NMISNG::Util::info("Power check attribute=$attr value=$catchall_data->{$attr}");
	if ( $catchall_data->{$attr} ne '' and $catchall_data->{$attr} !~ /noSuch/ )
	{
		$V->{system}{"${attr}_value"} = $catchall_data->{$attr};

		if ( $catchall_data->{$attr} =~ /normal|unknown|notPresent/ )
		{
			Compat::NMIS::checkEvent(
				sys     => $S,
				event   => "RPS Fail",
				level   => "Normal",
				element => $attr,
				details => "RPS failed"
			);
			$V->{system}{"${attr}_color"} = '#0F0';
		}
		else
		{
			Compat::NMIS::notify(
				sys     => $S,
				event   => "RPS Fail",
				element => $attr,
				details => "RPS failed",
				context => {type => "rps"}
			);
			$V->{system}{"${attr}_color"} = 'red';
		}
	}

	NMISNG::Util::info("Finished");
	return;
}

# try to figure out if the config of a device has been saved or not,
# send node config change event if one detected, update the view a little
sub checkNodeConfiguration
{
	my %args = @_;
	my $S    = $args{sys};
	my $V    = $S->view;
	my $M    = $S->mdl;
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	NMISNG::Util::info("Starting");

	my @updatePrevValues = qw ( configLastChanged configLastSaved bootConfigLastChanged );

	# create previous values if they don't exist
	for my $attr (@updatePrevValues)
	{
		if (   defined( $catchall_data->{$attr} )
			&& $catchall_data->{$attr} ne ''
			&& !defined( $catchall_data->{"${attr}_prev"} ) )
		{
			$catchall_data->{"${attr}_prev"} = $catchall_data->{$attr};
		}
	}

	my $configLastChanged = $catchall_data->{configLastChanged} if defined $catchall_data->{configLastChanged};
	my $configLastViewed  = $catchall_data->{configLastSaved}   if defined $catchall_data->{configLastSaved};
	my $bootConfigLastChanged = $catchall_data->{bootConfigLastChanged}
		if defined $catchall_data->{bootConfigLastChanged};
	my $configLastChanged_prev = $catchall_data->{configLastChanged_prev}
		if defined $catchall_data->{configLastChanged_prev};

	if ( defined $configLastViewed && defined $bootConfigLastChanged )
	{
		NMISNG::Util::info(
			"checkNodeConfiguration configLastChanged=$configLastChanged, configLastViewed=$configLastViewed, bootConfigLastChanged=$bootConfigLastChanged, configLastChanged_prev=$configLastChanged_prev"
		);
	}
	else
	{
		NMISNG::Util::info(
			"checkNodeConfiguration configLastChanged=$configLastChanged, configLastChanged_prev=$configLastChanged_prev"
		);
	}

	# check if config is saved:
	$V->{system}{configLastChanged_value} = NMISNG::Util::convUpTime( $configLastChanged / 100 ) if defined $configLastChanged;
	$V->{system}{configLastSaved_value}   = NMISNG::Util::convUpTime( $configLastViewed / 100 )  if defined $configLastViewed;
	$V->{system}{bootConfigLastChanged_value} = NMISNG::Util::convUpTime( $bootConfigLastChanged / 100 )
		if defined $bootConfigLastChanged;

	### Cisco Node Configuration Change Only
	if ( defined $configLastChanged && defined $bootConfigLastChanged )
	{
		$V->{system}{configurationState_title} = 'Configuration State';

		### when the router reboots bootConfigLastChanged = 0 and configLastChanged
		# is about 2 seconds, which are the changes made by booting.
		if ( $configLastChanged > $bootConfigLastChanged and $configLastChanged > 5000 )
		{
			$V->{system}{"configurationState_value"} = "Config Not Saved in NVRAM";
			$V->{system}{"configurationState_color"} = "#FFDD00";                     #warning
			NMISNG::Util::info("checkNodeConfiguration, config not saved, $configLastChanged > $bootConfigLastChanged");
		}
		elsif ( $bootConfigLastChanged == 0 and $configLastChanged <= 5000 )
		{
			$V->{system}{"configurationState_value"} = "Config Not Changed Since Boot";
			$V->{system}{"configurationState_color"} = "#00BB00";                         #normal
			NMISNG::Util::info("checkNodeConfiguration, config not changed, $configLastChanged $bootConfigLastChanged");
		}
		else
		{
			$V->{system}{"configurationState_value"} = "Config Saved in NVRAM";
			$V->{system}{"configurationState_color"} = "#00BB00";                         #normal
		}
	}

	### If it is newer, someone changed it!
	if ( $configLastChanged > $configLastChanged_prev )
	{
		$catchall_data->{configChangeCount}++;
		$V->{system}{configChangeCount_value} = $catchall_data->{configChangeCount};
		$V->{system}{configChangeCount_title} = "Configuration change count";

		Compat::NMIS::notify(
			sys     => $S,
			event   => "Node Configuration Change",
			element => "",
			details => "Changed at " . $V->{system}{configLastChanged_value},
			context => {type => "node"},
		);
		NMISNG::Util::logMsg("checkNodeConfiguration configuration change detected on $S->{name}, creating event");
	}

	#update previous values to be out current values
	for my $attr (@updatePrevValues)
	{
		if ( defined $catchall_data->{$attr} ne '' && $catchall_data->{$attr} ne '' )
		{
			$catchall_data->{"${attr}_prev"} = $catchall_data->{$attr};
		}
	}

	NMISNG::Util::info("Finished");
	return;

}

# Create the Interface configuration from SNMP Stuff
# except on collect it is always called with a blank interface info
#
# fixme: this function works ONLY if snmp is enabled for the node!
#
# returns: 1 if happy, 0 otherwise
sub getIntfInfo
{
	my %args     = @_;
	my $S        = $args{sys};      # object
	my $intf_one = $args{index};    # index for single interface update
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	if ( !$S->status->{snmp_enabled} )
	{
		NMISNG::Util::info("Not performing getIntfInfo for $S->{name}: SNMP not enabled for this node");
		return 0;                   # no interfaces collected, treat this as error
	}

	my $V    = $S->view;
	my $M    = $S->mdl;             # node model table
	my $SNMP = $S->snmp;
	my $NC   = $S->ndcfg;           # node config table

	my $singleInterface = 0;
	if ( defined $intf_one and $intf_one ne "" )
	{
		$singleInterface = 1;
	}

	my $C        = NMISNG::Util::loadConfTable();
	my $nodename = $catchall_data->{name};

	# create the node here for now, this should be passed in as a param in the future
	my $nmisng = $S->nmisng;
	my $nmisng_node = $S->nmisng_node;

	my $interface_max_number = $C->{interface_max_number} ? $C->{interface_max_number} : 5000;
	my $nocollect_interface_down_days
		= $C->{global_nocollect_interface_down_days} ? $C->{global_nocollect_interface_down_days} : 30;

	my $target_table = {};

	# fixme: hardcoded section name 'standard'
	if ( defined $S->{mdl}{interface}{sys}{standard}
		and $catchall_data->{ifNumber} <= $interface_max_number )
	{
		# Check if the ifTableLastChange has changed.  If it has not changed, the
		# interface table has had no interfaces added or removed, no need to go any further.
		if (    not $singleInterface
			and NMISNG::Util::getbool( $S->{mdl}{custom}{interface}{ifTableLastChange} )
			and my $result = $SNMP->get("ifTableLastChange.0") )
		{
			$result = $result->{"1.3.6.1.2.1.31.1.5.0"};
			if ( defined $result and not defined $catchall_data->{ifTableLastChange} )
			{
				NMISNG::Util::info("$catchall_data->{name} using ifTableLastChange for interface updates");
				$catchall_data->{ifTableLastChange} = $result;
			}
			elsif ( $catchall_data->{ifTableLastChange} != $result )
			{
				NMISNG::Util::info(
					"$catchall_data->{name} ifTableLastChange has changed old=$catchall_data->{ifTableLastChange} new=$result"
				);
				$catchall_data->{ifTableLastChange} = $result;
			}
			else
			{
				NMISNG::Util::info("$catchall_data->{name} ifTableLastChange NO change, skipping ");

				# returning 1 as we can do the rest of the updates.
				return 1;
			}
		}

		# else node may not have this variable so keep on doing in the hard way.

		NMISNG::Util::info("Starting");
		NMISNG::Util::info("Get Interface Info of node $catchall_data->{name}, model $catchall_data->{nodeModel}");

		# lets delete what we have in memory and start from scratch.
		# BUT only if this is for all interfaces
		if ( not $singleInterface )
		{
			NMISNG::Util::TODO("fixme9 Need to mark interfaces as historic!");
		}

		# load interface types (IANA). number => name
		my $IFT = Compat::NMIS::loadifTypesTable();

		my ( $error, $override ) = ( undef, undef );
		( $error, $override ) = Compat::NMIS::get_nodeconf( node => $nodename )
			if ( Compat::NMIS::has_nodeconf( node => $nodename ) );
		NMISNG::Util::logMsg("ERROR $error") if ($error);
		$override ||= {};

		# get interface Index table
		my @ifIndexNum;
		my $ifIndexTable;
		my $ifIndexMap = {};

		if ($singleInterface)
		{
			push( @ifIndexNum, $intf_one );
		}
		else
		{
			if ( $ifIndexTable = $SNMP->gettable('ifIndex') )
			{
				foreach my $oid ( oid_lex_sort( keys %{$ifIndexTable} ) )
				{
					# to handle stupid devices with ifIndexes which are 64 bit integers
					if ( $ifIndexTable->{$oid} < 0 )
					{
						$ifIndexTable->{$oid} = unpack( "I", pack( "i", $ifIndexTable->{$oid} ) );
					}
					push @ifIndexNum, $ifIndexTable->{$oid};
					$ifIndexMap->{$ifIndexTable->{$oid}} = 1;
				}
			}
			else
			{
				if ( $SNMP->error =~ /is empty or does not exist/ )
				{
					NMISNG::Util::info( "SNMP Object Not Present ($S->{name}) on get interface index table: " . $SNMP->error );
				}

				# snmp failed
				else
				{
					NMISNG::Util::logMsg( "ERROR ($S->{name}) on get interface index table: " . $SNMP->error );
					HandleNodeDown( sys => $S, type => "snmp", details => $SNMP->error );
				}

				NMISNG::Util::info("Finished");
				return 0;
			}

			# remove unknown interfaces, found in previous runs, from table
			my @active_indices = keys %$ifIndexMap;
			my $result = $S->nmisng_node->bulk_update_inventory_historic( active_indices => \@active_indices, concept => 'interface' );
			NMISNG::Util::dbg("Interfaces marked historic:$result->{marked_historic}, matched_historic:$result->{matched_historic},".
				"marked marked_nothistoric:$result->{marked_nothistoric}, matched_nothistoric:$result->{matched_nothistoric}");
			NMISNG::Util::logMsg("INFO ($S->{name}) marked historic:$result->{marked_historic}, matched_historic:$result->{matched_historic},".
				"marked marked_nothistoric:$result->{marked_nothistoric}, matched_nothistoric:$result->{matched_nothistoric}");    # test info

			delete $V->{interface};    # rebuild interface view table
		}

		# Loop to get interface information; keep the ifIndexs we care about.
		my @ifIndexNumManage;
		foreach my $index (@ifIndexNum)
		{
			next if ( $singleInterface and $intf_one ne $index );    # only one interface

			$target_table->{$index} = {};
			my $target = $target_table->{$index};
			if ($S->loadInfo(
					class  => 'interface',
					index  => $index,
					model  => $model,
					target => $target
				)
				)
			{
				# note: nodeconf overrides are NOT applied at this point!
				checkIntfInfo( sys => $S, index => $index, iftype => $IFT, target => $target );

				my $keepInterface = 1;
				if (    defined $S->{mdl}{custom}{interface}{skipIfType}
					and $S->{mdl}{custom}{interface}{skipIfType} ne ""
					and $target->{ifType} =~ /$S->{mdl}{custom}{interface}{skipIfType}/ )
				{
					$keepInterface = 0;
					NMISNG::Util::info(
						"SKIP Interface ifType matched skipIfType ifIndex=$index ifDescr=$target->{ifDescr} ifType=$target->{ifType}"
					);
				}
				elsif ( defined $S->{mdl}{custom}{interface}{skipIfDescr}
					and $S->{mdl}{custom}{interface}{skipIfDescr} ne ""
					and $target->{ifDescr} =~ /$S->{mdl}{custom}{interface}{skipIfDescr}/ )
				{
					$keepInterface = 0;
					NMISNG::Util::info(
						"SKIP Interface ifDescr matched skipIfDescr ifIndex=$index ifDescr=$target->{ifDescr} ifType=$target->{ifType}"
					);
				}

				if ( not $keepInterface )
				{
					# not easy.
					foreach my $key ( keys %$target )
					{
						if ( exists $V->{interface}{"${index}_${key}_title"} )
						{
							delete $V->{interface}{"${index}_${key}_title"};
						}
						if ( exists $V->{interface}{"${index}_${key}_value"} )
						{
							delete $V->{interface}{"${index}_${key}_value"};
						}
					}

					# easy!
					delete $target_table->{$index};
					NMISNG::Util::TODO("Should this info be kept but marked disabled?");
				}
				else
				{
					NMISNG::Util::logMsg("INFO ($S->{name}) ifadminstatus is empty for index=$index")
						if $target->{ifAdminStatus} eq "";
					NMISNG::Util::info(
						"ifIndex=$index ifDescr=$target->{ifDescr} ifType=$target->{ifType} ifAdminStatus=$target->{ifAdminStatus} ifOperStatus=$target->{ifOperStatus} ifSpeed=$target->{ifSpeed}"
					);
					push( @ifIndexNumManage, $index );
				}
			}
			else
			{
				# snmp failed
				HandleNodeDown( sys => $S, type => "snmp", details => $S->status->{snmp_error} );

				if ( NMISNG::Util::getbool( $C->{snmp_stop_polling_on_error} ) )
				{
					NMISNG::Util::info("Finished (stop polling on error)");
					return 0;
				}
			}
		}

		# copy the new list back.
		@ifIndexNum       = @ifIndexNumManage;
		@ifIndexNumManage = ();

		# port information optional
		if ( $M->{port} ne "" )
		{
			foreach my $index (@ifIndexNum)
			{
				next if ( $singleInterface and $intf_one ne $index );
				my $target = $target_table->{$index};

				# get the VLAN info: table is indexed by port.portnumber
				if ( $target->{ifDescr} =~ /\d{1,2}\/(\d{1,2})$/i )
				{    # FastEthernet0/1
					my $port = '1.' . $1;
					if ( $target->{ifDescr} =~ /(\d{1,2})\/\d{1,2}\/(\d{1,2})$/i )
					{    # FastEthernet1/0/0
						$port = $1 . '.' . $2;
					}
					if ($S->loadInfo(
							class  => 'port',
							index  => $index,
							port   => $port,
							table  => 'interface',
							model  => $model,
							target => $target
						)
						)
					{
						#
						last if $target->{vlanPortVlan} eq "";    # model does not support CISCO-STACK-MIB
						$V->{interface}{"${index}_portAdminSpeed_value"}
							= NMISNG::Util::convertIfSpeed( $target->{portAdminSpeed} );
						NMISNG::Util::dbg("get VLAN details: index=$index, ifDescr=$target->{ifDescr}");
						NMISNG::Util::dbg("portNumber: $port, VLan: $target->{vlanPortVlan}, AdminSpeed: $target->{portAdminSpeed}" );
					}
				}
				else
				{
					my $port;
					if ( $target->{ifDescr} =~ /(\d{1,2})\D(\d{1,2})$/ )
					{                                                 # 0-0 Catalyst
						$port = $1 . '.' . $2;
					}
					if ($S->loadInfo(
							class  => 'port',
							index  => $index,
							port   => $port,
							table  => 'interface',
							model  => $model,
							target => $target
						)
						)
					{
						#
						last if $target->{vlanPortVlan} eq "";    # model does not support CISCO-STACK-MIB
						$V->{interface}{"${index}_portAdminSpeed_value"}
							= NMISNG::Util::convertIfSpeed( $target->{portAdminSpeed} );
						NMISNG::Util::dbg("get VLAN details: index=$index, ifDescr=$target->{ifDescr}");
						NMISNG::Util::dbg("portNumber: $port, VLan: $target->{vlanPortVlan}, AdminSpeed: $target->{portAdminSpeed}" );
					}
				}
			}
		}

		if (    $singleInterface
			and defined $S->{mdl}{custom}{interface}{skipIpAddressTableOnSingle}
			and NMISNG::Util::getbool( $S->{mdl}{custom}{interface}{skipIpAddressTableOnSingle} ) )
		{
			NMISNG::Util::info("Skipping Device IP Address Table because skipIpAddressTableOnSingle is false");
		}
		else
		{
			my $ifAdEntTable;
			my $ifMaskTable;
			my %ifCnt;
			NMISNG::Util::info("Getting Device IP Address Table");
			if ( $ifAdEntTable = $SNMP->getindex('ipAdEntIfIndex') )
			{
				if ( $ifMaskTable = $SNMP->getindex('ipAdEntNetMask') )
				{
					foreach my $addr ( keys %{$ifAdEntTable} )
					{
						my $index = $ifAdEntTable->{$addr};
						next if ( $singleInterface and $intf_one ne $index );
						$ifCnt{$index} += 1;
						my $target = $target_table->{$index};
						NMISNG::Util::info("ifIndex=$ifAdEntTable->{$addr}, addr=$addr  mask=$ifMaskTable->{$addr}");
						$target->{"ipAdEntAddr$ifCnt{$index}"}    = $addr;
						$target->{"ipAdEntNetMask$ifCnt{$index}"} = $ifMaskTable->{$addr};

						# NOTE: inventory, breaks index convention here! not a big deal but it happens
						(   $target_table->{$ifAdEntTable->{$addr}}{"ipSubnet$ifCnt{$index}"},
							$target_table->{$ifAdEntTable->{$addr}}{"ipSubnetBits$ifCnt{$index}"}
						) = Compat::IP::ipSubnet( address => $addr, mask => $ifMaskTable->{$addr} );
						$V->{interface}{"$ifAdEntTable->{$addr}_ipAdEntAddr$ifCnt{$index}_title"} = 'IP address / mask';
						$V->{interface}{"$ifAdEntTable->{$addr}_ipAdEntAddr$ifCnt{$index}_value"}
							= "$addr / $ifMaskTable->{$addr}";
					}
				}
				else
				{
					NMISNG::Util::dbg("ERROR getting Device Ip Address table");
				}
			}
			else
			{
				NMISNG::Util::dbg("ERROR getting Device Ip Address table");
			}
		}

		# pre compile regex
		my $qr_no_collect_ifDescr_gen      = qr/($S->{mdl}{interface}{nocollect}{ifDescr})/i;
		my $qr_no_collect_ifType_gen       = qr/($S->{mdl}{interface}{nocollect}{ifType})/i;
		my $qr_no_collect_ifAlias_gen      = qr/($S->{mdl}{interface}{nocollect}{Description})/i;
		my $qr_no_collect_ifOperStatus_gen = qr/($S->{mdl}{interface}{nocollect}{ifOperStatus})/i;

		### 2012-03-14 keiths, collecting override based on interface description.
		my $qr_collect_ifAlias_gen = 0;
		$qr_collect_ifAlias_gen = qr/($S->{mdl}{interface}{collect}{Description})/
			if $S->{mdl}{interface}{collect}{Description};
		my $qr_collect_ifDescr_gen = 0;    # undef would be a match-always regex!
		$qr_collect_ifDescr_gen = qr/($S->{mdl}->{interface}->{collect}->{ifDescr})/i
			if ( $S->{mdl}->{interface}->{collect}->{ifDescr} );

		my $qr_no_event_ifAlias_gen = qr/($S->{mdl}{interface}{noevent}{Description})/i;
		my $qr_no_event_ifDescr_gen = qr/($S->{mdl}{interface}{noevent}{ifDescr})/i;
		my $qr_no_event_ifType_gen  = qr/($S->{mdl}{interface}{noevent}{ifType})/i;

		my $noDescription = $M->{interface}{nocollect}{noDescription};

		### 2013-03-05 keiths, global collect policy override from Config!
		if ( defined $C->{global_nocollect_noDescription} and $C->{global_nocollect_noDescription} ne "" )
		{
			$noDescription = $C->{global_nocollect_noDescription};
			NMISNG::Util::info("INFO Model overriden by Global Config for global_nocollect_noDescription");
		}

		if ( defined $C->{global_collect_Description} and $C->{global_collect_Description} ne "" )
		{
			$qr_collect_ifAlias_gen = qr/($C->{global_collect_Description})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_collect_Description");
		}

		# is collection overridden globally, on or off? (on wins if both are set)
		if ( defined $C->{global_collect_ifDescr} and $C->{global_collect_ifDescr} ne '' )
		{
			$qr_collect_ifDescr_gen = qr/($C->{global_collect_ifDescr})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_collect_ifDescr");
		}
		elsif ( defined $C->{global_nocollect_ifDescr} and $C->{global_nocollect_ifDescr} ne "" )
		{
			$qr_no_collect_ifDescr_gen = qr/($C->{global_nocollect_ifDescr})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_nocollect_ifDescr");
		}

		if ( defined $C->{global_nocollect_Description} and $C->{global_nocollect_Description} ne "" )
		{
			$qr_no_collect_ifAlias_gen = qr/($C->{global_nocollect_Description})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_nocollect_Description");
		}

		if ( defined $C->{global_nocollect_ifType} and $C->{global_nocollect_ifType} ne "" )
		{
			$qr_no_collect_ifType_gen = qr/($C->{global_nocollect_ifType})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_nocollect_ifType");
		}

		if ( defined $C->{global_nocollect_ifOperStatus} and $C->{global_nocollect_ifOperStatus} ne "" )
		{
			$qr_no_collect_ifOperStatus_gen = qr/($C->{global_nocollect_ifOperStatus})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_nocollect_ifOperStatus");
		}

		if ( defined $C->{global_noevent_ifDescr} and $C->{global_noevent_ifDescr} ne "" )
		{
			$qr_no_event_ifDescr_gen = qr/($C->{global_noevent_ifDescr})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_noevent_ifDescr");
		}

		if ( defined $C->{global_noevent_Description} and $C->{global_noevent_Description} ne "" )
		{
			$qr_no_event_ifAlias_gen = qr/($C->{global_noevent_Description})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_noevent_Description");
		}

		if ( defined $C->{global_noevent_ifType} and $C->{global_noevent_ifType} ne "" )
		{
			$qr_no_event_ifType_gen = qr/($C->{global_noevent_ifType})/i;
			NMISNG::Util::info("INFO Model overriden by Global Config for global_noevent_ifType");
		}

		my $intfTotal   = 0;
		my $intfCollect = 0;    # reset counters

		NMISNG::Util::info("Checking interfaces for duplicate ifDescr");
		my $ifDescrIndx;
		foreach my $i (@ifIndexNum)
		{
			my $target = $target_table->{$i};

			#foreach my $i (keys %{$IF}) {
			# ifDescr must always be filled
			$target->{ifDescr} ||= $i;

			if ( exists $ifDescrIndx->{$target->{ifDescr}} and $ifDescrIndx->{$target->{ifDescr}} ne "" )
			{
				# ifDescr is duplicated.
				$target->{ifDescr} = "$target->{ifDescr}-$i";                  # add index to string
				$V->{interface}{"${i}_ifDescr_value"} = $target->{ifDescr};    # update
				NMISNG::Util::info("Interface ifDescr changed to $target->{ifDescr}");
			}
			else
			{
				$ifDescrIndx->{$target->{ifDescr}} = $i;
			}
		}
		NMISNG::Util::info("Completed duplicate ifDescr processing");

		### 2012-10-08 keiths, updates to index node conf table by ifDescr instead of ifIndex.
		foreach my $index (@ifIndexNum)
		{
			next if ( $singleInterface and $intf_one ne $index );
			my $target = $target_table->{$index};

			my $ifDescr = $target->{ifDescr};
			$intfTotal++;

			# count total number of real interfaces
			if (    $target->{ifType} !~ /$qr_no_collect_ifType_gen/
				and $target->{ifDescr} !~ /$qr_no_collect_ifDescr_gen/ )
			{
				$target->{real} = 'true';
			}

			### add in anything we find from nodeConf - allows manual updating of interface variables
			### warning - will overwrite what we got from the device - be warned !!!
			if ( ref( $override->{$ifDescr} ) eq "HASH" )
			{
				my $thisintfover = $override->{$ifDescr};

				if ( $thisintfover->{Description} )
				{
					$target->{nc_Description} = $target->{Description};                         # save
					$target->{Description}    = $V->{interface}{"${index}_Description_value"}
						= $thisintfover->{Description};
					NMISNG::Util::info("Manual update of Description by nodeConf");
				}
				if ( $thisintfover->{display_name} )
				{
					$target->{display_name} = $V->{interface}->{"${index}_display_name_value"}
						= $thisintfover->{display_name};
					$V->{interface}->{"${index}_display_name_title"} = "Display Name";

					# no log/diag msg as  this comes ONLY from nodeconf, it's not overriding anything
				}

				for my $speedname (qw(ifSpeed ifSpeedIn ifSpeedOut))
				{
					if ( $thisintfover->{$speedname} )
					{
						$target->{"nc_$speedname"} = $target->{$speedname};    # save
						$target->{$speedname} = $thisintfover->{$speedname};

						### 2012-10-09 keiths, fixing ifSpeed to be shortened when using nodeConf
						$V->{interface}{"${index}_${speedname}_value"} = NMISNG::Util::convertIfSpeed( $target->{$speedname} );
						NMISNG::Util::info("Manual update of $speedname by nodeConf");
					}
				}

				if ( $thisintfover->{setlimits} && $thisintfover->{setlimits} =~ /^(normal|strict|off)$/ )
				{
					$target->{setlimits} = $thisintfover->{setlimits};
				}
			}

			# set default for the speed  limit enforcement
			$target->{setlimits} ||= 'normal';

			# set default for collect, event and threshold: on, possibly overridden later
			$target->{collect}   = "true";
			$target->{event}     = "true";
			$target->{threshold} = "true";
			$target->{nocollect} = "Collecting: Collection Policy";
		  #
		  #Decide if the interface is one that we can do stats on or not based on Description and ifType and AdminStatus
		  # If the interface is admin down no statistics
			### 2012-03-14 keiths, collecting override based on interface description.
			if (    $qr_collect_ifAlias_gen
				and $target->{Description} =~ /$qr_collect_ifAlias_gen/i )
			{
				$target->{collect}   = "true";
				$target->{nocollect} = "Collecting: found $1 in Description";    # reason
			}
			elsif ( $qr_collect_ifDescr_gen
				and $target->{ifDescr} =~ /$qr_collect_ifDescr_gen/i )
			{
				$target->{collect}   = "true";
				$target->{nocollect} = "Collecting: found $1 in ifDescr";
			}
			elsif ( $target->{ifAdminStatus} =~ /down|testing|null/ )
			{
				$target->{collect}   = "false";
				$target->{event}     = "false";
				$target->{nocollect} = "ifAdminStatus eq down|testing|null";     # reason
				$target->{noevent}   = "ifAdminStatus eq down|testing|null";     # reason
			}
			elsif ( $target->{ifDescr} =~ /$qr_no_collect_ifDescr_gen/i )
			{
				$target->{collect}   = "false";
				$target->{nocollect} = "Not Collecting: found $1 in ifDescr";    # reason
			}
			elsif ( $target->{ifType} =~ /$qr_no_collect_ifType_gen/i )
			{
				$target->{collect}   = "false";
				$target->{nocollect} = "Not Collecting: found $1 in ifType";     # reason
			}
			elsif ( $target->{Description} =~ /$qr_no_collect_ifAlias_gen/i )
			{
				$target->{collect}   = "false";
				$target->{nocollect} = "Not Collecting: found $1 in Description";    # reason
			}
			elsif ( $target->{Description} eq "" and $noDescription eq 'true' )
			{
				$target->{collect}   = "false";
				$target->{nocollect} = "Not Collecting: no Description (ifAlias)";    # reason
			}
			elsif ( $target->{ifOperStatus} =~ /$qr_no_collect_ifOperStatus_gen/i )
			{
				$target->{collect}   = "false";
				$target->{nocollect} = "Not Collecting: found $1 in ifOperStatus";    # reason
			}

			# if the interface has been down for too many days to be in use now.
			elsif ( $target->{ifAdminStatus} =~ /up/
				and $target->{ifOperStatus} =~ /down/
				and ( $catchall_data->{sysUpTimeSec} - $target->{ifLastChangeSec} ) / 86400
				> $nocollect_interface_down_days )
			{
				$target->{collect} = "false";
				$target->{nocollect}
					= "Not Collecting: interface down for more than $nocollect_interface_down_days days";    # reason
			}

			# send events ?
			if ( $target->{Description} =~ /$qr_no_event_ifAlias_gen/i )
			{
				$target->{event}   = "false";
				$target->{noevent} = "found $1 in ifAlias";                                                  # reason
			}
			elsif ( $target->{ifType} =~ /$qr_no_event_ifType_gen/i )
			{
				$target->{event}   = "false";
				$target->{noevent} = "found $1 in ifType";                                                   # reason
			}
			elsif ( $target->{ifDescr} =~ /$qr_no_event_ifDescr_gen/i )
			{
				$target->{event}   = "false";
				$target->{noevent} = "found $1 in ifDescr";                                                  # reason
			}

			# convert interface name
			$target->{interface} = NMISNG::Util::convertIfName( $target->{ifDescr} );
			$target->{ifIndex}   = $index;

			# modify by node Config ?
			if ( ref( $override->{$ifDescr} ) eq "HASH" )
			{
				my $thisintfover = $override->{$ifDescr};

				if ( $thisintfover->{collect} and $thisintfover->{ifDescr} eq $target->{ifDescr} )
				{
					$target->{nc_collect} = $target->{collect};
					$target->{collect}    = $thisintfover->{collect};
					NMISNG::Util::info("Manual update of Collect by nodeConf");

					### 2014-04-28 keiths, fixing info for GUI
					if ( NMISNG::Util::getbool( $target->{collect}, "invert" ) )
					{
						$target->{nocollect} = "Not Collecting: Manual update by nodeConf";
					}
					else
					{
						$target->{nocollect} = "Collecting: Manual update by nodeConf";
					}
				}

				if ( $thisintfover->{event} and $thisintfover->{ifDescr} eq $target->{ifDescr} )
				{
					$target->{nc_event} = $target->{event};
					$target->{event}    = $thisintfover->{event};
					$target->{noevent}  = "Manual update by nodeConf"
						if ( NMISNG::Util::getbool( $target->{event}, "invert" ) );    # reason
					NMISNG::Util::info("Manual update of Event by nodeConf");
				}

				if ( $thisintfover->{threshold} and $thisintfover->{ifDescr} eq $target->{ifDescr} )
				{
					$target->{nc_threshold} = $target->{threshold};
					$target->{threshold}    = $thisintfover->{threshold};
					$target->{nothreshold}  = "Manual update by nodeConf"
						if ( NMISNG::Util::getbool( $target->{threshold}, "invert" ) );    # reason
					NMISNG::Util::info("Manual update of Threshold by nodeConf");
				}
			}

			# interface now up or down, check and set or clear outstanding event.
			if (    NMISNG::Util::getbool( $target->{collect} )
				and $target->{ifAdminStatus} =~ /up|ok/
				and $target->{ifOperStatus} !~ /up|ok|dormant/ )
			{
				if ( NMISNG::Util::getbool( $target->{event} ) )
				{
					Compat::NMIS::notify(
						sys     => $S,
						event   => "Interface Down",
						element => $target->{ifDescr},
						details => $target->{Description},
						context => {type => "interface"},
					);
				}
			}
			else
			{
				Compat::NMIS::checkEvent(
					sys     => $S,
					event   => "Interface Down",
					level   => "Normal",
					element => $target->{ifDescr},
					details => $target->{Description}
				);
			}



			# number of interfaces collected with collect and event on
			$intfCollect++ if ( NMISNG::Util::getbool( $target->{collect} )
				&& NMISNG::Util::getbool( $target->{event} ) );

			# save values only if all interfaces are updated
			if ( $intf_one eq '' )
			{
				$catchall_data->{intfTotal}   = $intfTotal;
				$catchall_data->{intfCollect} = $intfCollect;
			}

			# prepare values for web page
			$V->{interface}{"${index}_event_value"} = $target->{event};
			$V->{interface}{"${index}_event_title"} = 'Event on';

			$V->{interface}{"${index}_threshold_value"}
				= !NMISNG::Util::getbool( $NC->{node}{threshold} ) ? 'false' : $target->{threshold};
			$V->{interface}{"${index}_threshold_title"} = 'Threshold on';

			$V->{interface}{"${index}_collect_value"} = $target->{collect};
			$V->{interface}{"${index}_collect_title"} = 'Collect on';

			$V->{interface}{"${index}_nocollect_value"} = $target->{nocollect};
			$V->{interface}{"${index}_nocollect_title"} = 'Reason';

			# collect status
			if ( NMISNG::Util::getbool( $target->{collect} ) )
			{
				NMISNG::Util::info("$target->{ifDescr} ifIndex $index, collect=true");
			}
			else
			{
				NMISNG::Util::info("$target->{ifDescr} ifIndex $index, collect=false, $target->{nocollect}");

				# if  collect is of then disable event and threshold (clearly not applicable)
				$target->{threshold} = $V->{interface}{"${index}_threshold_value"} = 'false';
				$target->{event}     = $V->{interface}{"${index}_event_value"}     = 'false';
			}

			# get color depending of state
			# NMISNG - TODO: trying to get the color from something not in the db, problem, causing warning
			$V->{interface}{"${index}_ifAdminStatus_color"} = Compat::NMIS::getAdminColor( sys => $S, index => $index, data => $target );
			$V->{interface}{"${index}_ifOperStatus_color"} = Compat::NMIS::getOperColor( sys => $S, index => $index, data => $target );

			# index number of interface
			$V->{interface}{"${index}_ifIndex_value"} = $index;
			$V->{interface}{"${index}_ifIndex_title"} = 'ifIndex';

			# at this point every thing is ready for the rrd speed limit enforcement
			my $desiredlimit = $target->{setlimits};

			# write if inventory data now. the speed limit/checking code requires the entries to exist in order to correctly find them in parseString/etc


			# For now, create inventory at the very end
			# get the inventory object for this, path_keys required as we don't know what type it will be
			my $path = $nmisng_node->inventory_path( concept => 'interface', data => $target );
			if( ref($path) eq 'ARRAY')
			{
				my ( $inventory, $error_message ) = $nmisng_node->inventory(
					concept   => 'interface',
					data      => $target,
					path      => $path,
					create    => 1
				);
				$S->nmisng->log->error("Failed to create interface inventory, error:$error_message") && next if ( !$inventory );
				# regenerate the path, if this thing wasn't new the path may have changed, which is ok
				$inventory->path( recalculate => 1 );
				$inventory->description( $target->{Description} || $target->{ifDescr} );

				# historic is only set when the index/_id is in the db but not found in the device, we are looping
				# through things found on the device so it's not historic
				$inventory->historic(0);

				# if collect is off then this interface is disabled
				$inventory->enabled(1);
				if ( NMISNG::Util::getbool( $target->{collect}, "invert" ) )
				{
					$inventory->enabled(0);
				}
				# enable interfaces for viewing, no columns, someoneelse can define that
				# disable pkts, for now, no idea
				$inventory->data_info( subconcept => 'interface', enabled => 1 );
				$inventory->data_info( subconcept => 'pkts_hc', enabled => 0 );
				$inventory->data_info( subconcept => 'pkts', enabled => 0 );
				my ( $op, $error ) = $inventory->save();
				NMISNG::Util::info( "saved ".join(',', @$path)." op: $op");
				$nmisng->log->error( "Failed to save inventory:" . join( ",", @{$inventory->path} ) . " error:$error" )
					if ($error);
			}
			else
			{
				$nmisng->log->error("Failed to create path for inventory, error:$path");
			}

			# the following don't modify $target so no extra saving required

			# no limit or dud limit or dud speed or non-collected interface?
			if (   $desiredlimit
				&& $desiredlimit =~ /^(normal|strict|off)$/
				&& $target->{ifSpeed}
				&& NMISNG::Util::getbool( $target->{collect} ) )
			{
				NMISNG::Util::info(
					"performing rrd speed limit tuning for $ifDescr, limit enforcement: $desiredlimit, interface speed is "
						. NMISNG::Util::convertIfSpeed( $target->{ifSpeed} )
						. " ($target->{ifSpeed})" );

			# speed is in bits/sec, normal limit: 2*reported speed (in bytes), strict: exactly reported speed (in bytes)
				my $maxbytes
					= $desiredlimit eq "off"    ? "U"
					: $desiredlimit eq "normal" ? int( $target->{ifSpeed} / 4 )
					:                             int( $target->{ifSpeed} / 8 );
				my $maxpkts = $maxbytes eq "U" ? "U" : int( $maxbytes / 50 );    # this is a dodgy heuristic

				for (
					["interface", qr/(ifInOctets|ifHCInOctets|ifOutOctets|ifHCOutOctets)/],
					[   "pkts",
						qr/(ifInOctets|ifHCInOctets|ifOutOctets|ifHCOutOctets|ifInUcastPkts|ifInNUcastPkts|ifInDiscards|ifInErrors|ifOutUcastPkts|ifOutNUcastPkts|ifOutDiscards|ifOutErrors)/
					],
					[   "pkts_hc",
						qr/(ifInOctets|ifHCInOctets|ifOutOctets|ifHCOutOctets|ifInUcastPkts|ifInNUcastPkts|ifInDiscards|ifInErrors|ifOutUcastPkts|ifOutNUcastPkts|ifOutDiscards|ifOutErrors)/
					],
					)
				{
					my ( $datatype, $dsregex ) = @$_;

					# rrd file exists and readable?
					if ( -r ( my $rrdfile = $S->makeRRDname( graphtype => $datatype, index => $index ) ) )
					{
						my $fileinfo = RRDs::info($rrdfile);
						for my $matching ( grep /^ds\[.+\]\.max$/, keys %$fileinfo )
						{
							# only touch relevant and known datasets
							next if ( $matching !~ /($dsregex)/ );
							my $dsname = $1;

							my $curval = $fileinfo->{$matching};
							$curval = "U" if ( !defined $curval or $curval eq "" );

							# the pkts, discards, errors DS are packet based; the octets ones are bytes
							my $desiredval = $dsname =~ /octets/i ? $maxbytes : $maxpkts;

							if ( $curval ne $desiredval )
							{
								NMISNG::Util::info(
									"rrd section $datatype, ds $dsname, current limit $curval, desired limit $desiredval: adjusting limit"
								);
								RRDs::tune( $rrdfile, "--maximum", "$dsname:$desiredval" );
							}
							else
							{
								NMISNG::Util::info("rrd section $datatype, ds $dsname, current limit $curval is correct");
							}
						}
					}
				}
			}

		}

		NMISNG::Util::info("Finished");
	}
	elsif ( $catchall_data->{ifNumber} > $interface_max_number )
	{
		NMISNG::Util::info("Skipping, interface count $catchall_data->{ifNumber} exceeds configured maximum $interface_max_number");
	}
	else
	{
		NMISNG::Util::info("Skipping, interfaces not defined in Model");
	}

	return 1;
}    # end getIntfInfo

#=========================================================================================

# check and adjust/modify some values of interface
# args: sys object, index, iftype
# returns: nothing
sub checkIntfInfo
{
	my %args = @_;

	my $S          = $args{sys};
	my $index      = $args{index};
	my $ifTypeDefs = $args{iftype};

	my $target = $args{target};
	my $V      = $S->view;

	my $thisintf = $target;
	if ( $thisintf->{ifDescr} eq "" ) { $thisintf->{ifDescr} = "null"; }

	# remove bad chars from interface descriptions
	$thisintf->{ifDescr}     = NMISNG::Util::rmBadChars( $thisintf->{ifDescr} );
	$thisintf->{Description} = NMISNG::Util::rmBadChars( $thisintf->{Description} );

	# Try to set the ifType to be something meaningful!!!!
	if ( exists $ifTypeDefs->{$thisintf->{ifType}}{ifType} )
	{
		$thisintf->{ifType} = $ifTypeDefs->{$thisintf->{ifType}}{ifType};
	}

	# Just check if it is an Frame Relay sub-interface
	if ( ( $thisintf->{ifType} eq "frameRelay" and $thisintf->{ifDescr} =~ /\./ ) )
	{
		$thisintf->{ifType} = "frameRelay-subinterface";
	}
	$V->{interface}{"${index}_ifType_value"} = $thisintf->{ifType};

	# get 'ifHighSpeed' if 'ifSpeed' = 4,294,967,295 - refer RFC2863 HC interfaces.
	# ditto if ifspeed is zero
	if ( $thisintf->{ifSpeed} == 4294967295 or $thisintf->{ifSpeed} == 0 )
	{
		$thisintf->{ifSpeed} = $thisintf->{ifHighSpeed};
		$thisintf->{ifSpeed} *= 1000000;
	}

	# final fallback in case SNMP agent is DODGY
	$thisintf->{ifSpeed} ||= 1000000000;

	$V->{interface}{"${index}_ifSpeed_value"} = NMISNG::Util::convertIfSpeed( $thisintf->{ifSpeed} );

	# convert time integer to time string
	$V->{interface}{"${index}_ifLastChange_value"} = $thisintf->{ifLastChange}
		= NMISNG::Util::convUpTime( $thisintf->{ifLastChangeSec} = int( $thisintf->{ifLastChange} / 100 ) );

}    # end checkIntfInfo

# fixme: this function does not work for wmi-only nodes
sub checkPIX
{
	my %args = @_;
	my $S    = $args{sys};
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	if ( !$S->status->{snmp_enabled} )
	{
		NMISNG::Util::info("Not performing PIX Failover check for $S->{name}: SNMP not enabled for this node");
		return 1;
	}

	my $V    = $S->view;
	my $SNMP = $S->snmp;
	my $result;

	NMISNG::Util::dbg("Starting");

	# PIX failover test
	# table has six values
	# [0] primary.cfwHardwareInformation, [1] secondary.cfwHardwareInformation
	# [2] primary.HardwareStatusValue, [3] secondary.HardwareStatusValue
	# [4] primary.HardwareStatusDetail, [5] secondary.HardwareStatusDetail
	# if HardwareStatusDetail is blank ( ne 'Failover Off' ) then
	# HardwareStatusValue will have 'active' or 'standby'

	if ( $catchall_data->{nodeModel} eq "CiscoPIX" )
	{
		NMISNG::Util::dbg("checkPIX, Getting Cisco PIX Failover Status");
		if ($result = $SNMP->get(
				'cfwHardwareStatusValue.6',  'cfwHardwareStatusValue.7',
				'cfwHardwareStatusDetail.6', 'cfwHardwareStatusDetail.7'
			)
			)
		{
			$result = $SNMP->keys2name($result);    # convert oid in hash key to name

			if ( $result->{'cfwHardwareStatusDetail.6'} ne 'Failover Off' )
			{
				if ( $result->{'cfwHardwareStatusValue.6'} == 0 )
				{
					$result->{'cfwHardwareStatusValue.6'} = "Failover Off";
				}
				elsif ( $result->{'cfwHardwareStatusValue.6'} == 3 ) { $result->{'cfwHardwareStatusValue.6'} = "Down"; }
				elsif ( $result->{'cfwHardwareStatusValue.6'} == 9 )
				{
					$result->{'cfwHardwareStatusValue.6'} = "Active";
				}
				elsif ( $result->{'cfwHardwareStatusValue.6'} == 10 )
				{
					$result->{'cfwHardwareStatusValue.6'} = "Standby";
				}
				else { $result->{'cfwHardwareStatusValue.6'} = "Unknown"; }

				if ( $result->{'cfwHardwareStatusValue.7'} == 0 )
				{
					$result->{'cfwHardwareStatusValue.7'} = "Failover Off";
				}
				elsif ( $result->{'cfwHardwareStatusValue.7'} == 3 ) { $result->{'cfwHardwareStatusValue.7'} = "Down"; }
				elsif ( $result->{'cfwHardwareStatusValue.7'} == 9 )
				{
					$result->{'cfwHardwareStatusValue.7'} = "Active";
				}
				elsif ( $result->{'cfwHardwareStatusValue.7'} == 10 )
				{
					$result->{'cfwHardwareStatusValue.7'} = "Standby";
				}
				else { $result->{'cfwHardwareStatusValue.7'} = "Unknown"; }

				# fixme unclean access to internal structure
				# fixme also fails if we've switched to updating this node on the go!
				if ( !NMISNG::Util::getbool( $S->{update} ) )
				{
					if (   $result->{'cfwHardwareStatusValue.6'} ne $catchall_data->{pixPrimary}
						or $result->{'cfwHardwareStatusValue.7'} ne $catchall_data->{pixSecondary} )
					{
						NMISNG::Util::dbg("PIX failover occurred");

						# As this is not stateful, alarm not sent to state table in sub eventAdd
						Compat::NMIS::notify(
							sys     => $S,
							event   => "Node Failover",
							element => 'PIX',
							details =>
								"Primary now: $catchall_data->{pixPrimary}  Secondary now: $catchall_data->{pixSecondary}"
						);
					}
				}
				$catchall_data->{pixPrimary}   = $result->{'cfwHardwareStatusValue.6'};    # remember
				$catchall_data->{pixSecondary} = $result->{'cfwHardwareStatusValue.7'};

				$V->{system}{firewall_title} = "Failover Status";
				$V->{system}{firewall_value} = "Pri: $catchall_data->{pixPrimary} Sec: $catchall_data->{pixSecondary}";
				if (    $catchall_data->{pixPrimary} =~ /Failover Off|Active/i
					and $catchall_data->{pixSecondary} =~ /Failover Off|Standby/i )
				{
					$V->{system}{firewall_color} = "#00BB00";                           #normal
				}
				else
				{
					$V->{system}{firewall_color} = "#FFDD00";                           #warning

				}
			}
			else
			{
				$V->{system}{firewall_title} = "Failover Status";
				$V->{system}{firewall_value} = "Failover off";
			}
		}
	}
	NMISNG::Util::dbg("Finished");
	return 1;
}


# retrieve system health index data from snmp, done during update
# args: sys (object)
# returns: 1 if all present sections worked, 0 otherwise
# note: raises xyz down events if snmp or wmi are down
sub getSystemHealthInfo
{
	my %args = @_;
	my $S    = $args{sys};    # object

	my $V    = $S->view;
	my $SNMP = $S->snmp;
	my $M    = $S->mdl;           # node model table
	my $C    = NMISNG::Util::loadConfTable();
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	# create the node here for now, this should be passed in as a param in the future
	my $nmisng = $S->nmisng;
	my $nmisng_node = $S->nmisng_node;

	NMISNG::Util::info("Starting");
	NMISNG::Util::info("Get systemHealth Info of node $catchall_data->{name}, model $catchall_data->{nodeModel}");

	if ( ref( $M->{systemHealth} ) ne "HASH" )
	{
		NMISNG::Util::dbg("No class 'systemHealth' declared in Model.");
		return 0;
	}
	elsif ( !$S->status->{snmp_enabled} && !$S->status->{wmi_enabled} )
	{
		NMISNG::Util::logMsg("ERROR: cannot get systemHealth info, neither SNMP nor WMI enabled!");
		return 0;
	}

	# get the default (sub)sections from config, model can override
	my @healthSections = split(
		",",
		(   defined( $M->{systemHealth}{sections} )
			? $M->{systemHealth}{sections}
			: $C->{model_health_sections}
		)
	);
	for my $section (@healthSections)
	{
		# TODO:
		NMISNG::Util::TODO("fixme9 Does deleting all of the inventory for a section does not make sense, need to loop through and mark unused as historic!");

		next
			if ( !exists( $M->{systemHealth}->{sys}->{$section} ) ); # if the config provides list but the model doesn't

		my $thissection = $M->{systemHealth}->{sys}->{$section};

		# all systemhealth sections must be indexed by something
		# this holds the name, snmp or wmi
		my $index_var;

		# or if you want to use a raw oid instead: use 'index_oid' => '1.3.6.1.4.1.2021.13.15.1.1.1',
		my $index_snmp;

		# and for obscure SNMP Indexes a more generous snmp index regex can be given:
		# in the systemHealth section of the model 'index_regex' => '\.(\d+\.\d+\.\d+)$',
		# attention: FIRST capture group must return the index part
		my $index_regex = '\.(\d+)$';

		$index_var = $index_snmp = $thissection->{indexed};
		$index_regex = $thissection->{index_regex} if ( exists( $thissection->{index_regex} ) );
		$index_snmp  = $thissection->{index_oid}   if ( exists( $thissection->{index_oid} ) );
		my $header_info;

		if ( !defined($index_var) or $index_var eq '' )
		{
			NMISNG::Util::dbg("No index var found for $section, skipping");
			next;
		}

		# determine if this is an snmp- OR wmi-backed systemhealth section
		# combination of both cannot work, as there is only one index
		if ( exists( $thissection->{wmi} ) and exists( $thissection->{snmp} ) )
		{
			NMISNG::Util::logMsg("ERROR, systemhealth: section=$section cannot have both sources WMI and SNMP enabled!");
			NMISNG::Util::info("ERROR, systemhealth: section=$section cannot have both sources WMI and SNMP enabled!");
			next;    # fixme: or is this completely terminal for this model?
		}

		if ( exists( $thissection->{wmi} ) )
		{
			NMISNG::Util::info("systemhealth: section=$section, source WMI, index_var=$index_var");
			$header_info = NMISNG::Inventory::parse_model_subconcept_headers( $thissection, 'wmi' );

			my $wmiaccessor = $S->wmi;
			if ( !$wmiaccessor )
			{
				NMISNG::Util::info("skipping section $section: source WMI but node $S->{name} not configured for WMI");
				next;
			}

			# model broken if it says 'indexed by X' but doesn't have a query section for 'X'
			if ( !exists( $thissection->{wmi}->{$index_var} ) )
			{
				NMISNG::Util::logMsg("ERROR: Model section $section is missing declaration for index_var $index_var!");
				next;
			}

			my $wmisection   = $thissection->{wmi};          # the whole section, might contain more than just the index
			my $indexsection = $wmisection->{$index_var};    # the subsection for the index var

			# query can come from -common- or from the index var's own section
			my $query = (
				exists( $indexsection->{query} ) ? $indexsection->{query}
				: ( ref( $wmisection->{"-common-"} ) eq "HASH"
						&& exists( $wmisection->{"-common-"}->{query} ) ) ? $wmisection->{"-common-"}->{query}
				: undef
			);
			if ( !$query or !$indexsection->{field} )
			{
				NMISNG::Util::logMsg("ERROR: Model section $section is missing query or field for WMI variable  $index_var!");
				next;
			}

			# wmi gettable could give us both the indices and the data, but here we want only the different index values
			my ( $error, $fields, $meta ) = $wmiaccessor->gettable(
				wql    => $query,
				index  => $index_var,
				fields => [$index_var]
			);

			if ($error)
			{
				NMISNG::Util::logMsg("ERROR ($S->{name}) failed to get index table for systemHealth $section: $error");
				HandleNodeDown(
					sys     => $S,
					type    => "wmi",
					details => "failed to get index table for systemHealth $section: $error"
				);
				next;
			}

			# update historic setting in records
			my @active_indices = keys %$fields;
			$S->nmisng_node->bulk_update_inventory_historic( active_indices => \@active_indices, concept => $section );

			# fixme: meta might tell us that the indexing didn't work with the given field, if so we should bail out
			for my $indexvalue ( @active_indices )
			{
				NMISNG::Util::dbg("section=$section index=$index_var, found value=$indexvalue");

				# save the seen index value
				my $target = {$index_var => $indexvalue};

				# then get all data for this indexvalue
				# Inventory note: for now Sys will populate the nodeinfo section it cares about
				# afer successful load we'll delete it. in the future loadinfo should maybe be passed
				# the location we want the data to go
				if ($S->loadInfo(
						class   => 'systemHealth',
						section => $section,
						index   => $indexvalue,
						table   => $section,
						model   => $model,
						target  => $target
					)
					)
				{
					NMISNG::Util::info("section=$section index=$indexvalue read and stored");

					# $index_var is correct but the loading side in S->inventory doesn't know what the key will be in data
					# so use 'index' for now.
					# loadInfo always sets {index}
					# my $path_keys = [$index_var];
					my $path_keys = ['index'];
					my $path = $nmisng_node->inventory_path( concept => $section, data => $target, path_keys => $path_keys );
					my ( $inventory, $error_message ) = $nmisng_node->inventory(
						concept   => $section,
						data      => $target,
						path      => $path,
						path_keys => $path_keys,
						create    => 1
					);
					$nmisng->log->error("Failed to create inventory, error:$error_message") && next if ( !$inventory );
					# regenerate the path, if this thing wasn't new the path may have changed, which is ok
					$inventory->path( recalculate => 1 );
					$inventory->historic(0);
					$inventory->enabled(1);

					# set which columns should be displayed
					$inventory->data_info(
						subconcept => $section,
						enabled => 1,
						display_keys => $header_info
					);
					# the above will put data into inventory, so save
					my ( $op, $error ) = $inventory->save();
					NMISNG::Util::info( "saved ".join(',', @$path)." op: $op");
					$nmisng->log->error(
						"Failed to save inventory:" . join( ",", @{$inventory->path} ) . " error:$error" )
						if ($error);
				}
				else
				{
					my $error = $S->status->{wmi_error};
					NMISNG::Util::logMsg("ERROR ($S->{name}) failed to get table for systemHealth $section: $error");
					HandleNodeDown(
						sys     => $S,
						type    => "wmi",
						details => "failed to get table for systemHealth $section: $error"
					);
					next;
				}
			}
		}
		else
		{
			NMISNG::Util::info("systemHealth: section=$section, source SNMP, index_var=$index_var, index_snmp=$index_snmp");
			$header_info = NMISNG::Inventory::parse_model_subconcept_headers( $thissection, 'snmp' );
			my ( %healthIndexNum, $healthIndexTable );

			# first loop gets the index we want to use out of the oid
			# so we need to keep a map of index => target
			# potientially these two loops could be merged.
			my $targets = {};
			if ( $healthIndexTable = $SNMP->gettable($index_snmp) )
			{
				# NMISNG::Util::dbg("systemHealth: table is ".Dumper($healthIndexTable) );
				foreach my $oid ( oid_lex_sort( keys %{$healthIndexTable} ) )
				{
					my $index = $oid;
					if ( $oid =~ /$index_regex/ )
					{
						$index = $1;
					}
					$healthIndexNum{$index} = $index;
					NMISNG::Util::dbg("section=$section index=$index is found, value=$healthIndexTable->{$oid}");
					$targets->{$index}{$index_var} = $healthIndexTable->{$oid};
				}
			}
			else
			{
				if ( $SNMP->error =~ /is empty or does not exist/ )
				{
					NMISNG::Util::info( "SNMP Object Not Present ($S->{name}) on get systemHealth $section index table: "
							. $SNMP->error );
				}
				else
				{
					NMISNG::Util::logMsg( "ERROR ($S->{name}) on get systemHealth $section index table: " . $SNMP->error );
					HandleNodeDown(
						sys     => $S,
						type    => "snmp",
						details => "get systemHealth $section index table: " . $SNMP->error
					);
				}
			}

			# mark historic records
			my @active_indices = (sort keys %healthIndexNum);
			$S->nmisng_node->bulk_update_inventory_historic( active_indices => \@active_indices, concept => $section );

			# Loop to get information, will be stored in {info}{$section} table
			foreach my $index ( @active_indices )
			{
				my $target = $targets->{$index};
				# we pass loadInfo a hash to fill in, then put that into the inventory data
				if( $S->loadInfo(
						class   => 'systemHealth',
						section => $section,
						index   => $index,
						table   => $section,
						model   => $model,
						target  => $target
				))
				{
					NMISNG::Util::info("section=$section index=$index read and stored");

					# get the inventory object for this, path_keys required as we don't know what type it will be
					NMISNG::Util::TODO("Do we use index or the healthIndextTable value that the loop above grabbed?");

					# $index_var is correct but the loading side in S->inventory doesn't know what the key will be in data
					# so use 'index' for now.
					# loadInfo always sets {index}, which is potentially the oid part and not the value of the oid, eg. how fanStatus works

					my $path_keys = ['index'];
					my $path = $nmisng_node->inventory_path( concept => $section, data => $target, path_keys => $path_keys );

					# NOTE: systemHealth requires {index} => $index to be set, it
					my ( $inventory, $error_message ) = $nmisng_node->inventory(
						concept   => $section,
						data      => $target,
						path      => $path,
						path_keys => $path_keys,
						create    => 1
					);
					$nmisng->log->error("Failed to create inventory, error:$error_message") && next if ( !$inventory );
					# regenerate the path, if this thing wasn't new the path may have changed, which is ok
					$inventory->path( recalculate => 1 );
					$inventory->historic(0);
					$inventory->enabled(1);

					# set which columns should be displayed
					$inventory->data_info(
						subconcept => $section,
						enabled => 1,
						display_keys => $header_info
					);

					# the above will put data into inventory, so save
					my ( $op, $error ) = $inventory->save();
					NMISNG::Util::info( "saved ".join(',', @$path)." op: $op");
					$nmisng->log->error(
						"Failed to save inventory:" . join( ",", @{$inventory->path} ) . " error:$error" )
						if ($error);
				}
				else
				{
					my $error = $S->status->{snmp_error};
					NMISNG::Util::logMsg("ERROR ($S->{name}) on get systemHealth $section index $index: $error");
					HandleNodeDown(
						sys     => $S,
						type    => "snmp",
						details => "get systemHealth $section index $index: $error"
					);
				}
			}
		}
	}
	NMISNG::Util::info("Finished");
	return 1;
}

# retrieves system health rrd data, and updates relevant rrd database files
# args: sys (object)
# returns: 1 if all ok, 0 otherwise
sub getSystemHealthData
{
	my %args = @_;
	my $S    = $args{sys};    # object

	my $V  = $S->view;
	my $M  = $S->mdl;         # node model table

	my $C = NMISNG::Util::loadConfTable();

	# create the node here for now, this should be passed in as a param in the future
	my $nmisng = $S->nmisng;
	my $nmisng_node = $S->nmisng_node;
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	NMISNG::Util::info("Starting");
	NMISNG::Util::info("Get systemHealth Data of node $catchall_data->{name}, model $catchall_data->{nodeModel}");

	if ( !exists( $M->{systemHealth} ) )
	{
		NMISNG::Util::dbg("No class 'systemHealth' declared in Model");
		return 1;    # nothing there means all ok
	}

	# config sets default sections, model overrides
	my @healthSections = split( ",", defined( $M->{systemHealth}{sections} )
		? $M->{systemHealth}{sections}
		: $C->{model_health_sections} );

	for my $section (@healthSections)
	{
		my $ids = $nmisng_node->get_inventory_ids( concept => $section, filter => { enabled => 1, historic => 0 } );

		# node doesn't have info for this section, so no indices so no fetch,
		# may be no update yet or unsupported section for this model anyway
		# OR only sys section but no rrd (e.g. addresstable)
		next
			if ( @$ids < 1
			or !exists( $M->{systemHealth}->{rrd} )
			or ref( $M->{systemHealth}->{rrd}->{$section} ) ne "HASH" );

		my $thissection = $M->{systemHealth}{sys}{$section};
		my $index_var   = $thissection->{indexed};

		# that's instance index value
		foreach my $id (@$ids)
		{
			my ( $inventory, $error ) = $nmisng_node->inventory( _id => $id );
			$nmisng_node->nmisng->log->error("Failed to get inventory with id:$id, error:$error") && next if ( !$inventory );

			my $data = $inventory->data();

			# sanity check the data
			if (   ref($data) ne "HASH"
				or !keys %$data
				or !exists( $data->{index} ) )
			{
				my $index = $data->{index} // 'noindex';
				NMISNG::Util::logMsg(
					"ERROR invalid data for section $section and index $index, cannot collect systemHealth data for this index!"
				);
				NMISNG::Util::info(
					"ERROR invalid data for section $section and index $index, cannot collect systemHealth data for this index!"
				);

				# clean it up as well, it's utterly broken as it is.
				$inventory->delete();
				next;
			}

			# value should be in $index_var, loadInfo also puts it in {index} so fall back to that
			my $index = $data->{index};

			my $rrdData = $S->getData( class => 'systemHealth', section => $section, index => $index, debug => $model );
			my $howdiditgo = $S->status;

			my $anyerror = $howdiditgo->{error} || $howdiditgo->{snmp_error} || $howdiditgo->{wmi_error};

			# were there any errors?
			if ( !$anyerror && !$howdiditgo->{skipped} )
			{
				my $previous_pit = $inventory->get_newest_timed_data();
				my $count = 0;
				foreach my $sect ( keys %{$rrdData} )
				{
					my $D = $rrdData->{$sect}->{$index};

					# update retrieved values in node info, too, not just the rrd database
					for my $item ( keys %$D )
					{
						++$count;
						NMISNG::Util::dbg(      "updating node info $section $index $item: old "
								. $data->{$item}
								. " new $D->{$item}{value}" );
						$data->{$item} = $D->{$item}{value};
					}

					# RRD Database update and remember filename;
					# also feed in the section data for filename expansion
					my $db = $S->create_update_rrd( data   => $D,
																					type   => $sect,
																					index  => $index,
																					extras => $data,
																					inventory => $inventory );
					if ( !$db )
					{
						NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
					}
					else
					{
						# convert data into values we can use in pit (eg resolve counters)
						my $target = {};
						NMISNG::Inventory::parse_rrd_update_data( $D, $target, $previous_pit, $sect);
						# get stats
						my $period = getThresholdPeriod(subconcept => $sect);
						my $stats = Compat::NMIS::getSubconceptStats(sys => $S, inventory => $inventory,
																												 subconcept => $sect, start => $period, end => time);
						$stats //= {};
						my $error = $inventory->add_timed_data( data => $target, derived_data => $stats, subconcept => $sect,
																									time => $catchall_data->{last_poll}, delay_insert => 1 );
						NMISNG::Util::logMsg("ERROR: timed data adding for ". $inventory->concept ." failed: $error") if ($error);
					}
				}
				NMISNG::Util::info("section=$section index=$index read and stored $count values");
				# technically the path shouldn't change during collect so for now don't recalculate path
				# put the new values into the inventory and save
				$inventory->data($data);
				$inventory->save();
			}
			# this allows us to prevent adding data when it wasn't collected (but not an error)
			elsif( $howdiditgo->{skipped} ) {}
			else
			{
				NMISNG::Util::logMsg("ERROR ($catchall_data->{name}) on getSystemHealthData, $section, $index, $anyerror");
				NMISNG::Util::info("ERROR ($catchall_data->{name}) on getSystemHealthData, $section, $index, $anyerror");
				HandleNodeDown( sys => $S, type => "snmp", details => $howdiditgo->{snmp_error} )
					if ( $howdiditgo->{snmp_error} );
				HandleNodeDown( sys => $S, type => "wmi", details => $howdiditgo->{wmi_error} )
					if ( $howdiditgo->{wmi_error} );

				return 0;
			}
		}
	}
	NMISNG::Util::info("Finished");
	return 1;
}

# updates the node info and node view structures with all kinds of stuff
# this is run ONLY for collect type ops (and if runping succeeded, and if the node is marked for collect)
# fixme: what good is this as a function? details are lost, exit 1/0 is not really enough
#
# returns: 1 if node is up, and at least one source worked for retrieval; 0 if node is down/to be skipped etc.
sub updateNodeInfo
{
	my %args = @_;
	my $S    = $args{sys};
	my $V    = $S->view;
	my $RI   = $S->reach;
	my $NC   = $S->ndcfg;    # node config
	my $M    = $S->mdl;

	my $time_marker = $args{time_marker} || time;

	my $result;
	my $exit = 1;
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	NMISNG::Util::info("Starting Update Node Info, node $S->{name}");

	# clear the node reset indication from the last run
	$catchall_data->{node_was_reset} = 0;

	# save what we need now for check of this node
	my $sysObjectID  = $catchall_data->{sysObjectID};
	my $ifNumber     = $catchall_data->{ifNumber};
	my $sysUpTimeSec = $catchall_data->{sysUpTimeSec};
	my $sysUpTime    = $catchall_data->{sysUpTime};

	# this returns 0 iff none of the possible/configured sources worked, sets details
	my $loadsuccess = $S->loadInfo( class => 'system', model => $model, target => $catchall_data );

	# polling policy needs saving regardless of success/failure
	$catchall_data->{last_polling_policy} = $NC->{node}->{polling_policy} || 'default';

	# handle dead sources, raise appropriate events
	my $curstate = $S->status;
	for my $source (qw(snmp wmi))
	{

		if ($curstate->{"${source}_enabled"})
		{
			# ok if enabled and no errors
			if (!$curstate->{"${source}_error"} )
			{
				my $sourcename = uc($source);
				$RI->{"${source}result"} = 100;
				HandleNodeDown( sys => $S, type => $source, up => 1, details => "$sourcename ok" );

				# record a _successful_ collect for the different sources,
				# the collect now-or-later logic needs that, not just attempted at time x
				$catchall_data->{"last_poll_$source"} = $time_marker;

			}
			else
			{
				HandleNodeDown( sys => $S, type => $source, details => $curstate->{"${source}_error"} );
				$RI->{"${source}result"} = 0;
			}
		}
		# we don't care about nonenabled sources, sys won't touch them nor set errors, RI stays whatever it was
	}

	if ($loadsuccess)
	{
		# do some checks, and perform only an update-type op if they don't work out
		# however, ensure this is not attempted if snmp wasn't configured or didn't work anyway
		if (   $S->status->{snmp_enabled}
			&& !$S->status->{snmp_error}
			&& $sysObjectID ne $catchall_data->{sysObjectID} )
		{
			# fixme: who not a complete doUpdate?
			NMISNG::Util::logMsg("INFO ($catchall_data->{name}) Device type/model changed $sysObjectID now $catchall_data->{sysObjectID}");
			$exit = getNodeInfo( sys => $S );
			NMISNG::Util::info("Finished with exit=$exit");
			return $exit;
		}

		# if ifNumber has changed, then likely an interface has been added or removed.

		# a new control to minimise when interfaces are added,
		# if disabled {custom}{interface}{ifNumber} eq "false" then don't run getIntfInfo when intf changes
		my $doIfNumberCheck = (
			exists( $S->{mdl}->{custom} ) && exists( $S->{mdl}->{custom}->{interface} )    # do not autovivify
				&& !NMISNG::Util::getbool( $S->{mdl}->{custom}->{interface}->{ifNumber} )
		);

		if ( $doIfNumberCheck and $ifNumber != $catchall_data->{ifNumber} )
		{
			NMISNG::Util::logMsg(
				"INFO ($catchall_data->{name}) Number of interfaces changed from $ifNumber now $catchall_data->{ifNumber}");
			getIntfInfo( sys => $S );                                                      # get new interface table
		}

		my $interface_max_number = $C->{interface_max_number} ? $C->{interface_max_number} : 5000;
		if ( $ifNumber > $interface_max_number )
		{
			NMISNG::Util::info(
				"INFO ($catchall_data->{name}) has $ifNumber interfaces, no interface data will be collected, to collect interface data increase the configured interface_max_number $interface_max_number, we recommend to test thoroughly"
			);
		}

		# make a sysuptime from the newly loaded data for testing
		makesysuptime($S);

		if ( defined $catchall_data->{snmpUpTime} )
		{
			# add processing for SNMP Uptime- handle just like sysUpTime
			$catchall_data->{snmpUpTimeSec}   = int( $catchall_data->{snmpUpTime} / 100 );
			$catchall_data->{snmpUpTime}      = NMISNG::Util::convUpTime( $catchall_data->{snmpUpTimeSec} );
			$V->{system}{snmpUpTime_value} = $catchall_data->{snmpUpTime};
			$V->{system}{snmpUpTime_title} = 'SNMP Uptime';
		}

		NMISNG::Util::info("sysUpTime: Old=$sysUpTime New=$catchall_data->{sysUpTime}");
		if ( $catchall_data->{sysUpTimeSec} && $sysUpTimeSec > $catchall_data->{sysUpTimeSec} )
		{
			NMISNG::Util::info("NODE RESET: Old sysUpTime=$sysUpTimeSec New sysUpTime=$catchall_data->{sysUpTimeSec}");
			Compat::NMIS::notify(
				sys     => $S,
				event   => "Node Reset",
				element => "",
				details => "Old_sysUpTime=$sysUpTime New_sysUpTime=$catchall_data->{sysUpTime}",
				context => {type => "node"}
			);

			# now stash this info in the node info object, to ensure we insert one set of U's into the rrds
			# so that no spikes appear in the graphs
			$catchall_data->{node_was_reset} = 1;
		}

		$V->{system}{sysUpTime_value} = $catchall_data->{sysUpTime};
		$V->{system}{sysUpTime_title} = 'Uptime';

		$V->{system}{lastUpdate_value} = NMISNG::Util::returnDateStamp();
		$V->{system}{lastUpdate_title} = 'Last Update';
		# that's actually critical for other functions down the track
		$catchall_data->{last_poll}   = $time_marker;
		delete $catchall_data->{lastCollectPoll}; # replaced by last_poll

		# get and apply any nodeconf override if such exists for this node
		my $node = $catchall_data->{name};
		my ( $errmsg, $override ) = Compat::NMIS::get_nodeconf( node => $node )
			if ( Compat::NMIS::has_nodeconf( node => $node ) );
		NMISNG::Util::logMsg("ERROR $errmsg") if $errmsg;
		$override ||= {};

		# anything to override?
		if ( $override->{sysLocation} )
		{
			$catchall_data->{sysLocation} = $V->{system}{sysLocation_value} = $override->{sysLocation};
			NMISNG::Util::info("Manual update of sysLocation by nodeConf");
		}
		if ( $override->{sysContact} )
		{
			$catchall_data->{sysContact} = $V->{system}{sysContact_value} = $override->{sysContact};
			NMISNG::Util::info("Manual update of sysContact by nodeConf");
		}

		if ( exists($override->{nodeType}) )
		{
			$catchall_data->{nodeType} = $override->{nodeType};
		}

		checkPIX( sys => $S );    # check firewall if needed

		$V->{system}{status_value} = 'reachable';    # sort-of, at least one source worked
		$V->{system}{status_color} = '#0F0';

		# conditional on model section to ensure backwards compatibility with different Juniper values.
		checkNodeConfiguration( sys => $S )
			if ( exists( $M->{system}{sys}{nodeConfiguration} )
			or exists( $M->{system}{sys}{juniperConfiguration} ) );
	}
	else
	{
		$exit = 0;

		if ( NMISNG::Util::getbool( $NC->{node}{ping} ) )
		{
			# ping was ok but wmi and snmp were not
			$V->{system}{status_value} = 'degraded';
			$V->{system}{status_color} = '#FFFF00';
		}
		else
		{
			# ping was disabled, so sources wmi/snmp are the only thing that tells us about reachability
			# note: ping disabled != runping failed
			$V->{system}{status_value} = 'unreachable';
			$V->{system}{status_color} = 'red';
		}
	}

	# some model testing and debugging options.
	if ($model)
	{
		print
			"MODEL $S->{name}: nodedown=$catchall_data->{nodedown} sysUpTime=$catchall_data->{sysUpTime} sysObjectID=$catchall_data->{sysObjectID}\n";
	}

	NMISNG::Util::info("Finished with exit=$exit");
	return $exit;
}

# goes through the list of 'parked' alerts in sys, and creates up or down events where applicable
# sys::getvalues() populates the parked alerts section, this consumes them (but writes back
# into sys' info->status)
sub processAlerts
{
	my %args   = @_;
	my $S      = $args{S};
	my $alerts = $S->{alerts};

	foreach my $alert ( @{$alerts} )
	{
		NMISNG::Util::info(
			"Processing alert: event=Alert: $alert->{event}, level=$alert->{level}, element=$alert->{ds}, details=Test $alert->{test} evaluated with $alert->{value} was $alert->{test_result}"
		) if $alert->{test_result};

		NMISNG::Util::dbg( "Processing alert " . Dumper($alert), 4 );

		my $tresult      = $alert->{test_result} ? $alert->{level} : "Normal";
		my $statusResult = $tresult eq "Normal"  ? "ok"            : "error";

		my $details = "$alert->{type} evaluated with $alert->{value} $alert->{unit} as $tresult";
		if ( $alert->{test_result} )
		{
			Compat::NMIS::notify(
				sys     => $S,
				event   => "Alert: " . $alert->{event},
				level   => $alert->{level},
				element => $alert->{ds},                  # vital part of context, too
				details => $details,
				context => {
					type    => "alert",
					source  => $alert->{source},
					section => $alert->{section},
					name    => $alert->{alert},
					index   => $alert->{index},
				}
			);
		}
		else
		{
			Compat::NMIS::checkEvent(
				sys     => $S,
				event   => "Alert: " . $alert->{event},
				level   => $alert->{level},
				element => $alert->{ds},
				details => $details
			);
		}

		### save the Alert result into the Status thingy
		my $statusKey = "$alert->{event}--$alert->{ds}";
		$S->compat_nodeinfo->{status}->{$statusKey} = {
			method   => "Alert",
			type     => $alert->{type},
			property => $alert->{test},
			event    => $alert->{event},
			index    => undef,             #$args{index},
			level    => $tresult,
			status   => $statusResult,
			element  => $alert->{ds},
			value    => $alert->{value},
			updated  => time()
		};
	}
}

#=========================================================================================

# get node values by snmp and store in RRD and some values in reach table
# inventory for this is the catchall
sub getNodeData
{
	my %args = @_;
	my $S    = $args{sys};
	my $inventory = $S->inventory( concept => 'catchall' );
	my $catchall_data = $inventory->data_live();

	NMISNG::Util::info("Starting Node get data, node $S->{name}");

	my $rrdData    = $S->getData( class => 'system', model => $model );
	my $howdiditgo = $S->status;
	my $anyerror   = $howdiditgo->{error} || $howdiditgo->{snmp_error} || $howdiditgo->{wmi_error};

	if ( !$anyerror )
	{
		my $previous_pit = $inventory->get_newest_timed_data();

		processAlerts( S => $S );
		foreach my $sect ( keys %{$rrdData} )
		{
			my $D = $rrdData->{$sect};
			checkNodeHealth( sys => $S, data => $D ) if $sect eq "nodehealth";

			foreach my $ds ( keys %{$D} )
			{
				NMISNG::Util::dbg( "rrdData, section=$sect, ds=$ds, value=$D->{$ds}{value}, option=$D->{$ds}{option}", 2 );
			}
			my $db = $S->create_update_rrd( inventory => $inventory, data => $D, type => $sect );
			if ( !$db )
			{
				NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
			}
			else
			{
				my $target = {};
				NMISNG::Inventory::parse_rrd_update_data( $D, $target, $previous_pit, $sect );
				my $period = getThresholdPeriod( subconcept => $sect );
				my $stats = Compat::NMIS::getSubconceptStats(sys => $S, inventory => $inventory,
																										 subconcept => $sect, start => $period, end => time);
				$stats //= {};
				my $error = $inventory->add_timed_data( data => $target, derived_data => $stats, subconcept => $sect,
																								time => $catchall_data->{last_poll}, delay_insert => 1 );
				NMISNG::Util::logMsg("ERROR: timed data adding for ". $inventory->concept ." failed: $error") if ($error);
			}
		}
		# NO save on inventory because it's the catchall right now
	}
	elsif( $howdiditgo->{skipped} ) {}
	else
	{
		NMISNG::Util::logMsg("ERROR ($catchall_data->{name}) on getNodeData, $anyerror");
		HandleNodeDown( sys => $S, type => "snmp", details => $howdiditgo->{snmp_error} )
			if ( $howdiditgo->{snmp_error} );
		HandleNodeDown( sys => $S, type => "wmi", details => $howdiditgo->{wmi_error} ) if ( $howdiditgo->{wmi_error} );
		return 0;
	}

	NMISNG::Util::info("Finished");
	return 1;
}

#=========================================================================================

# copy/modify some health values collected by getNodeData
# nmisdev 13Oct2012 - check if hash key is present before testing value, else key will 'auto vivify', and cause DS errors
sub checkNodeHealth
{
	my %args = @_;
	my $S    = $args{sys};
	my $D    = $args{data};
	my $RI   = $S->reach;

	NMISNG::Util::info("Starting, node $S->{name}");

	# take care of negative values from 6509 MSCF
	if ( exists $D->{bufferElHit} and $D->{bufferElHit}{value} < 0 )
	{
		$D->{bufferElHit}{value} = sprintf( "%u", $D->{bufferElHit}{value} );
	}

	### 2012-12-13 keiths, fixed this so it would assign!
	### 2013-04-17 keiths, fixed an autovivification problem!
	if ( exists $D->{avgBusy5} or exists $D->{avgBusy1} )
	{
		$RI->{cpu} = ( $D->{avgBusy5}{value} ne "" ) ? $D->{avgBusy5}{value} : $D->{avgBusy1}{value};
	}
	if ( exists $D->{MemoryUsedPROC} )
	{
		$RI->{memused} = $D->{MemoryUsedPROC}{value};
	}
	if ( exists $D->{MemoryFreePROC} )
	{
		$RI->{memfree} = $D->{MemoryFreePROC}{value};
	}
	NMISNG::Util::info("Finished");
	return 1;
}    # end checkHealth

#=========================================================================================

# fixme: this function currently does not work for wmi-only nodes!
sub getIntfData
{
	my %args = @_;
	my $S    = $args{sys};

	if ( !$S->status->{snmp_enabled} )
	{
		NMISNG::Util::info("Not performing getIntfData for $S->{name}: SNMP not enabled for this node");
		return 1;
	}

	my $V    = $S->view;
	my $RI   = $S->reach;
	my $SNMP = $S->snmp;
	my $IFCACHE;

	my $C = NMISNG::Util::loadConfTable();

	# get any nodeconf overrides if such exists for this node
	my $nodename = $S->{name};
	my ( $errmsg, $override ) = Compat::NMIS::get_nodeconf( node => $nodename )
		if ( Compat::NMIS::has_nodeconf( node => $nodename ) );
	NMISNG::Util::logMsg("ERROR $errmsg") if $errmsg;
	$override ||= {};

	# load the node here for now, this should be passed in as a param in the future
	my $nmisng = $S->nmisng;
	my $nmisng_node = $S->nmisng_node;
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	my $createdone = "false";

	NMISNG::Util::info("Starting Interface get data, node $S->{name}");

	$RI->{intfUp} = $RI->{intfColUp} = 0;    # reset counters of interface Up and interface collected Up

	# find all id's that are needed for the first section of searching
	my $model_data = $nmisng_node->get_inventory_model(
		'concept' => 'interface',
		fields_hash => {
			'_id' => 1,
			'data.collect' => 1,
			'data.ifAdminStatus' => 1,
			'data.ifDescr' => 1,
			'data.ifIndex' => 1,
			'data.ifLastChange' => 1,
			'enabled' => 1,
			'historic' => 1
		}
	);

	my $data = $model_data->data();
	# create a map by ifindex so we can look them up easily, flatten _id into data to make things easier
	my %if_data_map = map
		{
			$_->{data}{_id} = $_->{_id};
			$_->{data}{enabled} = $_->{enabled};
			$_->{data}{historic} = $_->{historic};
			$_->{data}{ifIndex} => $_->{data}
		}
		(@$data);

	# default for ifAdminStatus-based detection is ON. only off if explicitely set to false.
	my ($ran_admin,$ran_change) = (0,0);
	my ( $ifAdminTable, $ifOperTable ) = ({},{});
	if (ref( $S->{mdl}->{custom} ) ne "HASH"    # don't autovivify
		or ref( $S->{mdl}{custom}->{interface} ) ne "HASH"
		or !NMISNG::Util::getbool( $S->{mdl}->{custom}->{interface}->{ifAdminStatus}, "invert" )
		)
	{
		# fixme: this cannot work for non-snmp nodes
		NMISNG::Util::info("Using ifAdminStatus and ifOperStatus for Interface Change Detection");

		if ( $ifAdminTable = $SNMP->getindex('ifAdminStatus') )
		{
			$ran_admin = 1;
			$ifOperTable = $SNMP->getindex('ifOperStatus');
			for my $index ( keys %{$ifAdminTable} )
			{
				NMISNG::Util::logMsg("INFO ($S->{name}) entry ifAdminStatus for index=$index not found in interface table")
					if( !exists $if_data_map{$index}->{ifAdminStatus} );

				if ( ( $ifAdminTable->{$index} == 1 and $if_data_map{$index}->{ifAdminStatus} ne 'up' )
					or ( $ifAdminTable->{$index} != 1 and $if_data_map{$index}->{ifAdminStatus} eq 'up' ) )
				{
					### NMISNG::Util::logMsg("INFO ($S->{name}) ifIndex=$index, Admin was $IF->{$index}{ifAdminStatus} now $ifAdminTable->{$index} (1=up) rebuild");
					getIntfInfo( sys => $S, index => $index );    # update this interface
				}

				# total number of interfaces up
				$RI->{intfUp}++
					if $ifOperTable->{$index} == 1
					and NMISNG::Util::getbool( $if_data_map{$index}{real} );
			}
		}
	}

	# so get the ifLastChange for each interface and see if it has changed, if it has then run an update.
	# if an interface is added this will find it to.
	# if it changes admin or oper state it will find it.
	# this can be enabled on a model by model basis is false by default.
	my $ifLastChangeTable = {};
	if (    ref( $S->{mdl}{custom} ) eq "HASH"
		and ref( $S->{mdl}{custom}{interface} ) eq "HASH"
		and NMISNG::Util::getbool( $S->{mdl}{custom}{interface}{ifLastChange} ) )
	{
		# fixme: this cannot work for non-snmp node
		NMISNG::Util::info("Using ifLastChange for Interface Change Detection");

		if ( $ifLastChangeTable = $SNMP->getindex('ifLastChange') )
		{
			$ran_change = 1;
			for my $index ( sort { $a <=> $b } ( keys %{$ifLastChangeTable} ) )
			{
				my $ifLastChangeSec = int( $ifLastChangeTable->{$index} / 100 );
				if( exists($if_data_map{$index}) && $ifLastChangeSec == $if_data_map{$index}->{ifLastChange} )
				{
					NMISNG::Util::info("$if_data_map{$index}->{ifDescr}: NO Change ifIndex=$index ifLastChangeSec=$ifLastChangeSec");
				}
				else
				{
					NMISNG::Util::info("New Interface: ifIndex=$index ifLastChangeSec=$ifLastChangeSec") if( !exists($if_data_map{$index}) );
					NMISNG::Util::info("$if_data_map{$index}->{ifDescr}: Changed ifLastChangeSec=$ifLastChangeSec, was=$if_data_map{$index}->{ifLastChangeSec}")
						if($ifLastChangeSec != $if_data_map{$index}->{ifLastChangeSec}); # don't care about vivify here
					getIntfInfo( sys => $S, index => $index );    # add/update this interface
					# $IF->{$index}{ifLastChangeSec} = $ifLastChangeSec; # the getIntfInfo update should do this for us
				}
			}
		}
	}

	# This used to be in the ifLastChange if statement, it's been taken out and now looks at both last change and admintable
	# check for deleted interfaces, which exist in our inventory but are not reported by the device
	if( $ran_change || $ran_admin )
	{
		# build a list of all active indices
		my %active_index_map = ();
		map { $active_index_map{$_} = 1 } (keys %$ifLastChangeTable);
		map { $active_index_map{$_} = 1 } (keys %$ifAdminTable);
		my @active_indices = keys %active_index_map;
		# this will update all historic settings to be correct
		my $result = $S->nmisng_node->bulk_update_inventory_historic( active_indices => \@active_indices, concept => 'interface' );
		NMISNG::Util::dbg("Interfaces marked historic:$result->{marked_historic}, matched_historic:$result->{matched_historic},".
			"marked marked_nothistoric:$result->{marked_nothistoric}, matched_nothistoric:$result->{matched_nothistoric}");
		NMISNG::Util::logMsg("INFO ($S->{name}) marked historic:$result->{marked_historic}, matched_historic:$result->{matched_historic},".
			"marked marked_nothistoric:$result->{marked_nothistoric}, matched_nothistoric:$result->{matched_nothistoric}");    # test info

		# NOTE: this info is nice, can we have bulk_update_inventory_historic do something like it?
		# NMISNG::Util::info("$data->{ifDescr}: Interface Removed ifIndex=$index");
	}

	# grab the list of interfaces again, now that the list has possibly been updated
	# (could track the changes above and only do it if necessary)
	# this could also query for ifDescr being the value we want instead of doing the if below
	my $ids = $S->nmisng_node->get_inventory_ids( concept => 'interface', filter => { enabled => 1, historic => 0 } );
	NMISNG::Util::info("Processing Interface Table");
	foreach my $id ( sort @$ids )
	{
		my ($inventory,$error_message) = $nmisng_node->inventory( _id =>  $id );
		$nmisng->log->error("Failed to get interface inventory, _id:$id, error_message:$error_message") && next if(!$inventory);
		# replace minimal data with all data known
		my $inventory_data = $inventory->data();
		my $index = $inventory_data->{ifIndex};
		my $previous_pit = $inventory->get_newest_timed_data();

		# only collect on interfaces that are defined, with collection turned on globally,
		# also don't bother with ones without ifdescr
		if ( !defined( $inventory_data->{ifDescr} )	or $inventory_data->{ifDescr} eq "" )
		{
			NMISNG::Util::dbg("NOT Collected: $if_data_map{$index}->{ifDescr}: ifIndex=$if_data_map{$index}->{ifIndex}, OperStatus=$if_data_map{$index}->{ifOperStatus}, ifAdminStatus=$if_data_map{$index}->{ifAdminStatus}, Interface Collect=$if_data_map{$index}->{collect}"
			);
			next;
		}

		NMISNG::Util::info(
			"$inventory_data->{ifDescr}: ifIndex=$inventory_data->{ifIndex}, was => OperStatus=$inventory_data->{ifOperStatus}, ifAdminStatus=$inventory_data->{ifAdminStatus}, Collect=$inventory_data->{collect}"
		);

		NMISNG::Util::dbg("collect interface index=$index");

		# this is safe from using {info}{interface}, uses graphtype data a lot
		my $rrdData    = $S->getData( class => 'interface', index => $index, model => $model );
		my $howdiditgo = $S->status;
		my $anyerror   = $howdiditgo->{error} || $howdiditgo->{snmp_error} || $howdiditgo->{wmi_error};

		# were there any errors?
		if ( !$anyerror && !$howdiditgo->{skipped} )
		{
			processAlerts( S => $S );
			foreach my $sect ( keys %{$rrdData} )
			{
				my $D = $rrdData->{$sect}{$index};

				# if HC exists then copy values
				if ( exists $D->{ifHCInOctets} )
				{
					NMISNG::Util::dbg("processing HC counters");
					for ( ["ifHCInOctets", "ifInOctets"], ["ifHCOutOctets", "ifOutOctets"] )
					{
						my ( $source, $dest ) = @$_;

						if ( $D->{$source}->{value} =~ /^\d+$/ )
						{
							$D->{$dest}->{value}  = $D->{$source}->{value};
							$D->{$dest}->{option} = $D->{$source}->{option};
						}
						delete $D->{$source};
					}
				}

				# ...and copy these over as well
				if ( $sect eq 'pkts' or $sect eq 'pkts_hc' )
				{
					my $debugdone = 0;

					for (
						["ifHCInUcastPkts",  "ifInUcastPkts"],
						["ifHCOutUcastPkts", "ifOutUcastPkts"],
						["ifHCInMcastPkts",  "ifInMcastPkts"],
						["ifHCOutMcastPkts", "ifOutMcastPkts"],
						["ifHCInBcastPkts",  "ifInBcastPkts"],
						["ifHCOutBcastPkts", "ifOutBcastPkts"],
						)
					{
						my ( $source, $dest ) = @$_;

						if ( $D->{$source}->{value} =~ /^\d+$/ )
						{
							NMISNG::Util::dbg("process HC counters of $sect") if ( !$debugdone++ );
							$D->{$dest}->{value}  = $D->{$source}->{value};
							$D->{$dest}->{option} = $D->{$source}->{option};
						}
						delete $D->{$source};
					}
				}

				if ( $sect eq 'interface' )
				{
					$D->{ifDescr}{value} = NMISNG::Util::rmBadChars( $D->{ifDescr}{value} );

					# Cache any data for use later.
					$IFCACHE->{$index}{ifAdminStatus} = $D->{ifAdminStatus}{value};
					$IFCACHE->{$index}{ifOperStatus}  = $D->{ifOperStatus}{value};

					if ( $D->{ifInOctets}{value} ne "" and $D->{ifOutOctets}{value} ne "" )
					{
						if ( defined $S->{mdl}{custom}{interface}{ifAdminStatus}
							and not NMISNG::Util::getbool( $S->{mdl}{custom}{interface}{ifAdminStatus} ) )
						{
							### 2014-03-14 keiths, special handling for manual interface discovery which does not use getIntfInfo.
							# interface now up or down, check and set or clear outstanding event.
							NMISNG::Util::dbg("handling up/down admin=$D->{ifAdminStatus}{value}, oper=$D->{ifOperStatus}{value} was admin=$if_data_map{$index}->{ifAdminStatus}, oper=$if_data_map{$index}->{ifOperStatus}"
							);
							$inventory_data->{ifAdminStatus} = $D->{ifAdminStatus}{value};
							$inventory_data->{ifOperStatus}  = $D->{ifOperStatus}{value};

							if (  $inventory_data->{ifAdminStatus} =~ /up|ok/
								and $inventory_data->{ifOperStatus} !~ /up|ok|dormant/ )
							{
								if ( NMISNG::Util::getbool( $inventory_data->{event} ) )
								{
									Compat::NMIS::notify(
										sys     => $S,
										event   => "Interface Down",
										element => $inventory_data->{ifDescr},
										details => $inventory_data->{Description},
										context => {type => "interface"}
									);
								}
							}
							else
							{
								Compat::NMIS::checkEvent(
									sys     => $S,
									event   => "Interface Down",
									level   => "Normal",
									element => $inventory_data->{ifDescr},
									details => $inventory_data->{Description}
								);
							}
						}
						else
						{
							NMISNG::Util::dbg("status now admin=$D->{ifAdminStatus}{value}, oper=$D->{ifOperStatus}{value} was admin=$if_data_map{$index}->{ifAdminStatus}, oper=$if_data_map{$index}->{ifOperStatus}"
							);
							if ( $D->{ifOperStatus}{value} eq 'down' )
							{
								if ( $inventory_data->{ifOperStatus} =~ /up|ok/ )
								{
									# going down
									getIntfInfo( sys => $S, index => $index );    # update this interface
								}
							}

							# must be up
							else
							{
								# Check if the status changed
								if ( $inventory_data->{ifOperStatus} !~ /up|ok|dormant/ )
								{
									# going up
									getIntfInfo( sys => $S, index => $index );    # update this interface
								}
							}
						}

						# If new ifDescr is different from old ifDescr rebuild interface info table
						# check if nodeConf modified this inteface
						my $node    = $S->{name};
						my $ifDescr = $inventory_data->{ifDescr};

						# nodeconf override for the ifDescr?
						my $have_overridden_ifdescr;
						$have_overridden_ifdescr = 1
							if ( ref( $override->{$ifDescr} ) eq "HASH"
							and $override->{$ifDescr}->{ifDescr} );

						if (   !$have_overridden_ifdescr
							and $D->{ifDescr}{value} ne ''
							and $D->{ifDescr}{value} ne $inventory_data->{ifDescr} )
						{
							# Reload the interface config won't get that one right but should get the next one right
							NMISNG::Util::logMsg(
								"INFO ($S->{name}) ifIndex=$index - ifDescr has changed - old=$inventory_data->{ifDescr} new=$D->{ifDescr}{value} - updating Interface Table"
							);
							getIntfInfo( sys => $S, index => $index );    # update this interface
						}

						delete $D->{ifDescr};                             # dont store in rrd
						delete $D->{ifAdminStatus};

						if ( exists $D->{ifLastChange}{value} )
						{
							# convert time integer to time string
							$V->{interface}{"${index}_ifLastChange_value"} = $inventory_data->{ifLastChange}
								= NMISNG::Util::convUpTime( $inventory_data->{ifLastChangeSec} = int( $D->{ifLastChange}{value} / 100 ) );
							NMISNG::Util::dbg("last change time=$inventory_data->{ifLastChange}, timesec=$inventory_data->{ifLastChangeSec}");
						}
						delete $D->{ifLastChange};

						my $operStatus;

						# Calculate Operational Status
						$operStatus = ( $D->{ifOperStatus}{value} =~ /up|ok|dormant/ ) ? 100 : 0;
						$D->{ifOperStatus}{value} = $operStatus;    # store real value in rrd

						# While updating start calculating the total availability of the node, depends on events set
						my $opstatus = NMISNG::Util::getbool( $inventory_data->{event} ) ? $operStatus : 100;
						$RI->{operStatus} = $RI->{operStatus} + $opstatus;
						$RI->{operCount}  = $RI->{operCount} + 1;

						# count total number of collected interfaces up ( if events are set on)
						$RI->{intfColUp} += $operStatus / 100
							if NMISNG::Util::getbool( $inventory_data->{event} );
					}
					else
					{
						NMISNG::Util::logMsg("ERROR ($S->{name}) ifIndex=$index, no values for ifInOctets and ifOutOctets received");
					}
				}

				if ( $C->{debug} )
				{
					foreach my $ds ( keys %{$D} )
					{
						NMISNG::Util::dbg( "rrdData section $sect, ds $ds, value=$D->{$ds}{value}, option=$D->{$ds}{option}", 2 );
					}
				}

				# RRD Database update and remember filename
				NMISNG::Util::info( "updateRRD type$sect index=$index", 2 );
				my $db = $S->create_update_rrd( data => $D, type => $sect, index => $index, inventory => $inventory );
				if ( !$db )
				{
					NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
				}
				else
				{
					# convert data into values we can use in pit (eg resolve counters)
					my $target = {};
					NMISNG::Inventory::parse_rrd_update_data( $D, $target, $previous_pit, $sect );
					my $period = getThresholdPeriod( subconcept => $sect );
					my $stats = Compat::NMIS::getSubconceptStats(sys => $S, inventory => $inventory,
																											 subconcept => $sect, start => $period, end => time);
					# add data and stats
					$stats //= {};
					my $error = $inventory->add_timed_data( data => $target, derived_data => $stats, subconcept => $sect,
																									time => $catchall_data->{last_poll}, delay_insert => 1 );
					NMISNG::Util::logMsg("ERROR: timed data adding for ". $inventory->concept ." failed: $error") if ($error);
				}
			}

			# can't reu-se stats here because these run on default 6h, normal stats run on 15m
			my $period = $C->{interface_util_period} || "-6 hours";    # bsts plus backwards compat
			my $interface_util_stats = Compat::NMIS::getSubconceptStats(sys => $S,
																																	inventory => $inventory,
																																	subconcept => 'interface',
																																	start => $period, end => time);

			$V->{interface}{"${index}_operAvail_value"} = $interface_util_stats->{availability};
			$V->{interface}{"${index}_totalUtil_value"} = $interface_util_stats->{totalUtil};
			$V->{interface}{"${index}_operAvail_color"} = Compat::NMIS::colorHighGood( $interface_util_stats->{availability} );
			$V->{interface}{"${index}_totalUtil_color"} = Compat::NMIS::colorLowGood( $interface_util_stats->{totalUtil} );

			if ( defined $S->{mdl}{custom}{interface}{ifAdminStatus}
				and NMISNG::Util::getbool( $S->{mdl}{custom}{interface}{ifAdminStatus}, "invert" ) )
			{
				NMISNG::Util::dbg("Updating view with ifAdminStatus=$IFCACHE->{$index}{ifAdminStatus} and ifOperStatus=$IFCACHE->{$index}{ifOperStatus}"
				);
				$V->{interface}{"${index}_ifAdminStatus_color"} = Compat::NMIS::getAdminColor(
					collect       => $inventory_data->{collect},
					ifAdminStatus => $IFCACHE->{$index}{ifAdminStatus},
					ifOperStatus  => $IFCACHE->{$index}{ifOperStatus}
				);
				$V->{interface}{"${index}_ifOperStatus_color"} = Compat::NMIS::getOperColor(
					collect       => $inventory_data->{collect},
					ifAdminStatus => $IFCACHE->{$index}{ifAdminStatus},
					ifOperStatus  => $IFCACHE->{$index}{ifOperStatus}
				);
				$V->{interface}{"${index}_ifAdminStatus_value"} = $IFCACHE->{$index}{ifAdminStatus};
				$V->{interface}{"${index}_ifOperStatus_value"}  = $IFCACHE->{$index}{ifOperStatus};
			}

			### 2012-08-14 keiths, logic here to verify an event exists and the interface is up.
			### this was causing events to be cleared when interfaces were collect true, oper=down, admin=up
			if ( Compat::NMIS::eventExist( $node, "Interface Down", $inventory_data->{ifDescr} )
				and $inventory_data->{ifOperStatus} =~ /up|ok|dormant/ )
			{
				Compat::NMIS::checkEvent(
					sys     => $S,
					event   => "Interface Down",
					level   => "Normal",
					element => $inventory_data->{ifDescr},
					details => $inventory_data->{Description}
				);
			}
		}
		elsif( $howdiditgo->{skipped} ) {}
		else
		{
			NMISNG::Util::logMsg("ERROR ($S->{name}) on getIntfData of interface=$index, $anyerror");

			$V->{interface}{"${index}_operAvail_value"} = 'N/A';
			$V->{interface}{"${index}_totalUtil_value"} = 'N/A';

			# interface problems but no usable data, don't make an event
			if ( NMISNG::Util::getbool( $inventory_data->{event} ) )
			{
				NMISNG::Util::logMsg(
					"ERROR: Interface SNMP Data: ifAdminStatus=$inventory_data->{ifAdminStatus} ifOperStatus=$inventory_data->{ifOperStatus} enabled=".$inventory->enabled()
				);
			}
		}

		# header info of web page
		$V->{interface}{"${index}_operAvail_title"} = 'Intf. Avail.';
		$V->{interface}{"${index}_totalUtil_title"} = $C->{interface_util_label} || 'Util. 6hrs';    # backwards compat

		# check escalation if event is on
		if ( NMISNG::Util::getbool( $inventory_data->{event} ) )
		{
			my $escalate = 'none';
			if ( my $event_exist = Compat::NMIS::eventExist( $S->{node}, "Interface Down", $inventory_data->{ifDescr} ) )
			{
				my $erec = Compat::NMIS::eventLoad( filename => $event_exist );
				$escalate = $erec->{escalate} if ( $erec and defined( $erec->{escalate} ) );
			}
			$V->{interface}{"${index}_escalate_title"} = 'Esc.';
			$V->{interface}{"${index}_escalate_value"} = $escalate;
		}
		# don't recalculate path, that should happen in update, any place where we find
		# the interface has changed enough runs update code anyway. I believe not doing this is correct
		$inventory->data( $inventory_data );
		$inventory->save();
	}
	NMISNG::Util::info("Finished");
}

### Class Based Qos handling
# this wrapper function performs both type=update and type=collect ops
# args: sys, update;
# returns: 1
sub getCBQoS
{
	my %args = @_;
	my ($S,$isupdate)    = @args{"sys","update"};

	my $NC = $S->ndcfg;

	if ( $NC->{node}{cbqos} !~ /^(true|input|output|both)$/ )
	{
		NMISNG::Util::info("no CBQoS collecting ($NC->{node}{cbqos}) for node $S->{name}");
		return 1;
	}

	NMISNG::Util::info("Starting for node $S->{name}");

	if ($isupdate)
	{
		getCBQoSwalk( sys => $S );    # get indexes
	}
	elsif ( !getCBQoSdata( sys => $S ) )
	{
		getCBQoSwalk( sys => $S );    # (re)get indexes
		getCBQoSdata( sys => $S );    # and reget data
	}

	NMISNG::Util::info("Finished");
	return 1;
}

# this function performs a collect-type operation for cbqos
# note that while this function could theoretically work with wmi,
# the priming/update function getCBQoSwalk doesn't.
# returns: 1 if successful, 0 otherwise
sub getCBQoSdata
{
	my (%args)  = @_;
	my $S     = $args{sys};
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	my $happy;
	foreach my $direction ( "in", "out" )
	{
		my $concept = "cbqos-$direction";
		my $ids = $S->nmisng_node->get_inventory_ids(concept => $concept,
																								 filter => { enabled => 1, historic => 0 });

		# oke, we have get now the PolicyIndex and ObjectsIndex directly
		foreach my $id ( @$ids )
		{
			my ($inventory,$error_message) = $S->nmisng_node->inventory( _id => $id );
			$S->nmisng->log->error("Failed to get inventory for id:$id, concept:$concept, error_message:$error_message")
					&& next if(!$inventory);

			my $data = $inventory->data();
			# for now ifIndex is stored in the index attribute
			my $intf = $data->{index};
			my $CB = $data;
			my $previous_pit = $inventory->get_newest_timed_data();

			next if ( !exists $CB->{'PolicyMap'}{'Name'} );

			# check if Policymap name contains no collect info
			if ( $CB->{'PolicyMap'}{'Name'} =~ /$S->{mdl}{system}{cbqos}{nocollect}/i )
			{
				NMISNG::Util::dbg("no collect for interface $intf $direction ($CB->{'Interface'}{'Descr'}) by control ($S->{mdl}{system}{cbqos}{nocollect}) at Policymap $CB->{'PolicyMap'}{'Name'}"
				);
				next;
			}

			++$happy;

			my $PIndex = $CB->{'PolicyMap'}{'Index'};
			foreach my $key ( keys %{$CB->{'ClassMap'}} )
			{
				my $CMName = $CB->{'ClassMap'}{$key}{'Name'};
				my $OIndex = $CB->{'ClassMap'}{$key}{'Index'};
				NMISNG::Util::info("Interface $intf, ClassMap $CMName, PolicyIndex $PIndex, ObjectsIndex $OIndex");
				my $subconcept = $CMName;

				# get the number of bytes/packets transfered and dropped
				my $port = "$PIndex.$OIndex";

				my $rrdData
					= $S->getData( class => $concept, index => $intf, port => $port, model => $model );
				my $howdiditgo = $S->status;
				my $anyerror = $howdiditgo->{error} || $howdiditgo->{snmp_error} || $howdiditgo->{wmi_error};

				# were there any errors?
				if ( !$anyerror )
				{
					processAlerts( S => $S );
					my $D = $rrdData->{$concept}{$intf};

					if ( $D->{'PrePolicyByte'} eq "noSuchInstance" )
					{
						NMISNG::Util::logMsg("ERROR mismatch of indexes in getCBQoSdata, run walk");
						return;
					}

					# oke, store the data
					NMISNG::Util::dbg("bytes transfered $D->{'PrePolicyByte'}{value}, bytes dropped $D->{'DropByte'}{value}");
					NMISNG::Util::dbg("packets transfered $D->{'PrePolicyPkt'}{value}, packets dropped $D->{'DropPkt'}{value}");
					NMISNG::Util::dbg("packets dropped no buffer $D->{'NoBufDropPkt'}{value}");


					# update RRD, rrd file info comes from inventory,
					# storage/subconcept: class name == subconcept
					my $db = $S->create_update_rrd( data  => $D,
																					type  => $CMName, # subconcept
#																					index => $intf,		# not needed
#																					item  => $CMName, # not needed
																					inventory => $inventory );
					if ( !$db )
					{
						NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
					}
					else
					{
						my $target = {};
						NMISNG::Inventory::parse_rrd_update_data( $D, $target, $previous_pit, $CMName );
						# get stats, subconcept here is too specific, so use concept name, which is what
						#  stats expects anyway
						my $period = getThresholdPeriod( subconcept => $concept );
						# subconcept is completely variable, so we must tell the system where to find the stats
						my $stats = Compat::NMIS::getSubconceptStats( sys => $S, inventory => $inventory, subconcept => $CMName,
																													stats_section => $concept, start => $period, end => time );
						$stats //= {};
						my $error = $inventory->add_timed_data( data => $target, derived_data => $stats, subconcept => $CMName,
																										time => $catchall_data->{last_poll}, delay_insert => 1 );
						NMISNG::Util::logMsg("ERROR: timed data adding for ". $inventory->concept ." failed: $error") if ($error);
					}
				}
				else
				{
					NMISNG::Util::logMsg("ERROR ($S->{name}) on getCBQoSdata, $anyerror");
					HandleNodeDown( sys => $S, type => "snmp", details => $howdiditgo->{snmp_error} )
						if ( $howdiditgo->{snmp_error} );
					HandleNodeDown( sys => $S, type => "wmi", details => $howdiditgo->{wmi_error} )
						if ( $howdiditgo->{wmi_error} );

					return 0;
				}
			}
			# saving is required becuase create_update_rrd can change inventory, setting data not done because
			# it's not chagned
			$inventory->save();
		}
	}
	return $happy? 1 : 0;
}

# collect cbqos overview data from snmp, for update operation
# this is expected to run AFTER getintfinfo (because that's where overrides are transferred into NI)
# fixme: this function does not work for wmi-only nodes
# args: sys
# returns: 1 if ok
sub getCBQoSwalk
{
	my (%args) = @_;
	my $S    = $args{sys};

	if ( !$S->status->{snmp_enabled} )
	{
		NMISNG::Util::info("Not performing getCBQoSwalk for $S->{name}: SNMP not enabled for this node");
		return 1;
	}

	my $NC   = $S->ndcfg;
	my $SNMP = $S->snmp;

	NMISNG::Util::info("start table scanning");

	# get the qos interface indexes and objects from the snmp table
	if ( my $ifIndexTable = $SNMP->getindex('cbQosIfIndex') )
	{
		# grab all the interface data required to run this function
		# no writing back to the IF information is done so plain models
		# are good
		my $nmisng = $S->nmisng;
		my $nmisng_node = $S->nmisng_node;

		my $model_data = $nmisng_node->get_inventory_model(
			'concept' => 'interface',
			fields_hash => {
				'_id' => 1,
				'data.collect' => 1,
				'data.ifAdminStatus' => 1,
				'data.ifDescr' => 1,
				'data.ifIndex' => 1,
				'data.ifSpeed' => 1,
				'data.ifSpeedIn' => 1,
				'data.ifSpeedOut' => 1,
				'data.setlimits' => 1,
				'enabled' => 1,
				'historic' => 1
			}
				);

		# create a map by ifindex so we can look them up easily, flatten _id into data to make things easier
		my $data = $model_data->data();
		my %if_data_map = map
			{
				$_->{data}{_id} = $_->{_id};
				$_->{data}{enabled} = $_->{enabled};
				$_->{data}{historic} = $_->{historic};
				$_->{data}{ifIndex} => $_->{data};
			}
			(@$data);

		my %cbQosTable;
		foreach my $PIndex ( keys %{$ifIndexTable} )
		{
			my $intf = $ifIndexTable->{$PIndex};    # the interface number from the snmp qos table
			NMISNG::Util::info("CBQoS, scan interface $intf");
			$nmisng->log->warn("CBQoS ifIndex $intf found which is not in inventory") && next
				if( !defined($if_data_map{$intf}) );
			my $if_data = $if_data_map{$intf};

			# skip CBQoS if interface has collection disabled
			if ( $if_data->{historic} || !$if_data->{enabled} )
			{
				NMISNG::Util::dbg("Skipping CBQoS, No collect on interface $if_data->{ifDescr} ifIndex=$intf");
				next;
			}

			my $answer = {};
			my %CMValues;

			# check direction of qos with node table
			( $answer->{'cbQosPolicyDirection'} ) = $SNMP->getarray("cbQosPolicyDirection.$PIndex");
			NMISNG::Util::dbg("direction in policy is $answer->{'cbQosPolicyDirection'}, node wants $NC->{node}{cbqos}");

			if (( $answer->{'cbQosPolicyDirection'} == 1 and $NC->{node}{cbqos} =~ /^(input|both)$/ )
				or ( $answer->{'cbQosPolicyDirection'} == 2 and $NC->{node}{cbqos} =~ /^(output|true|both)$/ ) )
			{
				# interface found with QoS input or output configured

				my $direction = ( $answer->{'cbQosPolicyDirection'} == 1 ) ? "in" : "out";
				NMISNG::Util::info("Interface $intf found, direction $direction, PolicyIndex $PIndex");

				my $ifSpeedIn    = $if_data->{ifSpeedIn}  ? $if_data->{ifSpeedIn}  : $if_data->{ifSpeed};
				my $ifSpeedOut   = $if_data->{ifSpeedOut} ? $if_data->{ifSpeedOut} : $if_data->{ifSpeed};
				my $inoutIfSpeed = $direction eq "in"       ? $ifSpeedIn               : $ifSpeedOut;

				# get the policy config table for this interface
				my $qosIndexTable = $SNMP->getindex("cbQosConfigIndex.$PIndex");
				NMIS::Util::dbg("qos index table $PIndex: ".Dumper ($qosIndexTable)) if ( $C->{debug} > 5 );

				# the OID will be 1.3.6.1.4.1.9.9.166.1.5.1.1.2.$PIndex.$OIndex = Gauge
			BLOCK2:
				foreach my $OIndex ( keys %{$qosIndexTable} )
				{
					# look for the Object type for each
					( $answer->{'cbQosObjectsType'} ) = $SNMP->getarray("cbQosObjectsType.$PIndex.$OIndex");
					NMISNG::Util::dbg("look for object at $PIndex.$OIndex, type $answer->{'cbQosObjectsType'}");
					if ( $answer->{'cbQosObjectsType'} eq 1 )
					{
						# it's a policy-map object, is it the primairy
						( $answer->{'cbQosParentObjectsIndex'} )
							= $SNMP->getarray("cbQosParentObjectsIndex.$PIndex.$OIndex");
						if ( $answer->{'cbQosParentObjectsIndex'} eq 0 )
						{
							# this is the primairy policy-map object, get the name
							( $answer->{'cbQosPolicyMapName'} )
								= $SNMP->getarray("cbQosPolicyMapName.$qosIndexTable->{$OIndex}");
							NMISNG::Util::dbg("policymap - name is $answer->{'cbQosPolicyMapName'}, parent ID $answer->{'cbQosParentObjectsIndex'}"
							);
						}
					}
					elsif ( $answer->{'cbQosObjectsType'} eq 2 )
					{
						# it's a classmap, ask the name and the parent ID
						( $answer->{'cbQosCMName'}, $answer->{'cbQosParentObjectsIndex'} )
							= $SNMP->getarray( "cbQosCMName.$qosIndexTable->{$OIndex}",
							"cbQosParentObjectsIndex.$PIndex.$OIndex" );
						NMISNG::Util::dbg("classmap - name is $answer->{'cbQosCMName'}, parent ID $answer->{'cbQosParentObjectsIndex'}"
						);

						$answer->{'cbQosParentObjectsIndex2'} = $answer->{'cbQosParentObjectsIndex'};
						my $cnt = 0;

					  #KS 2011-10-27 Redundant model object not in use: NMISNG::Util::getbool($M->{system}{cbqos}{collect_all_cm})
						while ( !NMISNG::Util::getbool( $C->{'cbqos_cm_collect_all'}, "invert" )
							and $answer->{'cbQosParentObjectsIndex2'} ne 0
							and $answer->{'cbQosParentObjectsIndex2'} ne $PIndex
							and $cnt++ lt 5 )
						{
							( $answer->{'cbQosConfigIndex'} )
								= $SNMP->getarray("cbQosConfigIndex.$PIndex.$answer->{'cbQosParentObjectsIndex2'}");
							if ( $C->{debug} > 5 )
							{
								print "Dumping cbQosConfigIndex\n";
								print Dumper ( $answer->{'cbQosConfigIndex'} );
							}

							# it is not the first level, get the parent names
							( $answer->{'cbQosObjectsType2'} )
								= $SNMP->getarray("cbQosObjectsType.$PIndex.$answer->{'cbQosParentObjectsIndex2'}");
							if ( $C->{debug} > 5 )
							{
								print "Dumping cbQosObjectsType2\n";
								print Dumper ( $answer->{'cbQosObjectsType2'} );
							}

							NMISNG::Util::dbg("look for parent of ObjectsType $answer->{'cbQosObjectsType2'}");
							if ( $answer->{'cbQosObjectsType2'} eq 1 )
							{
								# it is a policymap name
								( $answer->{'cbQosName'}, $answer->{'cbQosParentObjectsIndex2'} )
									= $SNMP->getarray( "cbQosPolicyMapName.$answer->{'cbQosConfigIndex'}",
									"cbQosParentObjectsIndex.$PIndex.$answer->{'cbQosParentObjectsIndex2'}" );
								NMISNG::Util::dbg("parent policymap - name is $answer->{'cbQosName'}, parent ID $answer->{'cbQosParentObjectsIndex2'}"
								);
								if ( $C->{debug} > 5 )
								{
									print "Dumping cbQosName\n";
									print Dumper ( $answer->{'cbQosName'} );
									print "Dumping cbQosParentObjectsIndex2\n";
									print Dumper ( $answer->{'cbQosParentObjectsIndex2'} );
								}

							}
							elsif ( $answer->{'cbQosObjectsType2'} eq 2 )
							{
								# it is a classmap name
								( $answer->{'cbQosName'}, $answer->{'cbQosParentObjectsIndex2'} )
									= $SNMP->getarray( "cbQosCMName.$answer->{'cbQosConfigIndex'}",
									"cbQosParentObjectsIndex.$PIndex.$answer->{'cbQosParentObjectsIndex2'}" );
								NMISNG::Util::dbg("parent classmap - name is $answer->{'cbQosName'}, parent ID $answer->{'cbQosParentObjectsIndex2'}"
								);
								if ( $C->{debug} > 5 )
								{
									print "Dumping cbQosName\n";
									print Dumper ( $answer->{'cbQosName'} );
									print "Dumping cbQosParentObjectsIndex2\n";
									print Dumper ( $answer->{'cbQosParentObjectsIndex2'} );
								}
							}
							elsif ( $answer->{'cbQosObjectsType2'} eq 3 )
							{
								NMISNG::Util::dbg("skip - this class-map is part of a match statement");
								next BLOCK2;    # skip this class-map, is part of a match statement
							}

							# concatenate names
							if ( $answer->{'cbQosParentObjectsIndex2'} ne 0 )
							{
								$answer->{'cbQosCMName'} = "$answer->{'cbQosName'}--$answer->{'cbQosCMName'}";
							}
						}

						# collect all levels of classmaps or only the first level
						# KS 2011-10-27: by default collect hierarchical QoS
						if ( !NMISNG::Util::getbool( $C->{'cbqos_cm_collect_all'}, "invert" )
							or $answer->{'cbQosParentObjectsIndex'} eq $PIndex )
						{
							#
							$CMValues{"H" . $OIndex}{'CMName'}  = $answer->{'cbQosCMName'};
							$CMValues{"H" . $OIndex}{'CMIndex'} = $OIndex;
						}
					}
					elsif ( $answer->{'cbQosObjectsType'} eq 4 )
					{
						my $CMRate;

						# it's a queueing object, look for the bandwidth
						(   $answer->{'cbQosQueueingCfgBandwidth'},
							$answer->{'cbQosQueueingCfgBandwidthUnits'},
							$answer->{'cbQosParentObjectsIndex'}
							)
							= $SNMP->getarray(
							"cbQosQueueingCfgBandwidth.$qosIndexTable->{$OIndex}",
							"cbQosQueueingCfgBandwidthUnits.$qosIndexTable->{$OIndex}",
							"cbQosParentObjectsIndex.$PIndex.$OIndex"
							);
						if ( $answer->{'cbQosQueueingCfgBandwidthUnits'} eq 1 )
						{
							$CMRate = $answer->{'cbQosQueueingCfgBandwidth'} * 1000;
						}
						elsif ($answer->{'cbQosQueueingCfgBandwidthUnits'} eq 2
							or $answer->{'cbQosQueueingCfgBandwidthUnits'} eq 3 )
						{
							$CMRate = $answer->{'cbQosQueueingCfgBandwidth'} * $inoutIfSpeed / 100;
						}
						if ( $CMRate eq 0 ) { $CMRate = "undef"; }
						NMISNG::Util::dbg("queueing - bandwidth $answer->{'cbQosQueueingCfgBandwidth'}, units $answer->{'cbQosQueueingCfgBandwidthUnits'},"
								. "rate $CMRate, parent ID $answer->{'cbQosParentObjectsIndex'}" );
						$CMValues{"H" . $answer->{'cbQosParentObjectsIndex'}}{'CMCfgRate'} = $CMRate;
					}
					elsif ( $answer->{'cbQosObjectsType'} eq 6 )
					{
						# traffic shaping
						( $answer->{'cbQosTSCfgRate'}, $answer->{'cbQosParentObjectsIndex'} )
							= $SNMP->getarray( "cbQosTSCfgRate.$qosIndexTable->{$OIndex}",
							"cbQosParentObjectsIndex.$PIndex.$OIndex" );
						NMISNG::Util::dbg("shaping - rate $answer->{'cbQosTSCfgRate'}, parent ID $answer->{'cbQosParentObjectsIndex'}"
						);
						$CMValues{"H" . $answer->{'cbQosParentObjectsIndex'}}{'CMTSCfgRate'}
							= $answer->{'cbQosPoliceCfgRate'};

					}
					elsif ( $answer->{'cbQosObjectsType'} eq 7 )
					{
						# police
						( $answer->{'cbQosPoliceCfgRate'}, $answer->{'cbQosParentObjectsIndex'} )
							= $SNMP->getarray(
							"cbQosPoliceCfgRate.$qosIndexTable->{$OIndex}",
							"cbQosParentObjectsIndex.$PIndex.$OIndex"
							);
						NMISNG::Util::dbg("police - rate $answer->{'cbQosPoliceCfgRate'}, parent ID $answer->{'cbQosParentObjectsIndex'}"
						);
						$CMValues{"H" . $answer->{'cbQosParentObjectsIndex'}}{'CMPoliceCfgRate'}
							= $answer->{'cbQosPoliceCfgRate'};
					}

					NMISNG::Util::dbg(Dumper($answer)) if ( $C->{debug} > 5 );
				}

				if ( $answer->{'cbQosPolicyMapName'} eq "" )
				{
					$answer->{'cbQosPolicyMapName'} = 'default';
					NMISNG::Util::dbg("policymap - name is blank, so setting to default");
				}
				# putting this also in ifDescr so it's easier to programatically find in nodes.pl
				$cbQosTable{$intf}{$direction}{'ifDescr'} = $if_data->{'ifDescr'};
				$cbQosTable{$intf}{$direction}{'Interface'}{'Descr'} = $if_data->{'ifDescr'};
				$cbQosTable{$intf}{$direction}{'PolicyMap'}{'Name'}  = $answer->{'cbQosPolicyMapName'};
				$cbQosTable{$intf}{$direction}{'PolicyMap'}{'Index'} = $PIndex;

				# combine CM name and bandwidth
				foreach my $index ( keys %CMValues )
				{
					# check if CM name does exist
					if ( exists $CMValues{$index}{'CMName'} )
					{

						$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'Name'}  = $CMValues{$index}{'CMName'};
						$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'Index'} = $CMValues{$index}{'CMIndex'};

						# lets print the just type
						if ( exists $CMValues{$index}{'CMCfgRate'} )
						{
							$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'BW'}{'Descr'} = "Bandwidth";
							$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'BW'}{'Value'}
								= $CMValues{$index}{'CMCfgRate'};
						}
						elsif ( exists $CMValues{$index}{'CMTSCfgRate'} )
						{
							$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'BW'}{'Descr'} = "Traffic shaping";
							$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'BW'}{'Value'}
								= $CMValues{$index}{'CMTSCfgRate'};
						}
						elsif ( exists $CMValues{$index}{'CMPoliceCfgRate'} )
						{
							$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'BW'}{'Descr'} = "Police";
							$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'BW'}{'Value'}
								= $CMValues{$index}{'CMPoliceCfgRate'};
						}
						else
						{
							$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'BW'}{'Descr'} = "Bandwidth";
							$cbQosTable{$intf}{$direction}{'ClassMap'}{$index}{'BW'}{'Value'} = "undef";
						}

					}
					else
					{

					}
				}
			}
			else
			{
				NMISNG::Util::dbg("No collect requested in Node table");
			}
		}

		# Finished with SNMP QoS info collection, store inventory info and tune any existing rrds

		# that's an ifindex
		for my $index ( keys %cbQosTable )
		{
			my $thisqosinfo = $cbQosTable{$index};

			# we rely on index to be there for the path key (right now)
			my $if_data = $if_data_map{$index};

			# don't care about interfaces w/o descr or no speed or uncollected or invalid limit config
			next if ( ref( $if_data_map{$index} ) ne "HASH"
								or !$if_data->{ifSpeed}
								or $if_data->{setlimits} !~ /^(normal|strict|off)$/
								or !NMISNG::Util::getbool( $if_data->{collect} ) );

			my $thisintf     = $if_data;
			my $desiredlimit = $thisintf->{setlimits};

			NMISNG::Util::info(
				"performing rrd speed limit tuning for cbqos on $thisintf->{ifDescr}, limit enforcement: $desiredlimit, interface speed is "
				. NMISNG::Util::convertIfSpeed( $thisintf->{ifSpeed} )
				. " ($thisintf->{ifSpeed})" );

			# speed is in bits/sec, normal limit: 2*reported speed (in bytes), strict: exactly reported speed (in bytes)
			my $maxbytes
					= $desiredlimit eq "off"    ? "U"
					: $desiredlimit eq "normal" ? int( $thisintf->{ifSpeed} / 4 )
					:                             int( $thisintf->{ifSpeed} / 8 );
			my $maxpkts = $maxbytes eq "U" ? "U" : int( $maxbytes / 50 );    # this is a dodgy heuristic

			for my $direction (qw(in out))
			{
				# save the QoS Data, do it before tuning so inventory can be found when looking for name
				my $data = $thisqosinfo->{$direction};
				$data->{index} = $index;

				# create inventory entry, data is not changed below so do it here,
				# add index entry for now, may want to modify this later, or create a specialised Inventory class
				my $path_keys = ['index'];    # for now use this, loadInfo guarnatees it will exist
				my $path = $nmisng_node->inventory_path( concept => "cbqos-$direction",
																								 data => $data, path_keys => $path_keys );

				# only add if we have data, which we may not have in both directions, at this time
				# i can't see a better way to find out when to skip and setting it to be disabled
				# does not seem correct as the cbqos info isn't there
				if( ref($path) eq 'ARRAY' && defined($data->{ClassMap}))
				{
					my ( $inventory, $error_message ) = $nmisng_node->inventory(
						concept   => "cbqos-$direction",
						data      => $data,
						path      => $path,
						path_keys => $path_keys,
						create    => 1
							);

					$nmisng->log->error("Failed to create inventory, error:$error_message") && next if ( !$inventory );

					$inventory->data($data); # fixme why twice? already given in  the constructor...

					# regenerate the path, if this thing wasn't new the path may have changed, which is ok
					$inventory->path( recalculate => 1 );
					$inventory->historic(0);
					$inventory->enabled(1);

					# remove all unwanted storage info - classes that are gone
					my $knownones = $inventory->storage;
					my %keepthese = map { ($_->{Name} => 1)	} (values %{$data->{ClassMap}});
					for my $maybegone (keys %$knownones)
					{
						next if ($keepthese{$maybegone});
						$inventory->set_subconcept_type_storage(type => "rrd",
																										subconcept => $maybegone,
																										data => undef);
					}

					# set up the subconcept/storage infrastructure: one subconcept and rrd file per class (name)
					for my $class (keys %{$data->{ClassMap}})
					{
						my $classname = $data->{ClassMap}->{$class}->{Name};
						my $dbname = $S->makeRRDname(type => "cbqos-$direction",
																				 index     => $index,
																				 item      => $classname,
																				 relative => 1 );

						$inventory->set_subconcept_type_storage(type => "rrd",
																										subconcept => $classname,
																										data => $dbname);

						# does the rrd file already exist?
						if (-f (my $rrdfile =  $C->{database_root}."/".$dbname))
						{
							my $fileinfo = RRDs::info($rrdfile);
							for my $matching ( grep /^ds\[.+\]\.max$/, keys %$fileinfo )
							{
								next if ( $matching
											 !~ /ds\[(PrePolicyByte|DropByte|PostPolicyByte|PrePolicyPkt|DropPkt|NoBufDropPkt)\]\.max/
										);
								my $dsname = $1;
								my $curval = $fileinfo->{$matching};

								# all DS but the byte ones are packet based
								my $desiredval = $dsname =~ /byte/i ? $maxbytes : $maxpkts;

								if ( $curval ne $desiredval )
								{
									NMISNG::Util::info(
										"rrd cbqos-$direction-$classname, ds $dsname, current limit $curval, desired limit $desiredval: adjusting limit"
											);
									RRDs::tune( $rrdfile, "--maximum", "$dsname:$desiredval" );
								}
								else
								{
									NMISNG::Util::info("rrd cbqos-$direction-$classname, ds $dsname, current limit $curval is correct");
								}
							}
						}
						$inventory->data_info( subconcept => $classname, enabled => 0 );
					}

					my ( $op, $error ) = $inventory->save();
					NMISNG::Util::info( "saved ".join(',', @$path)." op: $op");
					$nmisng->log->error( "Failed to save inventory:" . join( ",", @{$inventory->path} ) . " error:$error" )
							if ($error);
				}
			}
		}
	}
	else
	{
		NMISNG::Util::dbg("no entries found in QoS table of node $S->{name}");
	}
	return 1;
}

#=========================================================================================



# fixme: this function does not work for wmi-only nodes, it's also good and nasty
sub runServer
{
	my %args = @_;
	my $S    = $args{sys};
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	if ( !$S->status->{snmp_enabled} )
	{
		NMISNG::Util::info("Not performing server collection for $S->{name}: SNMP not enabled for this node");
		return 1;
	}

	my $M    = $S->mdl;
	my $SNMP = $S->snmp;

	my ( $result, %Val, %ValMeM, $hrCpuLoad, $op, $error );

	NMISNG::Util::info("Starting server device/storage collection, node $S->{name}");

	# clean up node file
	NMISNG::Util::TODO("fixme9 Need a cleanup/historic checker");

	# get cpu info
	if ( ref( $M->{device} ) eq "HASH" && keys %{$M->{device}} )
	{
		# this will put hrCpuLoad into the device_global concept
		# NOTE: should really be PIT!!!
		my $overall_target = {};
		my $deviceIndex = $SNMP->getindex('hrDeviceIndex');
		# doesn't use device global here, it's only an inventory concept right now
		$S->loadInfo( class => 'device', model => $model, target => $overall_target );    # get cpu load without index

		my $path = $S->nmisng_node->inventory_path( concept => 'device_global', path_keys => [], data => $overall_target );
		my ($inventory,$error_message) = $S->nmisng_node->inventory(
			concept => 'device_global',
			path => $path,
			path_keys => [],
			data => $overall_target,
			create => 1
		);
		$S->nmisng->log->error("Failed to get inventory for device_global, error_message:$error_message") if(!$inventory);
		# create is set so we should have an inventory here
		if($inventory)
		{
			# not sure why supplying the data above does not work, needs a test!
			$inventory->data( $overall_target );
			$inventory->historic(0);
			$inventory->enabled(1);
			# disable for now
			$inventory->data_info( subconcept => 'device_global', enabled => 0 );
			($op,$error) = $inventory->save();
			NMISNG::Util::info( "saved ".join(',', @$path)." op: $op");
		}

		$S->nmisng->log->error("Failed to save inventory, error_message:$error") if($error);

		foreach my $index ( keys %{$deviceIndex} )
		{
			# create a new target for each index
			my $device_target = {};
			if ( $S->loadInfo( class => 'device', index => $index, model => $model, target => $device_target ) )
			{
				my $D = $device_target;
				NMISNG::Util::info("device Descr=$D->{hrDeviceDescr}, Type=$D->{hrDeviceType}");
				if ( $D->{hrDeviceType} eq '1.3.6.1.2.1.25.3.1.3' )
				{# hrDeviceProcessor
					( $hrCpuLoad, $D->{hrDeviceDescr} )
						= $SNMP->getarray( "hrProcessorLoad.${index}", "hrDeviceDescr.${index}" );
					NMISNG::Util::dbg("CPU $index hrProcessorLoad=$hrCpuLoad hrDeviceDescr=$D->{hrDeviceDescr}");

					### 2012-12-20 keiths, adding Server CPU load to Health Calculations.
					push( @{$S->{reach}{cpuList}}, $hrCpuLoad );

					$device_target->{hrCpuLoad}
						= ( $hrCpuLoad =~ /noSuch/i ) ? $overall_target->{hrCpuLoad} : $hrCpuLoad;
					NMISNG::Util::info("cpu Load=$overall_target->{hrCpuLoad}, Descr=$D->{hrDeviceDescr}");
					my $D = {};
					$D->{hrCpuLoad}{value} = $device_target->{hrCpuLoad} || 0;

					# lookup/create inventory before create_update_rrd so it can be passed in
					my $path = $S->nmisng_node->inventory_path( concept => 'device', path_keys => ['index'], data => $device_target );
					($inventory,$error_message) = $S->nmisng_node->inventory(
						concept => 'device',
						path => $path,
						path_keys => ['index'],
						data => $device_target,
						create => 1
					);
					$S->nmisng->log->error("Failed to get inventory, error_message:$error_message") if(!$inventory);

					if (! ( my $db = $S->create_update_rrd( data => $D, type => "hrsmpcpu", index => $index, inventory => $inventory ) ) )
					{
						NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
					}

					# save after create_update_rrd so that new storage information is also saved
					# again, create is set, chances of no inventory very low
					if($inventory)
					{
						$inventory->data($device_target);
						$inventory->description( $device_target->{hrDeviceDescr} ) if( $device_target->{hrDeviceDescr} );
						$inventory->historic(0);
						$inventory->enabled(1);
						$inventory->data_info( subconcept => 'hrsmpcpu', enabled => 0 );

						my $previous_pit = $inventory->get_newest_timed_data();
						# shouldn't need to save twice but this all could be optimise
						my $target = {};
						NMISNG::Inventory::parse_rrd_update_data( $D, $target, $previous_pit, 'hrsmpcpu' );
						# get stats
						my $period = getThresholdPeriod(subconcept => 'hrsmpcpu');
						my $stats = Compat::NMIS::getSubconceptStats(sys => $S, inventory => $inventory,
							subconcept => 'hrsmpcpu', start => $period, end => time);
						$stats //= {};
						my $error = $inventory->add_timed_data( data => $target, derived_data => $stats, subconcept => 'hrsmpcpu',
																										time => $catchall_data->{last_poll}, delay_insert => 1 );
						NMISNG::Util::logMsg("ERROR: timed data adding for ". $inventory->concept ." failed: $error") if ($error);

						($op,$error) = $inventory->save();
						NMISNG::Util::info( "saved ".join(',', @$path)." op: $op");
					}
					$S->nmisng->log->error("Failed to save inventory, error_message:$error") if($error);
				}
				else
				{
					# don't log this error if not found because it probably doesn't exist
					$inventory = $S->inventory( concept => 'device', index => $index, nolog => 1);
					# if this thing already exists in the database, then disable it, historic is not correct
					# because it is still being reported on the device
					if($inventory)
					{
						$inventory->enabled(0);
						$inventory->save();
					}
				}
			}
		}
		NMISNG::Util::TODO("Need to clean up device/devices here and mark unused historic");
	}
	else
	{
		NMISNG::Util::dbg("Class=device not defined in model=$catchall_data->{nodeModel}");
	}

	### 2012-12-20 keiths, adding Server CPU load to Health Calculations.
	if ( ref( $S->{reach}{cpuList} ) and @{$S->{reach}{cpuList}} )
	{
		$S->{reach}{cpu} = mean( @{$S->{reach}{cpuList}} );
	}

	if ( $M->{storage} ne '' )
	{
		my $disk_cnt             = 1;
		my $storageIndex         = $SNMP->getindex('hrStorageIndex');
		my $hrFSMountPoint       = undef;
		my $hrFSRemoteMountPoint = undef;
		my $fileSystemTable      = undef;

		foreach my $index ( keys %{$storageIndex} )
		{
			# look for existing data for this as 'fallback'
			my $oldstorage;
			my $inventory = $S->inventory( concept => 'storage', index => $index, nolog => 1);
			$oldstorage = $inventory->data() if($inventory);
			my $storage_target = {};

			# this saves any retrieved info in the target
			my $wasloadable = $S->loadInfo(
				class  => 'storage',
				index  => $index,
				model  => $model,
				target => $storage_target
			);
			if ( $wasloadable )
			{
				# create_update_rrd needs an inventory object so create one, we know that index exists now so we have what is needed to
				# create/search for the path
				if( !$inventory )
				{
					my $path = $S->nmisng_node->inventory_path( concept => 'storage',
																											path_keys => ['index'],
																											data => $storage_target );
					($inventory,$error) = $S->nmisng_node->inventory(
						concept => 'storage',
						data => $storage_target,
						path => $path,
						path_keys => ['index'],
						create => 1
					);
					if (!$inventory)
					{
						$S->nmisng->log->error("Failed to get storage inventory, error_message:$error");
						next;
					}
				}

				my $D; #used to be %Val
				my $subconcept = 'notset'; # this will be filled in with the subconcept found

				### 2017-02-13 keiths, handling larger disk sizes by converting to an unsigned integer
				$storage_target->{hrStorageSize} = unpack( "I", pack( "i", $storage_target->{hrStorageSize} ) );
				$storage_target->{hrStorageUsed} = unpack( "I", pack( "i", $storage_target->{hrStorageUsed} ) );

				NMISNG::Util::info(
					"storage $storage_target->{hrStorageDescr} Type=$storage_target->{hrStorageType}, Size=$storage_target->{hrStorageSize}, Used=$storage_target->{hrStorageUsed}, Units=$storage_target->{hrStorageUnits}"
				);

				$inventory->historic(0); # it still exists
				$inventory->enabled(1);	# and it seems wanted - maybe not...

				# unwanted? nocollect regex matches or has zero size (matches windows cd, floppy)
				if (($M->{storage}{nocollect}{Description} ne ''
						 and $storage_target->{hrStorageDescr} =~ /$M->{storage}{nocollect}{Description}/
						)
						or $storage_target->{hrStorageSize} <= 0
						)
				{
					$inventory->enabled(0);
				}
				else
				{
					if ($storage_target->{hrStorageType} eq '1.3.6.1.2.1.25.2.1.4'        # hrStorageFixedDisk
							or $storage_target->{hrStorageType} eq '1.3.6.1.2.1.25.2.1.10'    # hrStorageNetworkDisk
							)
					{
						$subconcept = 'hrdisk';
						my $hrStorageType = $storage_target->{hrStorageType};
						$D->{hrDiskSize}{value} = $storage_target->{hrStorageUnits} * $storage_target->{hrStorageSize};
						$D->{hrDiskUsed}{value} = $storage_target->{hrStorageUnits} * $storage_target->{hrStorageUsed};

						### 2012-12-20 keiths, adding Server Disk to Health Calculations.
						my $diskUtil = $D->{hrDiskUsed}{value} / $D->{hrDiskSize}{value} * 100;
						NMISNG::Util::dbg("Disk List updated with Util=$diskUtil Size=$D->{hrDiskSize}{value} Used=$D->{hrDiskUsed}{value}",
															1);
						push( @{$S->{reach}{diskList}}, $diskUtil );

						$storage_target->{hrStorageDescr} =~ s/,/ /g;    # lose any commas.
						if ( ( my $db = $S->create_update_rrd( data => $D, type => $subconcept,
																									 index => $index, inventory => $inventory ) ) )
						{
							$storage_target->{hrStorageType}              = 'Fixed Disk';
							$storage_target->{hrStorageIndex}             = $index;
							$storage_target->{hrStorageGraph}             = "hrdisk";
							$disk_cnt++;
						}
						else
						{
							NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
						}

						if ( $hrStorageType eq '1.3.6.1.2.1.25.2.1.10' )
						{
							# only get this snmp once if we need to, and created an named index.
							if ( not defined $fileSystemTable )
							{
								$hrFSMountPoint       = $SNMP->getindex('hrFSMountPoint');
								$hrFSRemoteMountPoint = $SNMP->getindex('hrFSRemoteMountPoint');
								foreach my $fsIndex ( keys %$hrFSMountPoint )
								{
									my $mp = $hrFSMountPoint->{$fsIndex};
									$fileSystemTable->{$mp} = $hrFSRemoteMountPoint->{$fsIndex};
								}
							}

							$storage_target->{hrStorageType}        = 'Network Disk';
							$storage_target->{hrFSRemoteMountPoint} = $fileSystemTable->{$storage_target->{hrStorageDescr}};
						}

					}
					### VMware shows Real Memory as HOST-RESOURCES-MIB::hrStorageType.7 = OID: HOST-RESOURCES-MIB::hrStorageTypes.20
					elsif ($storage_target->{hrStorageType} eq '1.3.6.1.2.1.25.2.1.2'
								 or $storage_target->{hrStorageType} eq '1.3.6.1.2.1.25.2.1.20' )
					{
						# Memory
						$subconcept = 'hrmem';
						$D->{hrMemSize}{value} = $storage_target->{hrStorageUnits} * $storage_target->{hrStorageSize};
						$D->{hrMemUsed}{value} = $storage_target->{hrStorageUnits} * $storage_target->{hrStorageUsed};

						$S->{reach}{memfree} = $D->{hrMemSize}{value} - $D->{hrMemUsed}{value};
						$S->{reach}{memused} = $D->{hrMemUsed}{value};

						if ( ( my $db = $S->create_update_rrd( data => $D, type => $subconcept, inventory => $inventory ) ) )
						{
							$storage_target->{hrStorageType}     = 'Memory';
							$storage_target->{hrStorageGraph}    = "hrmem";
						}
						else
						{
							NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
						}
					}

					# in net-snmp, virtualmemory is used as type for both swap and 'virtual memory' (=phys + swap)
					elsif ( $storage_target->{hrStorageType} eq '1.3.6.1.2.1.25.2.1.3' )
					{    # VirtualMemory
						my ( $itemname, $typename )
								= ( $storage_target->{hrStorageDescr} =~ /Swap/i ) ? (qw(hrSwapMem hrswapmem)) : (qw(hrVMem hrvmem));
						$subconcept = $typename;

						$D->{$itemname . "Size"}{value} = $storage_target->{hrStorageUnits} * $storage_target->{hrStorageSize};
						$D->{$itemname . "Used"}{value} = $storage_target->{hrStorageUnits} * $storage_target->{hrStorageUsed};

						### 2014-08-07 keiths, adding Other Memory to Health Calculations.
						$S->{reach}{$itemname . "Free"}
							= $D->{$itemname . "Size"}{value} - $D->{$itemname . "Used"}{value};
						$S->{reach}{$itemname . "Used"} = $D->{$itemname . "Used"}{value};

						#print Dumper $S->{reach};

						if ( my $db = $S->create_update_rrd( data => $D, type => $subconcept, inventory => $inventory ) )
						{
							$storage_target->{hrStorageType}         = $storage_target->{hrStorageDescr};    # i.e. virtual memory or swap space
							$storage_target->{hrStorageGraph}        = $typename;
						}
						else
						{
							NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
						}
					}

					# also collect mem buffers and cached mem if present
					# these are marked as storagetype hrStorageOther but the descr is usable
					elsif (
						$storage_target->{hrStorageType} eq '1.3.6.1.2.1.25.2.1.1'    # StorageOther
						and $storage_target->{hrStorageDescr} =~ /^(Memory buffers|Cached memory)$/i
							)
					{
						my ( $itemname, $typename )
								= ( $storage_target->{hrStorageDescr} =~ /^Memory buffers$/i )
							? (qw(hrBufMem hrbufmem))
							: (qw(hrCacheMem hrcachemem));
						$subconcept = $typename;

						# for buffers the total size isn't overly useful (net-snmp reports total phsymem),
						# for cached mem net-snmp reports total size == used cache mem
						$D->{$itemname . "Size"}{value} = $storage_target->{hrStorageUnits} * $storage_target->{hrStorageSize};
						$D->{$itemname . "Used"}{value} = $storage_target->{hrStorageUnits} * $storage_target->{hrStorageUsed};

						if ( my $db = $S->create_update_rrd( data => $D, type => $subconcept, inventory => $inventory ) )
						{
							$storage_target->{hrStorageType}         = 'Other Memory';
							$storage_target->{hrStorageGraph}        = $typename;
						}
						else
						{
							NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
						}
					}
					# storage type not recognized?
					else
					{
						$inventory->enabled(0);
					}
				}

				my $target = {};
				my $previous_pit = $inventory->get_newest_timed_data();

				# make sure the data is set and save
				$inventory->data( $storage_target );
				$inventory->description( $storage_target->{hrStorageDescr} )
					if( defined($storage_target->{hrStorageDescr}) && $storage_target->{hrStorageDescr});


				NMISNG::Inventory::parse_rrd_update_data( $D, $target, $previous_pit, $subconcept );
				# get stats
				my $period = getThresholdPeriod(subconcept => $subconcept);
				my $stats = Compat::NMIS::getSubconceptStats(sys => $S, inventory => $inventory,
					subconcept => $subconcept, start => $period, end => time);
				$stats //= {};
				my $error = $inventory->add_timed_data( data => $target, derived_data => $stats, subconcept => $subconcept,
																								time => $catchall_data->{last_poll}, delay_insert => 1 );
				NMISNG::Util::logMsg("ERROR: timed data adding for ". $inventory->concept ." failed: $error") if ($error);

				$inventory->data_info( subconcept => $subconcept, enabled => 0 );
				($op,$error) = $inventory->save();
				NMISNG::Util::info( "saved ".join(',', @{$inventory->path})." op: $op");
				$S->nmisng->log->error("Failed to save storage inventory, op:$op, error_message:$error") if($error);
			}
			elsif( $oldstorage )
			{
				NMISNG::Util::logMsg("ERROR failed to retrieve storage info for index=$index, $oldstorage->{hrStorageDescr}, continuing with OLD data!");
				if( $inventory )
				{
					$inventory->historic(1);
					$inventory->save();
				}
				# nothing needs to be done here, storage target is the data from last time so it's already in db
				# maybe mark it historic?
			}
		}
	}
	else
	{
		NMISNG::Util::dbg("Class=storage not defined in Model=$catchall_data->{nodeModel}");
	}

	### 2012-12-20 keiths, adding Server Disk Usage to Health Calculations.
	if ( defined $S->{reach}{diskList} and @{$S->{reach}{diskList}} )
	{
		#print Dumper $S->{reach}{diskList};
		$S->{reach}{disk} = mean( @{$S->{reach}{diskList}} );
	}

	NMISNG::Util::info("Finished");
}    # end runServer


#=========================================================================================

# this function runs all services that are directly associated with a given node
# args: live sys object for the node in question, and optional snmp (true/false) arg
#
# attention: when run with snmp false then snmp-based services are NOT checked!
# fixme: this function does not support service definitions from wmi!
sub runServices
{
	my %args = @_;
	my $S    = $args{sys};
	my $V    = $S->view;
	my $C    = NMISNG::Util::loadConfTable();
	my $NT   = Compat::NMIS::loadLocalNodeTable();
	my $SNMP = $S->snmp;
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	# don't attempt anything silly if this is a wmi-only node
	my $snmp_allowed = NMISNG::Util::getbool( $args{snmp} ) && $S->status->{snmp_enabled};

	my $node = $S->{name};

	NMISNG::Util::info("Starting Services stats, node=$S->{name}, nodeType=$catchall_data->{nodeType}");

	my $cpu;
	my $memory;
	my $msg;
	my %services;    # hash to hold snmp gathered service status.

	my $ST    = Compat::NMIS::loadServicesTable();
	my $timer = Compat::Timing->new;

	my $nmisng = $S->nmisng;
	my $nmisng_node = $S->nmisng_node();

	# do an snmp service poll first, regardless of whether any specific services being enabled or not
	my %snmpTable;
	my $timeout = 3;
	my ( $snmpcmd, @ret, $var, $i );
	my $write = 0;

	# do we have snmp-based services and are we allowed to check them? ie node active and collect on
	# if so, then do the collection here
	if ( $snmp_allowed
			 and NMISNG::Util::getbool( $NT->{$node}{active} )
			 and NMISNG::Util::getbool( $NT->{$node}{collect} )
			 and grep( exists( $ST->{$_} ) && $ST->{$_}->{Service_Type} eq "service",
								 split( /,/, $NT->{$node}->{services} ) )
			)
	{
		NMISNG::Util::info("node has SNMP services to check");

		NMISNG::Util::dbg("get index of hrSWRunName by snmp, then get some data");
		my $hrIndextable;

		# get the process parameters by column, allowing efficient bulk requests
		# but possibly running into bad agents at times, which gettable/getindex
		# compensates for by backing off and retrying.
		for my $var (
			qw(hrSWRunName hrSWRunPath hrSWRunParameters hrSWRunStatus
			hrSWRunType hrSWRunPerfCPU hrSWRunPerfMem)
			)
		{
			if ( $hrIndextable = $SNMP->getindex($var) )
			{
				foreach my $inst ( keys %{$hrIndextable} )
				{
					my $value   = $hrIndextable->{$inst};
					my $textoid = NMISNG::MIB::oid2name( NMISNG::MIB::name2oid($var) . "." . $inst );
					$value = snmp2date($value) if ( $textoid =~ /date\./i );
					( $textoid, $inst ) = split /\./, $textoid, 2;
					$snmpTable{$textoid}{$inst} = $value;
					NMISNG::Util::dbg( "Indextable=$inst textoid=$textoid value=$value", 2 );
				}
			}

			# SNMP failed, so mark SNMP down so code below handles results properly
			else
			{
				NMISNG::Util::logMsg("$node SNMP failed while collecting SNMP Service Data");
				HandleNodeDown( sys => $S, type => "snmp", details => "get SNMP Service Data: " . $SNMP->error );
				$snmp_allowed = 0;
				last;
			}
		}

		# are we still good to continue?
		# don't do anything with the (incomplete and unusable) snmp data if snmp failed just now
		if ($snmp_allowed)
		{
			# prepare service list for all observed services, but ditch 'invalid' == zombies
			for my $pid ( keys %{$snmpTable{hrSWRunName}} )
			{
				# nmis keys services by name:pid (*sigh*)
				my $newkey = "$snmpTable{hrSWRunName}{$pid}:$pid";
				my %newrecord = ( pid => $pid, # cleaner/more useful
													hrSWRunName => $newkey, # name mangling is bad
													map { ($_ => $snmpTable{$_}->{$pid}) } (qw(hrSWRunPath hrSWRunParameters
hrSWRunPerfCPU hrSWRunPerfMem)) );
				$newrecord{hrSWRunType} = ( '', 'unknown', 'operatingSystem',
																		'deviceDriver', 'application' )[ $snmpTable{hrSWRunType}->{$pid}];
				$newrecord{hrSWRunStatus} = ( '', 'running', 'runnable',
																			'notRunnable', 'invalid' )[ $snmpTable{hrSWRunStatus}->{$pid}];
				if ($newrecord{hrSWRunStatus} eq "invalid")
				{
					NMISNG::Util::dbg("skipping process in state 'invalid': ".
														Data::Dumper->new([\%newrecord])->Terse(1)->Indent(0)->Pair("=")->Dump, 3);
					next;
				}

				$services{$newkey} = \%newrecord;
				NMISNG::Util::dbg("Found process: ".Data::Dumper->new([\%newrecord])->Terse(1)->Indent(0)->Pair("=")->Dump, 2);
			}

			# keep all processes for display, not rrd - park this as timed-data
			# for 'snmp_services' - fixme rename the concept?
			my $procinv_path = $nmisng_node->inventory_path(concept => "snmp_services", path_keys => [], data => {});
			die "failed to create path for snmp_services: $procinv_path\n" if (!ref($procinv_path));
			my ( $processinventory, $error)  = $nmisng_node->inventory( concept => "snmp_services",
																																 data => {},
																																 path => $procinv_path,
																																 path_keys => [],
																																 create => 1);
			die "failed to create or load inventory for snmp_services: $error\n" if (!$processinventory);
			# i think disabled here makes sense
			$processinventory->data_info( subconcept => 'snmp_services', enabled => 0 );
			(my $op, $error) = $processinventory->save();
			die "failed to save inventory for snmp_services: $error\n" if ($error);
			$error = $processinventory->add_timed_data(data => \%services, derived_data => {}, subconcept => 'snmp_services');
			NMISNG::Util::logMsg("ERROR: snmp_services timed data saving failed: $error") if ($error);

			# now clear events that applied to processes that no longer exist
			my %nodeevents = Compat::NMIS::loadAllEvents( node => $S->{name} );
			for my $eventkey ( keys %nodeevents )
			{
				my $thisevent = $nodeevents{$eventkey};

		  # fixme NMIS-73: this should be tied to both the element format and a to-be-added 'service' field of the event
		  # until then we trigger on the element format plus event name
				if (   $thisevent->{element} =~ /^\S+:\d+$/
					&& $thisevent->{event} =~ /process memory/i
					&& !exists $services{$thisevent->{element}} )
				{
					NMISNG::Util::dbg(      "clearing event $thisevent->{event} for node $thisevent->{node} as process "
							. $thisevent->{element}
							. " no longer exists" );
					Compat::NMIS::checkEvent(
						sys     => $S,
						event   => $thisevent->{event},
						level   => $thisevent->{level},
						element => $thisevent->{element},
						details => $thisevent->{details}
					);
				}
			}
		}
	}

	# find and mark as historic any services no longer configured for this host
	my %desiredservices = map { ($_ => 1) } (split /,/, $NT->{$S->{name}}{services} );

	my $modeldata = $nmisng_node->get_inventory_model(concept => "service",
																							filter => { historic => 0 },
																							fields_hash => { "data.service" => 1,
																															 _id => 1, });
	my %oldservice = map { ($_->{data}->{service} => $_->{_id}) } (@{$modeldata->data});
	for my $maybedead (keys %oldservice)
	{
		next if ($desiredservices{$maybedead});
		NMISNG::Util::dbg("marking as historic inventory record for service $maybedead");
		my ( $invobj, $error) = $nmisng_node->inventory(_id => $oldservice{$maybedead});
		die "cannot instantiate inventory object: $error\n" if ($error or !ref($invobj));
		$invobj->historic(1);
		$error = $invobj->save();
		NMISNG::Util::logMsg("ERROR failed to save historic inventory object for service $maybedead: $error") if ($error);
	}

	# specific services to be tested are saved in a list - these are rrd-collected, too.
	# note that this also covers the snmp-based services
	for my $service (sort keys %desiredservices)
	{
		my $thisservice = $ST->{$service};

		# check for invalid service table data
		next if ( !$service
							or $service =~ m!^n\/a$!i
							or $thisservice->{Service_Type} =~ m!^n\/a$!i );

		my ($name, $servicename, $servicetype)
				= @{$thisservice}{"Name","Service_Name","Service_Type"};

		# are we supposed to run this service now?
		# load the service inventory, most recent point-in-time data and check the last run time
		my $inventorydata = {
			service     => $service, # == key in Services.nmis, primary identifier
			# AND ensure the service has a uuid, a recreatable V5 one from config'd namespace+cluster_id+service+node's uuid
			uuid        => NMISNG::Util::getComponentUUID( $C->{cluster_id}, $service,
																									 $catchall_data->{uuid} ),
			description => $thisservice->{Description},
			display_name => $name, # logic-free, no idea why/how that can differ from $service
			node => $node, # backwards-compat
		};

		my $path_keys = [ 'service' ];
		my $path = $nmisng_node->inventory_path( concept => 'service',
																						 data => $inventorydata,
																						 path_keys => $path_keys );
		die "failed to create path for service: $path\n" if (!ref($path));

		my ($inventory, $error) = $nmisng_node->inventory(
			concept => "service",
			data    => $inventorydata,
			path => $path,
			path_keys => $path_keys,
			create  => 1,
				);
		die "failed to create or load inventory for $service: $error\n" if (!$inventory);

		# when was this service checked last?
		my $lastrun = ref($inventory->data) eq "HASH"? $inventory->data->{last_run} : 0;


		my $serviceinterval = $thisservice->{Poll_Interval} || 300;                       # 5min
		my $msg = "Service $service on $node (interval \"$serviceinterval\") last ran at "
			. NMISNG::Util::returnDateStamp($lastrun) . ", ";
		if ( $serviceinterval =~ /^\s*(\d+(\.\d+)?)([mhd])$/ )
		{
			my ( $rawvalue, $unit ) = ( $1, $3 );
			$serviceinterval = $rawvalue * ( $unit eq 'm' ? 60 : $unit eq 'h' ? 3600 : 86400 );
		}

		# we don't run the service exactly at the same time in the collect cycle,
		# so allow up to 10% underrun
		# note that force overrules the timing  policy
		if ( !NMISNG::Util::getbool($nvp{force})
				 && $lastrun
				 && ( ( time - $lastrun ) < $serviceinterval * 0.9 ) )
		{
			$msg .= "skipping this time.";
			if ( $C->{info} or $C->{debug} )
			{
				NMISNG::Util::info($msg);
				NMISNG::Util::logMsg("INFO: $msg");
			}
			next;
		}
		else
		{
			$msg .= "must be checked this time.";
			if ( $C->{info} or $C->{debug} )
			{
				NMISNG::Util::info($msg);
				NMISNG::Util::logMsg("INFO: $msg");
			}
		}

		# make sure that the rrd heartbeat is suitable for the service interval!
		my $serviceheartbeat = ( $serviceinterval * 3 ) || 300 * 3;

		# make sure this gets reinitialized for every service!
		my $gotMemCpu = 0;
		my (%Val, %status);

		NMISNG::Util::info(
			"Checking service_type=$servicetype name=$name service_name=$servicename"
		);

		# clear global hash each time around as this is used to pass results to rrd update
		my $ret      = 0;
		my $snmpdown = 0;

		# record the service response time, more precisely the time it takes us testing the service
		$timer->resetTime;
		my $responsetime;    # blank the responsetime

		# DNS: lookup whatever Service_name contains (fqdn or ip address),
		# nameserver being the host in question
		if ( $servicetype eq "dns" )
		{
			use Net::DNS;
			my $lookfor = $servicename;
			if ( !$lookfor )
			{
				NMISNG::Util::dbg("Service_Name for $catchall_data->{host} must be a FQDN or IP address");
				NMISNG::Util::logMsg(
					"ERROR, ($S->{name}) Service_name for service=$service must contain an FQDN or IP address"
				);
				next;
			}
			my $res = Net::DNS::Resolver->new;
			$res->nameserver( $catchall_data->{host} );
			$res->udp_timeout(10);    # don't waste more than 10s on dud dns
			$res->usevc(0);           # force to udp (default)
			$res->debug(1) if $C->{debug} > 3;    # set this to 1 for debug

			my $packet = $res->search($lookfor);  # resolver figures out what to look for
			if ( !defined $packet )
			{
				$ret = 0;
				NMISNG::Util::dbg("ERROR Unable to lookup $lookfor on DNS server $catchall_data->{host}");
			}
			else
			{
				$ret = 1;
				NMISNG::Util::dbg( "DNS data for $lookfor from $catchall_data->{host} was " . $packet->string );
			}
		}    # end DNS

		# now the 'port' service checks, which rely on nmap
		# - tcp would be easy enough to do with a plain connect, but udp accessible-or-closed needs extra smarts
		elsif ( $servicetype eq "port" )
		{
			$msg = '';
			my ( $scan, $port ) = split ':', $thisservice->{Port};

			my $nmap = (
				$scan =~ /^udp$/i
				? "nmap -sU --host_timeout 3000 -p $port -oG - $catchall_data->{host}"
				: "nmap -sT --host_timeout 3000 -p $port -oG - $catchall_data->{host}"
			);

			# fork and read from pipe
			my $pid = open( NMAP, "$nmap 2>&1 |" );
			if ( !defined $pid )
			{
				my $errmsg = "ERROR, Cannot fork to execute nmap: $!";
				NMISNG::Util::logMsg($errmsg);
				NMISNG::Util::info($errmsg);
			}
			while (<NMAP>)
			{
				$msg .= $_;    # this retains the newlines
			}
			close(NMAP);
			my $exitcode = $?;

			# if the pipe close doesn't wait until the child is gone (which it may do...)
			# then wait and collect explicitely
			if ( waitpid( $pid, 0 ) == $pid )
			{
				$exitcode = $?;
			}
			if ($exitcode)
			{
				NMISNG::Util::logMsg( "ERROR, NMAP ($nmap) returned exitcode " . ( $exitcode >> 8 ) . " (raw $exitcode)" );
				NMISNG::Util::info( "$nmap returned exitcode " .                 ( $exitcode >> 8 ) . " (raw $exitcode)" );
			}
			if ( $msg =~ /Ports: $port\/open/ )
			{
				$ret = 1;
				NMISNG::Util::info("NMAP reported success for port $port: $msg");
				NMISNG::Util::logMsg("INFO, NMAP reported success for port $port: $msg") if ( $C->{debug} or $C->{info} );
			}
			else
			{
				$ret = 0;
				NMISNG::Util::info("NMAP reported failure for port $port: $msg");
				NMISNG::Util::logMsg("INFO, NMAP reported failure for port $port: $msg") if ( $C->{debug} or $C->{info} );
			}
		}

		# now the snmp services - but only if snmp is on
		elsif ( $servicetype eq "service"
			and NMISNG::Util::getbool( $NT->{$node}{collect} ) )
		{
			# only do the SNMP checking if and when you are supposed to!
			# snmp not allowed also includes the case of snmp having failed just now
			next if ( !$snmp_allowed );

			NMISNG::Util::dbg("snmp_stop_polling_on_error=$C->{snmp_stop_polling_on_error} snmpdown=$catchall_data->{snmpdown} nodedown=$catchall_data->{nodedown}"
			);
			if (NMISNG::Util::getbool( $C->{snmp_stop_polling_on_error}, "invert" )
				or (    NMISNG::Util::getbool( $C->{snmp_stop_polling_on_error} )
					and !NMISNG::Util::getbool( $catchall_data->{snmpdown} )
					and !NMISNG::Util::getbool( $catchall_data->{nodedown} ) )
				)
			{
				my $wantedprocname = $servicename;
				my $parametercheck = $thisservice->{Service_Parameters};

				if ( !$wantedprocname and !$parametercheck )
				{
					NMISNG::Util::dbg("ERROR, Both Service_Name and Service_Parameters are empty");
					NMISNG::Util::logMsg(
						"ERROR, ($S->{name}) service=$service Service_Name and Service_Parameters are empty!");
					next;
				}

				# one of the two blank is ok
				$wantedprocname ||= ".*";
				$parametercheck ||= ".*";

				# lets check the service status from snmp for matching process(es)
				# it's common to have multiple processes with the same name on a system,
				# heuristic: one or more living processes -> service is ok,
				# no living ones -> down.
				# living in terms of host-resources mib = runnable or running;
				# interpretation of notrunnable is not clear.
				# invalid is for (short-lived) zombies, which should be ignored.

				# we check: the process name, against regex from Service_Name definition,
				# AND the process path + parameters, against regex from Service_Parameters
				# services list is keyed by "name:pid"
				my @matchingpids = grep( (
						/^$wantedprocname:\d+$/
							&& ( $services{$_}->{hrSWRunPath} . " " . $services{$_}->{hrSWRunParameters} )
							=~ /$parametercheck/
					),
					keys %services );

				my @livingpids = grep ( $services{$_}->{hrSWRunStatus} =~ /^(running|runnable)$/i, @matchingpids );

				NMISNG::Util::dbg(      "runServices: found "
						. scalar(@matchingpids)
						. " total and "
						. scalar(@livingpids)
						. " live processes for process '$wantedprocname', parameters '$parametercheck', live processes: "
						. join( " ", map { /^$wantedprocname:(\d+)/ && $1 } (@livingpids) ) );

				if ( !@livingpids )
				{
					$ret       = 0;
					$cpu       = 0;
					$memory    = 0;
					$gotMemCpu = 1;
					NMISNG::Util::logMsg(
						"INFO, service $name is down, "
							. (
							@matchingpids
							? "only non-running processes"
							: "no matching processes"
							)
					);
				}
				else
				{
					# return the average values for cpu and mem
					$ret       = 1;
					$gotMemCpu = 1;

					# cpu is in centiseconds, and a running counter. rrdtool wants integers for counters.
					# memory is in kb, and a gauge.
					$cpu = int( mean( map { $services{$_}->{hrSWRunPerfCPU} } (@livingpids) ) );
					$memory = mean( map { $services{$_}->{hrSWRunPerfMem} } (@livingpids) );

				  #					NMISNG::Util::dbg("cpu: ".join(" + ",map { $services{$_}->{hrSWRunPerfCPU} } (@livingpids)) ." = $cpu");
				  #					NMISNG::Util::dbg("memory: ".join(" + ",map { $services{$_}->{hrSWRunPerfMem} } (@livingpids)) ." = $memory");

					NMISNG::Util::info(
						"INFO, service $name is up, " . scalar(@livingpids) . " running process(es)" );
				}
			}
			else
			{
				# is the service already down?
				$snmpdown = 1;
			}
		}

		# now the sapi 'scripts' (similar to expect scripts)
		elsif ( $servicetype eq "script" )
		{
			# OMK-3237, use sensible and non-clashing config source:
			# now service_name sets the script file name, temporarily falling back to $service
			my $scriptfn = "$C->{script_root}/". $servicename || $service;
			if (!open(F, $scriptfn))
			{
				NMISNG::Util::dbg("ERROR, can't open script file $scriptfn for $service: $!");
			}
			else
			{
				my $scripttext = join( "", <F> );
				close(F);

				my $timeout = ( $thisservice->{Max_Runtime} > 0 ) ? $thisservice->{Max_Runtime} : 3;

				( $ret, $msg ) = NMISNG::Sapi::sapi( $catchall_data->{host}, $thisservice->{Port}, $scripttext, $timeout );
				NMISNG::Util::dbg("Results of $service is $ret, msg is $msg");
			}
		}

		# 'real' scripts, or more precisely external programs
		# which also covers nagios plugins - https://nagios-plugins.org/doc/guidelines.html
		elsif ( $servicetype =~ /^(program|nagios-plugin)$/ )
		{
			$ret = 0;
			my $svc = $thisservice;
			if ( !$svc->{Program} or !-x $svc->{Program} )
			{
				NMISNG::Util::info("ERROR, service $service defined with no working Program to run!");
				NMISNG::Util::logMsg("ERROR service $service defined with no working Program to run!");
				next;
			}

			# exit codes and output handling differ
			my $flavour_nagios = ( $svc->{Service_Type} eq "nagios-plugin" );

			# check the arguments (if given), substitute node.XYZ values
			my $finalargs;
			if ( $svc->{Args} )
			{
				$finalargs = $svc->{Args};

				# don't touch anything AFTER a node.xyz, and only subst if node.xyz is the first/only thing,
				# or if there's a nonword char before node.xyz.
				$finalargs =~ s/(^|\W)(node\.([a-zA-Z0-9_-]+))/$1$catchall_data->{$3}/g;
				NMISNG::Util::dbg("external program args were $svc->{Args}, now $finalargs");
			}

			my $programexit = 0;

			# save and restore any previously running alarm,
			# but don't bother subtracting the time spent here
			my $remaining = alarm(0);
			NMISNG::Util::dbg("saving running alarm, $remaining seconds remaining");
			my $pid;
			eval {
				my @responses;
				my $svcruntime = defined( $svc->{Max_Runtime} ) && $svc->{Max_Runtime} > 0 ? $svc->{Max_Runtime} : 0;

				local $SIG{ALRM} = sub { die "alarm\n"; };
				alarm($svcruntime) if ($svcruntime);    # setup execution timeout

			# run given program with given arguments and possibly read from it
			# program is disconnected from stdin; stderr goes into a tmpfile and is collected separately for diagnostics
				my $stderrsink = POSIX::tmpnam();    # good enough, no atomic open required
				NMISNG::Util::dbg(      "running external program '$svc->{Program} $finalargs', "
						. ( NMISNG::Util::getbool( $svc->{Collect_Output} ) ? "collecting" : "ignoring" )
						. " output" );
				$pid = open( PRG, "$svc->{Program} $finalargs </dev/null 2>$stderrsink |" );
				if ( !$pid )
				{
					alarm(0) if ($svcruntime);       # cancel any timeout
					NMISNG::Util::info("ERROR, cannot start service program $svc->{Program}: $!");
					NMISNG::Util::logMsg("ERROR: cannot start service program $svc->{Program}: $!");
				}
				else
				{
					@responses = <PRG>;              # always check for output but discard it if not required
					close PRG;
					$programexit = $?;
					alarm(0) if ($svcruntime);       # cancel any timeout

					NMISNG::Util::dbg( "service exit code is " . ( $programexit >> 8 ) );

					# consume and warn about any stderr-output
					if ( -f $stderrsink && -s $stderrsink )
					{
						open( UNWANTED, $stderrsink );
						my $badstuff = join( "", <UNWANTED> );
						chomp($badstuff);
						NMISNG::Util::logMsg(
							"WARNING: Service program $svc->{Program} returned unexpected error output: \"$badstuff\"");
						NMISNG::Util::info("Service program $svc->{Program} returned unexpected error output: \"$badstuff\"");
						close(UNWANTED);
					}
					unlink($stderrsink);

					if ( NMISNG::Util::getbool( $svc->{Collect_Output} ) )
					{
						# nagios has two modes of output *sigh*, |-as-newline separator and real newlines
						# https://nagios-plugins.org/doc/guidelines.html#PLUGOUTPUT
						if ($flavour_nagios)
						{
							# ditch any whitespace around the |
							my @expandedresponses = map { split /\s*\|\s*/ } (@responses);

							@responses = ( $expandedresponses[0] );    # start with the first line, as is
							   # in addition to the | mode, any subsequent lines can carry any number of
							   # 'performance measurements', which are hard to parse out thanks to a fairly lousy format
							for my $perfline ( @expandedresponses[1 .. $#expandedresponses] )
							{
								while ( $perfline =~ /([^=]+=\S+)\s*/g )
								{
									push @responses, $1;
								}
							}
						}

						# now determine how to save the values in question
						for my $idx ( 0 .. $#responses )
						{
							my $response = $responses[$idx];
							chomp $response;

							# the first line is special; it sets the textual status
							if ( $idx == 0 )
							{
								NMISNG::Util::dbg("service status text is \"$response\"");
								$status{status_text} = $response;
								next;
							}

							# normal expectation: values reported are unit-less, ready for final use
							# expectation not guaranteed by nagios
							my ( $k, $v ) = split( /=/, $response, 2 );
							my $rescaledv;

							if ($flavour_nagios)
							{
								# some nagios plugins report multiple metrics, e.g. the check_disk one
								# but the format for passing performance data is pretty ugly
								# https://nagios-plugins.org/doc/guidelines.html#AEN200

								$k = $1 if ( $k =~ /^'(.+)'$/ );    # nagios wants single quotes if a key has spaces

								# a plugin can report levels for warning and crit thresholds
								# and also optionally report possible min and max values;
								my ( $value_with_unit, $lwarn, $lcrit, $lmin, $lmax ) = split( /;/, $v, 5 );

								# any of those could be set to zero
								if ( defined $lwarn or defined $lcrit or defined $lmin or defined $lmax )
								{
									# note that putting this in status, ie. timed_data, isn't quite perfect
									# could go into inventory BUT might change on every poll, hence hard to track in inventory
									$status{limits}->{$k} = {
										warning  => $lwarn,
										critical => $lcrit,
										min      => $lmin,
										max      => $lmax
									};
								}

								# units: s,us,ms = seconds, % percentage, B,KB,MB,TB bytes, c a counter
								if ( $value_with_unit =~ /^([0-9\.]+)(s|ms|us|%|B|KB|MB|GB|TB|c)$/ )
								{
									my ( $numericval, $unit ) = ( $1, $2 );
									NMISNG::Util::dbg("performance data for label '$k': raw value '$value_with_unit'");

									# imperfect storage location, pit vs inventory
									$status{units}->{$k} = $unit;    # keep track of the input unit
									$v = $numericval;

									# massage the value into a number for rrd
									my %factors = (
										'ms' => 1e-3,
										'us' => 1e-6,
										'KB' => 1e3,
										'MB' => 1e6,
										'GB' => 1e9,
										'TB' => 1e12
									);                                           # decimal here
									$rescaledv = $v * $factors{$unit} if ( defined $factors{$unit} );
								}
							}
							NMISNG::Util::dbg( "collected response '$k' value '$v'"
									. ( defined $rescaledv ? " rescaled '$rescaledv'" : "" ) );

							# for rrd storage, but only numeric values can be stored!
							# k needs sanitizing for rrd: only a-z0-9_ allowed
							my $rrdsafekey = $k;
							$rrdsafekey =~ s/[^a-zA-Z0-9_]/_/g;
							$rrdsafekey = substr( $rrdsafekey, 0, 19 );
							$Val{$rrdsafekey} = {
								value => defined($rescaledv) ? $rescaledv : $v,
								option => "GAUGE,U:U,$serviceheartbeat"
							};

							# record the relationship between extra readings and the DS names they're stored under
							# imperfect storage location, pit vs inventory
							$status{ds}->{$k} = $rrdsafekey;

							if ( $k eq "responsetime" )    # response time is handled specially
							{
								$responsetime = NMISNG::Util::numify($v);
							}
							else
							{
								$status{extra}->{$k} = NMISNG::Util::numify($v);
							}

						}
					}
				}
			};

			if ( $@ and $@ eq "alarm\n" )
			{
				kill('TERM', $pid);    # get rid of the service tester, it ran over time...
				NMISNG::Util::info(
					"ERROR, service program $svc->{Program} exceeded Max_Runtime of $svc->{Max_Runtime}s, terminated.");
				NMISNG::Util::logMsg(
					"ERROR: service program $svc->{Program} exceeded Max_Runtime of $svc->{Max_Runtime}s, terminated.");
				$ret = 0;
				kill( "KILL", $pid );
			}
			else
			{
				# now translate the exit code into a service value (0 dead .. 100 perfect)
				# if the external program died abnormally we treat this as 0=dead.
				if ( WIFEXITED($programexit) )
				{
					$programexit = WEXITSTATUS($programexit);
					NMISNG::Util::dbg("external program terminated with exit code $programexit");

					# nagios knows four states: 0 ok, 1 warning, 2 critical, 3 unknown
					# we'll map those to 100, 50 and 0 for everything else.
					if ($flavour_nagios)
					{
						$ret = $programexit == 0 ? 100 : $programexit == 1 ? 50 : 0;
					}
					else
					{
						$ret = $programexit > 100 ? 100 : $programexit;
					}
				}
				else
				{
					NMISNG::Util::logMsg("WARNING: service program $svc->{Program} terminated abnormally!");
					$ret = 0;
				}
			}
			alarm($remaining) if ($remaining);    # restore previously running alarm
			NMISNG::Util::dbg("restored alarm, $remaining seconds remaining");
		}    # end of program/nagios-plugin service type
		else
		{
			# no service type found
			NMISNG::Util::logMsg("ERROR: skipping service $service, invalid service type!");
			next;    # just do the next one - no alarms
		}

		# let external programs set the responsetime if so desired
		$responsetime = $timer->elapTime if ( !defined $responsetime );
		$status{responsetime} = NMISNG::Util::numify($responsetime);
		my $thisrun = time;

		# external programs return 0..100 directly, rest has 0..1
		my $serviceValue = ( $servicetype =~ /^(program|nagios-plugin)$/ ) ? $ret : $ret * 100;
		$status{status} = NMISNG::Util::numify($serviceValue);

		#NMISNG::Util::logMsg("Updating $node Service, $name, $ret, gotMemCpu=$gotMemCpu");
		$V->{system}{"${service}_title"} = "Service $name";
		$V->{system}{"${service}_value"} = $serviceValue == 100 ? 'running' : $serviceValue > 0 ? "degraded" : 'down';
		$V->{system}{"${service}_color"} = $serviceValue == 100 ? 'white' : $serviceValue > 0 ? "orange" : 'red';

		$V->{system}{"${service}_responsetime"} = $responsetime;
		$V->{system}{"${service}_cpumem"} = $gotMemCpu ? 'true' : 'false';

		# now points to the per-service detail view. note: no widget info a/v at this time!
		delete $V->{system}->{"${service}_gurl"};
		$V->{system}{"${service}_url"}
			= "$C->{'<cgi_url_base>'}/services.pl?conf=$C->{conf}&act=details&node="
			. uri_escape($node)
			. "&service="
			. uri_escape($service);

		# let's raise or clear service events based on the status
		if ($snmpdown)    # only set IFF this is an snmp-based service AND snmp is broken/down.
		{
			NMISNG::Util::dbg("$servicetype $name is not checked, snmp is down");
			$V->{system}{"${service}_value"} = 'unknown';
			$V->{system}{"${service}_color"} = 'gray';
			$serviceValue                    = '';
		}
		elsif ( $serviceValue == 100 )    # service is fully up
		{
			NMISNG::Util::dbg("$servicetype $name is available ($serviceValue)");

			# all perfect, so we need to clear both degraded and down events
			Compat::NMIS::checkEvent(
				sys     => $S,
				event   => "Service Down",
				level   => "Normal",
				element => $name,
				details => ( $status{status_text} || "" )
			);

			Compat::NMIS::checkEvent(
				sys     => $S,
				event   => "Service Degraded",
				level   => "Warning",
				element => $name,
				details => ( $status{status_text} || "" )
			);
		}
		elsif ( $serviceValue > 0 )    # service is up but degraded
		{
			NMISNG::Util::dbg("$servicetype $name is degraded ($serviceValue)");

			# is this change towards the better or the worse?
			# we clear the down (if one exists) as it's not totally dead anymore...
			Compat::NMIS::checkEvent(
				sys     => $S,
				event   => "Service Down",
				level   => "Fatal",
				element => $name,
				details => ( $status{status_text} || "" )
			);

			# ...and create a degraded
			Compat::NMIS::notify(
				sys     => $S,
				event   => "Service Degraded",
				level   => "Warning",
				element => $name,
				details => ( $status{status_text} || "" ),
				context => {type => "service"}
			);
		}
		else    # Service is down
		{
			NMISNG::Util::dbg("$servicetype $name is down");

			# clear the degraded event
			# but don't just eventDelete, so that no state engines downstream of nmis get confused!
			Compat::NMIS::checkEvent(
				sys     => $S,
				event   => "Service Degraded",
				level   => "Warning",
				element => $name,
				details => ( $status{status_text} || "" )
			);

			# and now create a down event
			Compat::NMIS::notify(
				sys     => $S,
				event   => "Service Down",
				level   => "Fatal",
				element => $name,
				details => ( $status{status_text} || "" ),
				context => {type => "service"}
			);
		}

		# figure out which graphs to offer
		# every service has these; cpu+mem optional, and totally custom extra are possible, too.
		my @servicegraphs = (qw(service service-response));

		# save result for availability history - one rrd file per service per node
		$Val{service} = {
			value  => $serviceValue,
			option => "GAUGE,0:100,$serviceheartbeat"
		};

		$cpu = -$cpu if ( $cpu < 0 );
		$Val{responsetime} = {
			value  => $responsetime,                  # might be a NOP
			option => "GAUGE,0:U,$serviceheartbeat"
		};
		if ($gotMemCpu)
		{
			$Val{cpu} = {
				value  => $cpu,
				option => "COUNTER,U:U,$serviceheartbeat"
			};
			$Val{memory} = {
				value  => $memory,
				option => "GAUGE,U:U,$serviceheartbeat"
			};

			# cpu is a counter, need to get the delta(counters)/period from rrd
			$status{memory} = NMISNG::Util::numify($memory);

			# fixme: should we omit the responsetime graph for snmp-based services??
			# it doesn't say too much about the service itself...
			push @servicegraphs, (qw(service-mem service-cpu));
		}

		my $fullpath = $S->create_update_rrd( data => \%Val,
																					type => "service",
																					item => $service,
																					inventory => $inventory );
		NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() ) if (!$fullpath);

		# known/available graphs go into storage, as subconcept => rrd => fn
		# rrd file for this should now be present and a/v, we want relative path,
		# not $fullpath as returned by create_update_rrd...
		my $dbname = $inventory->find_subconcept_type_storage(subconcept => "service",
																													type => "rrd");

		# check what custom graphs exist for this service
		# file naming scheme: Graph-service-custom-<servicename>-<sometag>.nmis,
		# and servicename gets lowercased and reduced to [a-z0-9\._]
		# note: this schema is known here, and in cgi-bin/services.pl
		my $safeservice = lc($service);
		$safeservice =~ s/[^a-z0-9\._]//g;

		opendir( D, $C->{'<nmis_models>'} ) or die "cannot open models dir: $!\n";
		my @cands = grep( /^Graph-service-custom-$safeservice-[a-z0-9\._-]+\.nmis$/, readdir(D) );
		closedir(D);

		map { s/^Graph-(service-custom-[a-z0-9\._]+-[a-z0-9\._-]+)\.nmis$/$1/; } (@cands);
		NMISNG::Util::dbg( "found custom graphs for service $service: " . join( " ", @cands ) ) if (@cands);

		push @servicegraphs, @cands;

		# now record the right storage subconcept-to-filename set in the inventory
		my $knownones = $inventory->storage; # there's at least the main subconcept 'service'
		for my $maybegone (keys %$knownones)
		{
			next if ($maybegone eq "service" # that must remain
							 or grep($_ eq $maybegone, @servicegraphs)); # or a known one
			# ditch
			$inventory->set_subconcept_type_storage(type => "rrd", subconcept => $maybegone, data => undef);
		}
		for my $maybenew (@servicegraphs)
		{
			# add or update
			$inventory->set_subconcept_type_storage(type => "rrd", subconcept => $maybenew, data => $dbname);
		}

		if ($gotMemCpu)
		{
			# cpu is a counter! need to pull the most recent cpu value from timed data, and compute the delta(counters)/period
			# to do that we need to either query rrd (inefficient) or store both cpu_raw and cpu (cooked, average centiseconds per real second)
			my $newest = $inventory->get_newest_timed_data();

			# autovivifies but no problem
			my $prevcounter = ($newest->{success} && exists($newest->{data}->{service}->{cpu_raw}))? $newest->{data}->{service}->{cpu_raw} : 0;

			$status{cpu_raw} = $cpu;	# the counter
			# never done or done just now? zero
			$status{cpu} = ($lastrun && $thisrun != $lastrun)? (($cpu - $prevcounter) / ($thisrun - $lastrun)) : 0;
		}

		# update the inventory data
		my $invdata = $inventory->data;
		$invdata->{last_run} = $thisrun;
		$inventory->data($invdata);
		$inventory->enabled(1);
		$inventory->historic(0);

		# TODO: enable this? needs to know some things to show potentially
		$inventory->data_info( subconcept => 'service', enabled => 0 );
		( my $op, $error ) = $inventory->save();
		NMISNG::Util::logMsg("ERROR: service status saving inventory failed: $error") if ($error);

		# and add a new point-in-time record for this service
		# must provide datasets info as status info is pretty deep
		my %dspresent = (status => 1,  responsetime => 1 ); # standard
		# optional semi-standard
		for my $maybe (qw(memory cpu))
		{
			$dspresent{$maybe} = 1  if (exists $status{$maybe});
		}

		# extras collected from a program
		map { $dspresent{$_} =1 } (values %{$status{ds}})
				if (ref($status{ds}) eq "HASH");

		$error = $inventory->add_timed_data(data => \%status,
																				derived_data => {},
																				time => NMISNG::Util::numify($thisrun),
																				datasets => { "service" => \%dspresent },
																				subconcept => "service" );
		NMISNG::Util::logMsg("ERROR: service timed data saving failed: $error") if ($error);
	}

	NMISNG::Util::info("Finished");
}    # end runServices

#=========================================================================================

# fixme: the CVARn evaluation function should be integrated into and handled by sys::parseString
# fixme: this function works ONLY for indexed/systemhealth sections!
sub runAlerts
{
	my %args = @_;
	my $S    = $args{sys};
	my $M    = $S->mdl;
	my $CA   = $S->alerts;

	my $result;
	my %Val;
	my %ValMeM;
	my $hrCpuLoad;

	NMISNG::Util::info("Running Custom Alerts for node $S->{name}");

	foreach my $sect ( keys %{$CA} )
	{
		# only use inventory that already exists
		my $ids = $S->nmisng_node->get_inventory_ids( concept => $sect );
		NMISNG::Util::info("Custom Alerts for $sect");
		foreach my $id ( @$ids )
		{
			my ($inventory,$error_message) = $S->nmisng_node->inventory( _id => $id );
			$S->nmisng->log->error("Failed to get inventory, concept:$sect, _id:$id, error_message:$error_message") && next
				if(!$inventory);
			my $data = $inventory->data();
			my $index = $data->{index};
			foreach my $alrt ( keys %{$CA->{$sect}} )
			{
				if ( defined( $CA->{$sect}{$alrt}{control} ) and $CA->{$sect}{$alrt}{control} ne '' )
				{
					my $control_result = $S->parseString(
						string => "($CA->{$sect}{$alrt}{control}) ? 1:0",
						index  => $index,
						type   => $sect,
						sect   => $sect,
						extras => $data, # <- this isn't really needed, it's going to look this up for cvars anyway
						eval => 1
					);
					NMISNG::Util::dbg("control_result sect=$sect index=$index control_result=$control_result");
					next if not $control_result;
				}

				# perform CVARn substitution for these two types of ops
				NMISNG::Util::TODO("Why can't this run through parseString?");
				if ( $CA->{$sect}{$alrt}{type} =~ /^(test$|threshold)/ )
				{
					my ( $test, $value, $alert, $test_value, $test_result );

					# do this for test and value
					for my $thingie ( ['test', \$test_result], ['value', \$test_value] )
					{
						my ( $key, $target ) = @$thingie;

						my $origexpr = $CA->{$sect}{$alrt}{$key};
						my ( $rebuilt, @CVAR );

						# rip apart expression, rebuild it with var substitutions
						while ( $origexpr =~ s/^(.*?)(CVAR(\d)=(\w+);|\$CVAR(\d))// )
						{
							$rebuilt .= $1;    # the unmatched, non-cvar stuff at the begin
							my ( $varnum, $decl, $varuse ) = ( $3, $4, $5 );    # $2 is the whole |-group

							if ( defined $varnum )                              # cvar declaration
							{
								$CVAR[$varnum] = $data->{$decl};
								NMISNG::Util::logMsg(   "ERROR: CVAR$varnum references unknown object \"$decl\" in \""
										. $CA->{$sect}{$alrt}{$key}
										. '"' )
									if ( !exists $data->{$decl} );
							}
							elsif ( defined $varuse )                           # cvar use
							{
								NMISNG::Util::logMsg(   "ERROR: CVAR$varuse used but not defined in test \""
										. $CA->{$sect}{$alrt}{$key}
										. '"' )
									if ( !exists $CVAR[$varuse] );

								$rebuilt .= $CVAR[$varuse];                     # sub in the actual value
							}
							else                                                # shouldn't be reached, ever
							{
								NMISNG::Util::logMsg( "ERROR: CVAR parsing failure for \"" . $CA->{$sect}{$alrt}{$key} . '"' );
								$rebuilt = $origexpr = '';
								last;
							}
						}
						$rebuilt .= $origexpr;    # and the non-CVAR-containing remainder.

						$$target = eval { eval $rebuilt; };
						NMISNG::Util::dbg("substituted $key sect=$sect index=$index, orig=\""
								. $CA->{$sect}{$alrt}{$key}
								. "\", expr=\"$rebuilt\", result=$$target",
							2
						);
					}

					if ( $test_value =~ /^[\+-]?\d+\.\d+$/ )
					{
						$test_value = sprintf( "%.2f", $test_value );
					}

					my $level = $CA->{$sect}{$alrt}{level};

					# check the thresholds
					# fixed thresholds to fire at level not one off, and threshold falling was just wrong.
					if ( $CA->{$sect}{$alrt}{type} =~ /^threshold/ )
					{
						if ( $CA->{$sect}{$alrt}{type} eq "threshold-rising" )
						{
							if ( $test_value <= $CA->{$sect}{$alrt}{threshold}{Normal} )
							{
								$test_result = 0;
								$level       = "Normal";
							}
							else
							{
								my @levels = qw(Fatal Critical Major Minor Warning);
								foreach my $lvl (@levels)
								{
									if ( $test_value >= $CA->{$sect}{$alrt}{threshold}{$lvl} )
									{
										$test_result = 1;
										$level       = $lvl;
										last;
									}
								}
							}
						}
						elsif ( $CA->{$sect}{$alrt}{type} eq "threshold-falling" )
						{
							if ( $test_value >= $CA->{$sect}{$alrt}{threshold}{Normal} )
							{
								$test_result = 0;
								$level       = "Normal";
							}
							else
							{
								my @levels = qw(Warning Minor Major Critical Fatal);
								foreach my $lvl (@levels)
								{
									if ( $test_value <= $CA->{$sect}{$alrt}{threshold}{$lvl} )
									{
										$test_result = 1;
										$level       = $lvl;
										last;
									}
								}
							}
						}
						NMISNG::Util::info(
							"alert result: Normal=$CA->{$sect}{$alrt}{threshold}{Normal} test_value=$test_value test_result=$test_result level=$level",
							2
						);
					}

				   # and now save the result, for both tests and thresholds (source of level is the only difference)
					$alert->{type}  = $CA->{$sect}{$alrt}{type};    # threshold or test or whatever
					$alert->{test}  = $CA->{$sect}{$alrt}{value};
					$alert->{name}  = $S->{name};                   # node name, not much good here
					$alert->{unit}  = $CA->{$sect}{$alrt}{unit};
					$alert->{event} = $CA->{$sect}{$alrt}{event};
					$alert->{level} = $level;
					$alert->{ds}          = $data->{ $CA->{$sect}{$alrt}{element} };
					$alert->{test_result} = $test_result;
					$alert->{value}       = $test_value;

					# also ensure that section, index and alertkey are known for the event context
					$alert->{section} = $sect;
					$alert->{alert}   = $alrt;                      # the key, good enough
					$alert->{index}   = $index;

					push( @{$S->{alerts}}, $alert );
				}
			}
		}

	}

	processAlerts( S => $S );

	NMISNG::Util::info("Finished");
}    # end runAlerts

# check model sections (but only under sys!), look for 'check' properties,
# and if a known check type is seen, run the appropriate function
# args: sys
# returns: nothing
sub runCheckValues
{
	my %args = @_;
	my $S    = $args{sys};
	my $M    = $S->mdl;
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	my $C = NMISNG::Util::loadConfTable();

	if ( NMISNG::Util::getbool( $catchall_data->{nodedown} ) )    #  don't bother with dead nodes
	{
		NMISNG::Util::dbg("Node $S->{name} is down, not looking for check values");
		return;
	}

	for my $sect ( keys %{$M->{system}->{sys}} )
	{
		if ( my $control = $M->{system}{sys}{$sect}{control} )    # check if skipped by control
		{
			NMISNG::Util::dbg( "control=$control found for section=$sect", 2 );
			if ( !$S->parseString( string => "($control) ? 1:0", sect => $sect, eval => 1 ) )
			{
				NMISNG::Util::dbg("checkvalues of section $sect skipped by control=$control");
				next;
			}
			my $thissection = $M->{system}->{sys}->{$sect};

			for my $source (qw(wmi snmp))
			{
				next if ( ref( $thissection->{$source} ) ne "HASH" );

				for my $attr ( keys %{$thissection->{$source}} )
				{
					my $thisattr = $thissection->{$source}->{$attr};
					if ( my $checktype = $thisattr->{check} )
					{
						if ( $checktype eq 'checkPower' )
						{
							checkPower( sys => $S, attr => $attr );
						}
						else
						{
							NMISNG::Util::logMsg(
								"ERROR ($S->{name}) unknown check method=$checktype in section $sect, source $source");
						}
					}
				}
			}
		}
	}
	NMISNG::Util::dbg("Finished");
}

# create event: node has <something> down, or clear said event (and state)
# args: sys, type (both required), details (optional),
# up (optional, set to clear event, default is create)
#
# currently understands snmp, wmi, node (=the whole node)
# also updates <something>down flag in node info
#
# returns: nothing
sub HandleNodeDown
{
	my %args = @_;
	my ( $S, $typeofdown, $details, $goingup ) = @args{"sys", "type", "details", "up"};
	return if ( ref($S) ne "NMISNG::Sys" or $typeofdown !~ /^(snmp|wmi|node)$/ );
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	$goingup = NMISNG::Util::getbool($goingup);

	my %eventnames = (
		'snmp' => "SNMP Down",
		'wmi'  => "WMI Down",
		'node' => "Node Down"
	);
	my $eventname = $eventnames{$typeofdown};
	$details ||= "$typeofdown error";

	my $eventfunc = ( $goingup ? \&Compat::NMIS::checkEvent : \&Compat::NMIS::notify );
	&$eventfunc(
		sys     => $S,
		event   => $eventname,
		element => '',
		details => $details,
		level   => ( $goingup ? 'Normal' : undef ),
		context => {type => "node"}
	);

	$catchall_data->{"${typeofdown}down"} = $goingup ? 'false' : 'true';

	return;
}


# performs various node health status checks
# optionally! updates rrd
# args: sys, delayupdate (default: 0),
# if delayupdate is set, this DOES NOT update the
#type 'health' rrd (to be done later, with total polltime)
# returns: reachability data (hashref)
sub runReach
{
	my %args           = @_;
	my $S              = $args{sys};                      # system object
	my $donotupdaterrd = NMISNG::Util::getbool( $args{delayupdate} );

	my $RI = $S->reach;                                   # reach info
	my $C  = NMISNG::Util::loadConfTable();
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	my $cpuWeight;
	my $diskWeight;
	my $memWeight;
	my $swapWeight = 0;
	my $responseWeight;
	my $interfaceWeight;
	my $intf;
	my $inputUtil;
	my $outputUtil;
	my $totalUtil;
	my $reportStats;
	my @tmparray;
	my @tmpsplit;
	my %util;
	my $intcount;
	my $intsummary;
	my $intWeight;
	my $index;

	my $reachabilityHealth = 0;
	my $availabilityHealth = 0;
	my $responseHealth     = 0;
	my $cpuHealth          = 0;

	my $memHealth  = 0;
	my $intHealth  = 0;
	my $swapHealth = 0;
	my $diskHealth = 0;

	my $reachabilityMax = 100 * $C->{weight_reachability};
	my $availabilityMax = 100 * $C->{weight_availability};
	my $responseMax     = 100 * $C->{weight_response};
	my $cpuMax          = 100 * $C->{weight_cpu};
	my $memMax          = 100 * $C->{weight_mem};
	my $intMax          = 100 * $C->{weight_int};

	my $swapMax = 0;
	my $diskMax = 0;

	my %reach;

	NMISNG::Util::info("Starting node $S->{name}, type=$catchall_data->{nodeType}");

	# Math hackery to convert Foundry CPU memory usage into appropriate values
	$RI->{memused} = ( $RI->{memused} - $RI->{memfree} ) if $catchall_data->{nodeModel} =~ /FoundrySwitch/;

	if ( $catchall_data->{nodeModel} =~ /Riverstone/ )
	{
		# Math hackery to convert Riverstone CPU memory usage into appropriate values
		$RI->{memfree} = ( $RI->{memfree} - $RI->{memused} );
		$RI->{memused} = $RI->{memused} * 16;
		$RI->{memfree} = $RI->{memfree} * 16;
	}

	if ( $RI->{memfree} == 0 or $RI->{memused} == 0 )
	{
		$RI->{mem} = 100;
	}
	else
	{
		#'hrSwapMemFree' => 4074844160,
		#'hrSwapMemUsed' => 220114944,
		my $mainMemWeight = 1;
		my $extraMem      = 0;

		if (    defined $RI->{hrSwapMemFree}
			and defined $RI->{hrSwapMemUsed}
			and $RI->{hrSwapMemFree}
			and $RI->{hrSwapMemUsed} )
		{
			$RI->{swap} = ( $RI->{hrSwapMemFree} * 100 ) / ( $RI->{hrSwapMemUsed} + $RI->{hrSwapMemFree} );
		}
		else
		{
			$RI->{swap} = 0;
		}

		# calculate mem
		if ( $RI->{memfree} > 0 and $RI->{memused} > 0 )
		{
			$RI->{mem} = ( $RI->{memfree} * 100 ) / ( $RI->{memused} + $RI->{memfree} );
		}
		else
		{
			$RI->{mem} = "U";
		}
	}

	# copy stashed results (produced by runPing and getnodeinfo)
	my $pingresult = $RI->{pingresult};
	$reach{responsetime} = $RI->{pingavg};
	$reach{loss}         = $RI->{pingloss};

	my $snmpresult = $RI->{snmpresult};

	$reach{cpu} = $RI->{cpu};
	$reach{mem} = $RI->{mem};
	if ( $RI->{swap} )
	{
		$reach{swap} = $RI->{swap};
	}
	$reach{disk} = 0;
	if ( defined $RI->{disk} and $RI->{disk} > 0 )
	{
		$reach{disk} = $RI->{disk};
	}
	$reach{operStatus} = $RI->{operStatus};
	$reach{operCount}  = $RI->{operCount};

	# number of interfaces
	$reach{intfTotal}   = $catchall_data->{intfTotal} eq 0 ? 'U' : $catchall_data->{intfTotal};    # from run update
	$reach{intfCollect} = $catchall_data->{intfCollect};                                        # from run update
	$reach{intfUp}      = $RI->{intfUp} ne '' ? $RI->{intfUp} : 0;                           # from run collect
	$reach{intfColUp}   = $RI->{intfColUp};                                                  # from run collect

# new option to set the interface availability to 0 (zero) when node is Down, default is "U" config interface_availability_value_when_down
	my $intAvailValueWhenDown
		= defined $C->{interface_availability_value_when_down} ? $C->{interface_availability_value_when_down} : "U";
	NMISNG::Util::dbg("availability using interface_availability_value_when_down=$C->{interface_availability_value_when_down} intAvailValueWhenDown=$intAvailValueWhenDown"
	);

	# Things which don't do collect get 100 for availability
	if ( $reach{availability} eq "" and !NMISNG::Util::getbool( $catchall_data->{collect} ) )
	{
		$reach{availability} = "100";
	}
	elsif ( $reach{availability} eq "" ) { $reach{availability} = $intAvailValueWhenDown; }

	my ( $outage, undef ) = Compat::NMIS::outageCheck( node => $S->{node}, time => time() );
	NMISNG::Util::dbg("Outage for $S->{name} is $outage");

	# Health should actually reflect a combination of these values
	# ie if response time is high health should be decremented.
	if ( $pingresult == 100 and $snmpresult == 100 )
	{

		$reach{reachability} = 100;
		if ( $reach{operCount} > 0 )
		{
			$reach{availability} = sprintf( "%.2f", $reach{operStatus} / $reach{operCount} );
		}

		if ( $reach{reachability} > 100 ) { $reach{reachability} = 100; }
		( $reach{responsetime}, $responseWeight ) = weightResponseTime( $reach{responsetime} );

		if ( NMISNG::Util::getbool( $catchall_data->{collect} ) and $reach{cpu} ne "" )
		{
			if    ( $reach{cpu} <= 10 )  { $cpuWeight = 100; }
			elsif ( $reach{cpu} <= 20 )  { $cpuWeight = 90; }
			elsif ( $reach{cpu} <= 30 )  { $cpuWeight = 80; }
			elsif ( $reach{cpu} <= 40 )  { $cpuWeight = 70; }
			elsif ( $reach{cpu} <= 50 )  { $cpuWeight = 60; }
			elsif ( $reach{cpu} <= 60 )  { $cpuWeight = 50; }
			elsif ( $reach{cpu} <= 70 )  { $cpuWeight = 35; }
			elsif ( $reach{cpu} <= 80 )  { $cpuWeight = 20; }
			elsif ( $reach{cpu} <= 90 )  { $cpuWeight = 10; }
			elsif ( $reach{cpu} <= 100 ) { $cpuWeight = 1; }

			if ( $reach{disk} )
			{
				if    ( $reach{disk} <= 10 )  { $diskWeight = 100; }
				elsif ( $reach{disk} <= 20 )  { $diskWeight = 90; }
				elsif ( $reach{disk} <= 30 )  { $diskWeight = 80; }
				elsif ( $reach{disk} <= 40 )  { $diskWeight = 70; }
				elsif ( $reach{disk} <= 50 )  { $diskWeight = 60; }
				elsif ( $reach{disk} <= 60 )  { $diskWeight = 50; }
				elsif ( $reach{disk} <= 70 )  { $diskWeight = 35; }
				elsif ( $reach{disk} <= 80 )  { $diskWeight = 20; }
				elsif ( $reach{disk} <= 90 )  { $diskWeight = 10; }
				elsif ( $reach{disk} <= 100 ) { $diskWeight = 1; }

				NMISNG::Util::dbg("Reach for Disk disk=$reach{disk} diskWeight=$diskWeight");
			}

			# Very aggressive swap weighting, 11% swap is pretty healthy.
			if ( $reach{swap} )
			{
				if    ( $reach{swap} >= 95 ) { $swapWeight = 100; }
				elsif ( $reach{swap} >= 89 ) { $swapWeight = 95; }
				elsif ( $reach{swap} >= 70 ) { $swapWeight = 90; }
				elsif ( $reach{swap} >= 50 ) { $swapWeight = 70; }
				elsif ( $reach{swap} >= 30 ) { $swapWeight = 50; }
				elsif ( $reach{swap} >= 10 ) { $swapWeight = 30; }
				elsif ( $reach{swap} >= 0 )  { $swapWeight = 1; }

				NMISNG::Util::dbg("Reach for Swap swap=$reach{swap} swapWeight=$swapWeight");
			}

			if    ( $reach{mem} >= 40 ) { $memWeight = 100; }
			elsif ( $reach{mem} >= 35 ) { $memWeight = 90; }
			elsif ( $reach{mem} >= 30 ) { $memWeight = 80; }
			elsif ( $reach{mem} >= 25 ) { $memWeight = 70; }
			elsif ( $reach{mem} >= 20 ) { $memWeight = 60; }
			elsif ( $reach{mem} >= 15 ) { $memWeight = 50; }
			elsif ( $reach{mem} >= 10 ) { $memWeight = 40; }
			elsif ( $reach{mem} >= 5 )  { $memWeight = 25; }
			elsif ( $reach{mem} >= 0 )  { $memWeight = 1; }
		}
		elsif ( NMISNG::Util::getbool( $catchall_data->{collect} ) and $catchall_data->{nodeModel} eq "Generic" )
		{
			$cpuWeight = 100;
			$memWeight = 100;
			### ehg 16 sep 2002 also make interface aavilability 100% - I dont care about generic switches interface health !
			$reach{availability} = 100;
		}
		else
		{
			$cpuWeight = 100;
			$memWeight = 100;
			### 2012-12-13 keiths, removed this stoopid line as availability was allways 100%
			### $reach{availability} = 100;
		}

		# Added little fix for when no interfaces are collected.
		if ( $reach{availability} !~ /\d+/ )
		{
			$reach{availability} = "100";
		}

		# Makes 3Com memory health weighting always 100, and CPU, and Interface availibility
		if ( $catchall_data->{nodeModel} =~ /SSII 3Com/i )
		{
			$cpuWeight           = 100;
			$memWeight           = 100;
			$reach{availability} = 100;

		}

		# Makes CatalystIOS memory health weighting always 100.
		# Add Baystack and Accelar
		if ( $catchall_data->{nodeModel} =~ /CatalystIOS|Accelar|BayStack|Redback|FoundrySwitch|Riverstone/i )
		{
			$memWeight = 100;
		}

		NMISNG::Util::info(
			"REACH Values: reachability=$reach{reachability} availability=$reach{availability} responsetime=$reach{responsetime}"
		);
		NMISNG::Util::info("REACH Values: CPU reach=$reach{cpu} weight=$cpuWeight, MEM reach=$reach{mem} weight=$memWeight");

		if ( NMISNG::Util::getbool( $catchall_data->{collect} ) and defined $S->{mdl}{interface}{nocollect}{ifDescr} )
		{
			NMISNG::Util::dbg("Getting Interface Utilisation Health");
			$intcount   = 0;
			$intsummary = 0;
			my $ids = $S->nmisng_node->get_inventory_ids( concept => 'interface', filter => { enabled => 1, historic => 0 } );

			# get all collected interfaces
			foreach my $id (@$ids)
			{
				my ($intf_inventory,$error) = $S->nmisng_node->inventory( _id => $id );
				my $data = $intf_inventory->data();
				my $index = $data->{index};

				# Get the link availability from the local node!!!
				my $util = Compat::NMIS::getSummaryStats(
					sys   => $S,
					type  => "interface",
					start => "-15 minutes",
					end   => time(),
					index => $index
				);
				if ( $util->{$index}{inputUtil} eq 'NaN' or $util->{$index}{outputUtil} eq 'NaN' )
				{
					NMISNG::Util::dbg("SummaryStats for interface=$index of node $S->{name} skipped because value is NaN"
					);
					next;
				}

				# lets make the interface metric the largest of input or output
				my $intUtil = $util->{$index}{inputUtil};
				if ( $intUtil < $util->{$index}{outputUtil} )
				{
					$intUtil = $util->{$index}{outputUtil};
				}

				# only add interfaces with utilisation above metric_int_utilisation_above configuration option
				if ( $intUtil > $C->{'metric_int_utilisation_above'} or $C->{'metric_int_utilisation_above'} eq "" )
				{
					$intsummary = $intsummary + ( 100 - $intUtil );
					++$intcount;
					NMISNG::Util::info(
						"Intf Summary util=$intUtil in=$util->{$index}{inputUtil} out=$util->{$index}{outputUtil} intsumm=$intsummary count=$intcount"
					);
				}

			}    # FOR LOOP
			if ( $intsummary != 0 )
			{
				$intWeight = sprintf( "%.2f", $intsummary / $intcount );
			}
			else
			{
				$intWeight = "NaN";
			}
		}
		else
		{
			$intWeight = 100;
		}

		# if the interfaces are unhealthy and lost stats, whack a 100 in there
		if ( $intWeight eq "NaN" or $intWeight > 100 ) { $intWeight = 100; }

		# Would be cool to collect some interface utilisation bits here.
		# Maybe thresholds are the best way to handle that though.  That
		# would pickup the peaks better.

		# keeping the health values for storing in the RRD
		$reachabilityHealth = ( $reach{reachability} * $C->{weight_reachability} );
		$availabilityHealth = ( $reach{availability} * $C->{weight_availability} );
		$responseHealth     = ( $responseWeight * $C->{weight_response} );
		$cpuHealth          = ( $cpuWeight * $C->{weight_cpu} );
		$memHealth          = ( $memWeight * $C->{weight_mem} );
		$intHealth          = ( $intWeight * $C->{weight_int} );
		$swapHealth         = 0;
		$diskHealth         = 0;

		# the minimum value for health should always be 1
		$reachabilityHealth = 1 if $reachabilityHealth < 1;
		$availabilityHealth = 1 if $availabilityHealth < 1;
		$responseHealth     = 1 if $responseHealth < 1;
		$cpuHealth          = 1 if $cpuHealth < 1;

		# overload the int and mem with swap and disk
		if ( $reach{swap} )
		{
			$memHealth  = ( $memWeight * $C->{weight_mem} ) / 2;
			$swapHealth = ( $swapWeight * $C->{weight_mem} ) / 2;
			$memMax     = 100 * $C->{weight_mem} / 2;
			$swapMax    = 100 * $C->{weight_mem} / 2;

			# the minimum value for health should always be 1
			$memHealth  = 1 if $memHealth < 1;
			$swapHealth = 1 if $swapHealth < 1;
		}

		if ( $reach{disk} )
		{
			$intHealth  = ( $intWeight *  ( $C->{weight_int} / 2 ) );
			$diskHealth = ( $diskWeight * ( $C->{weight_int} / 2 ) );
			$intMax     = 100 * $C->{weight_int} / 2;
			$diskMax    = 100 * $C->{weight_int} / 2;

			# the minimum value for health should always be 1
			$intHealth  = 1 if $intHealth < 1;
			$diskHealth = 1 if $diskHealth < 1;
		}

		# Health is made up of a weighted values:
		### AS 16 Mar 02, implemented weights in nmis.conf
		$reach{health}
			= (   $reachabilityHealth
				+ $availabilityHealth
				+ $responseHealth
				+ $cpuHealth
				+ $memHealth
				+ $intHealth
				+ $diskHealth
				+ $swapHealth );

		NMISNG::Util::info("Calculation of health=$reach{health}");
		if ( lc $reach{health} eq 'nan' )
		{
			NMISNG::Util::dbg("Values Calc. reachability=$reach{reachability} * $C->{weight_reachability}");
			NMISNG::Util::dbg("Values Calc. intWeight=$intWeight * $C->{weight_int}");
			NMISNG::Util::dbg("Values Calc. responseWeight=$responseWeight * $C->{weight_response}");
			NMISNG::Util::dbg("Values Calc. availability=$reach{availability} * $C->{weight_availability}");
			NMISNG::Util::dbg("Values Calc. cpuWeight=$cpuWeight * $C->{weight_cpu}");
			NMISNG::Util::dbg("Values Calc. memWeight=$memWeight * $C->{weight_mem}");
			NMISNG::Util::dbg("Values Calc. swapWeight=$swapWeight * $C->{weight_mem}");
		}
	}

	# the node is collect=false and was pingable
	elsif ( !NMISNG::Util::getbool( $catchall_data->{collect} ) and $pingresult == 100 )
	{
		$reach{reachability} = 100;
		$reach{availability} = 100;
		$reach{intfTotal}    = 'U';
		( $reach{responsetime}, $responseWeight ) = weightResponseTime( $reach{responsetime} );
		$reach{health} = ( $reach{reachability} * 0.9 ) + ( $responseWeight * 0.1 );
	}

	# there is a current outage for this node
	elsif ( ( $pingresult == 0 or $snmpresult == 0 ) and $outage eq 'current' )
	{
		$reach{reachability} = "U";
		$reach{availability} = "U";
		$reach{intfTotal}    = 'U';
		$reach{responsetime} = "U";
		$reach{health}       = "U";
		$reach{loss}         = "U";
	}

	# ping is working but SNMP is Down
	elsif ( $pingresult == 100 and $snmpresult == 0 )
	{
		$reach{reachability} = 80;                       # correct ? is up and degraded
		$reach{availability} = $intAvailValueWhenDown;
		$reach{intfTotal}    = 'U';
		$reach{health}       = "U";
	}

	# node is Down
	else
	{
		NMISNG::Util::dbg("Node is Down using availability=$intAvailValueWhenDown");
		$reach{reachability} = 0;
		$reach{availability} = $intAvailValueWhenDown;
		$reach{responsetime} = "U";
		$reach{intfTotal}    = 'U';
		$reach{health}       = 0;
	}

	NMISNG::Util::dbg("Reachability and Metric Stats Summary");
	NMISNG::Util::dbg("collect=$catchall_data->{collect} (Node table)");
	NMISNG::Util::dbg("ping=$pingresult (normalised)");
	NMISNG::Util::dbg("cpuWeight=$cpuWeight (normalised)");
	NMISNG::Util::dbg("memWeight=$memWeight (normalised)");
	NMISNG::Util::dbg("swapWeight=$swapWeight (normalised)") if $swapWeight;
	NMISNG::Util::dbg("intWeight=$intWeight (100 less the actual total interface utilisation)");
	NMISNG::Util::dbg("diskWeight=$diskWeight");
	NMISNG::Util::dbg("responseWeight=$responseWeight (normalised)");

	NMISNG::Util::info("Reachability KPI=$reachabilityHealth/$reachabilityMax");
	NMISNG::Util::info("Availability KPI=$availabilityHealth/$availabilityMax");
	NMISNG::Util::info("Response KPI=$responseHealth/$responseMax");
	NMISNG::Util::info("CPU KPI=$cpuHealth/$cpuMax");
	NMISNG::Util::info("MEM KPI=$memHealth/$memMax");
	NMISNG::Util::info("Int KPI=$intHealth/$intMax");
	NMISNG::Util::info("Disk KPI=$diskHealth/$diskMax") if $diskHealth;
	NMISNG::Util::info("SWAP KPI=$swapHealth/$swapMax") if $swapHealth;

	NMISNG::Util::info("total number of interfaces=$reach{intfTotal}");
	NMISNG::Util::info("total number of interfaces up=$reach{intfUp}");
	NMISNG::Util::info("total number of interfaces collected=$reach{intfCollect}");
	NMISNG::Util::info("total number of interfaces coll. up=$reach{intfColUp}");

	for $index ( sort keys %reach )
	{
		NMISNG::Util::dbg("$index=$reach{$index}");
	}

	$reach{health} = ( $reach{health} > 100 ) ? 100 : $reach{health};
	my %reachVal;
	$reachVal{reachability}{value} = $reach{reachability};
	$reachVal{availability}{value} = $reach{availability};
	$reachVal{responsetime}{value} = $reach{responsetime};
	$reachVal{health}{value}       = $reach{health};

	$reachVal{reachabilityHealth}{value} = $reachabilityHealth;
	$reachVal{availabilityHealth}{value} = $availabilityHealth;
	$reachVal{responseHealth}{value}     = $responseHealth;
	$reachVal{cpuHealth}{value}          = $cpuHealth;
	$reachVal{memHealth}{value}          = $memHealth;
	$reachVal{intHealth}{value}          = $intHealth;
	$reachVal{diskHealth}{value}         = $diskHealth;
	$reachVal{swapHealth}{value}         = $swapHealth;

	$reachVal{loss}{value}          = $reach{loss};
	$reachVal{intfTotal}{value}     = $reach{intfTotal};
	$reachVal{intfUp}{value}        = $reach{intfTotal} eq 'U' ? 'U' : $reach{intfUp};
	$reachVal{intfCollect}{value}   = $reach{intfTotal} eq 'U' ? 'U' : $reach{intfCollect};
	$reachVal{intfColUp}{value}     = $reach{intfTotal} eq 'U' ? 'U' : $reach{intfColUp};
	$reachVal{reachability}{option} = "gauge,0:100";
	$reachVal{availability}{option} = "gauge,0:100";
	### 2014-03-18 keiths, setting maximum responsetime to 30 seconds.
	$reachVal{responsetime}{option} = "gauge,0:30000";
	$reachVal{health}{option}       = "gauge,0:100";

	$reachVal{reachabilityHealth}{option} = "gauge,0:100";
	$reachVal{availabilityHealth}{option} = "gauge,0:100";
	$reachVal{responseHealth}{option}     = "gauge,0:100";
	$reachVal{cpuHealth}{option}          = "gauge,0:100";
	$reachVal{memHealth}{option}          = "gauge,0:100";
	$reachVal{intHealth}{option}          = "gauge,0:100";
	$reachVal{diskHealth}{option}         = "gauge,0:100";
	$reachVal{swapHealth}{option}         = "gauge,0:100";

	$reachVal{loss}{option}        = "gauge,0:100";
	$reachVal{intfTotal}{option}   = "gauge,0:U";
	$reachVal{intfUp}{option}      = "gauge,0:U";
	$reachVal{intfCollect}{option} = "gauge,0:U";
	$reachVal{intfColUp}{option}   = "gauge,0:U";

	# make sure inventory exists so delayed saves don't have to create it
	my $section = 'health';
	my $inventory = $S->inventory( concept => $section, nolog => 1);
	if( !$inventory )
	{
		my $path = $S->nmisng_node->inventory_path( concept => $section, path_keys => [], data => {} );
		($inventory,my $error) = $S->nmisng_node->inventory(
			concept => $section,
			data => {},
			path => $path,
			path_keys => [],
			create => 1
		);
		$inventory->enabled(1);
		$inventory->historic(0);
		$inventory->data_info( subconcept => 'health', enabled => 1 );
		$inventory->save();
	}

	# update the rrd or leave it to a caller?
	if ( !$donotupdaterrd )
	{
		# goes into catchall/general
		my $db = $S->create_update_rrd( data => \%reachVal, type => "health", inventory => $inventory );    # database name is normally 'reach'
		if ( !$db )
		{
			NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
		}
		else
		{
			my $pit = {};
			my $previous_pit = $inventory->get_newest_timed_data();
			NMISNG::Inventory::parse_rrd_update_data( \%reachVal, $pit, $previous_pit, "health" );
			my $stats = nodeSummaryStats(C => $C,S => $S, inventory => $inventory, catchall_data => $catchall_data);
			my $error = $inventory->add_timed_data( data => $pit, derived_data => $stats, subconcept => "health",
																						time => $catchall_data->{last_poll}, delay_insert => 1 );
			NMISNG::Util::logMsg("ERROR: timed data adding for ". $inventory->concept ." failed: $error") if ($error);
			# $inventory->data($data);
			$inventory->save();
		}
	}
	NMISNG::Util::info("Finished");

	return \%reachVal;
}


# calculate the summary8 and summary16 data like it used to be, this will be stored in the db as
# derived data
# NB: in the future this can be removed, summary8/16 should be calculatable from the PIT data, there
#   really is no need to do this. aggregations or something should be able to pull this off.
sub nodeSummaryStats
{
	my %args = (@_);
	my $S = $args{S};
	my $C = $args{C};
	my $inventory = $args{inventory};
	my $catchall_data = $args{catchall_data};

	my $section = 'health';
	my $metricsFirstPeriod  = $C->{'metric_comparison_first_period'} // "-8 hours";
	my $metricsSecondPeriod	= $C->{'metric_comparison_second_period'} // "-16 hours";

	my $stats8  = Compat::NMIS::getSubconceptStats(
		sys => $S,
		inventory => $inventory,
		subconcept => $section,
		start => $metricsFirstPeriod,
		end => time
	);
	my $stats16 = Compat::NMIS::getSubconceptStats(
		sys => $S,
		inventory => $inventory,
		subconcept => $section,
		start => $metricsSecondPeriod,
		end => $metricsFirstPeriod
	);

	# nodedown isn't needed in summary info anymore
	# $stats8->{nodedown} = 'false';
	# $stats8->{nodedown} = 'true' if ( NMISNG::Util::getbool( $catchall_data->{nodedown} ) );

	# map all stats into one package for derived, don't know if we want to keep it this way
	my %allstats = ();
	map { $allstats{'08_'.$_} = $stats8->{$_} } (keys %$stats8);
	map { $allstats{'16_'.$_} = $stats8->{$_} } (keys %$stats16);
	return \%allstats;
}
#=========================================================================================

# this generates the data for nmis-interfaces.json,
# NOTE: this should not be required for NMISNG
sub getIntfAllInfo
{
	my $index;
	my $tmpDesc;
	my $intHash;
	my %interfaceInfo;

	### 2013-08-30 keiths, restructured to avoid creating and loading large Interface summaries
	if ( NMISNG::Util::getbool( $C->{disable_interfaces_summary} ) )
	{
		NMISNG::Util::logMsg("getIntfAllInfo disabled with disable_interfaces_summary=$C->{disable_interfaces_summary}");
		return;
	}

	NMISNG::Util::dbg("Starting");

	NMISNG::Util::dbg("Getting Interface Info from all nodes");

	my $nmisng = Compat::NMIS::new_nmisng();
	my $node_names = $nmisng->get_node_names();
	# Write a node entry for each node
	foreach my $node_name ( sort @$node_names )
	{
		my $nmisng_node = $nmisng->node( name => $node_name );
		my $configuration = $nmisng_node->configuration;
		if ( NMISNG::Util::getbool( $configuration->{active} ) and NMISNG::Util::getbool( $configuration->{collect} ) )
		{
			# ony grab active interfaces
			my $ids = $nmisng_node->get_inventory_ids(concept => 'interface', filter => { enabled => 1, historic => 0});
			NMISNG::Util::dbg( "ADD node=$node_name", 3 );
			NMISNG::Util::logMsg("INFO empty interface info file of node $node_name") if(!$ids || @$ids < 1);
			foreach my $id ( @$ids )
			{
				my ($inventory,$error_message) = $nmisng_node->inventory( _id => $id );

				$nmisng->log->error("Failed to get inventory, error_message:$error_message") && next
					if(!$inventory);

				my $data = $inventory->data();
				$tmpDesc = &NMISNG::Util::convertIfName( $data->{ifDescr} );

				$intHash = "$node_name-$tmpDesc";

				NMISNG::Util::dbg( "$node_name $tmpDesc hash=$intHash $data->{ifDescr}", 3 );

				if ( $data->{ifDescr} ne "" )
				{
					NMISNG::Util::dbg( "Add node=$node_name interface=$data->{ifDescr}", 2 );
					my $source = $data;
					my $dest = $interfaceInfo{$intHash} ||= {};

					$dest->{node} = $node_name;
					# TODO: revive this if we still need this function
					# $dest->{sysName} = $info->{system}->{sysName};

					for my $copyme (
						qw(ifIndex ifDescr collect real ifType ifSpeed ifAdminStatus
						ifOperStatus ifLastChange Description display_name portModuleIndex portIndex portDuplex portIfIndex
						portSpantreeFastStart vlanPortVlan portAdminSpeed)
						)
					{
						$dest->{$copyme} = $source->{$copyme};
					}

					my $cnt = 1;
					while ( defined( $source->{"ipAdEntAddr$cnt"} ) )
					{
						for my $copymeprefix (qw(ipAdEntAddr ipAdEntNetMask ipSubnet ipSubnetBits))
						{
							my $copyme = $copymeprefix . $cnt;
							$dest->{$copyme} = $source->{$copyme};
						}
						$cnt++;
					}
				}
			}

		}
	}    # foreach $linkname
	     # Write the interface table out.
	NMISNG::Util::dbg("Writing Interface Info from all nodes");
	NMISNG::Util::writeTable( dir => 'var', name => "nmis-interfaces", data => \%interfaceInfo );
	NMISNG::Util::dbg("Finished");
}

#=========================================================================================



#=========================================================================================

sub weightResponseTime
{
	my $rt             = shift;
	my $responseWeight = 0;

	if ( $rt eq "" )
	{
		$rt             = "U";
		$responseWeight = 0;
	}
	elsif ( $rt !~ /^[0-9]/ )
	{
		$rt             = "U";
		$responseWeight = 0;
	}
	elsif ( $rt == 0 )
	{
		$rt             = 1;
		$responseWeight = 100;
	}
	elsif ( $rt >= 1500 ) { $responseWeight = 0; }
	elsif ( $rt >= 1000 ) { $responseWeight = 10; }
	elsif ( $rt >= 900 )  { $responseWeight = 20; }
	elsif ( $rt >= 800 )  { $responseWeight = 30; }
	elsif ( $rt >= 700 )  { $responseWeight = 40; }
	elsif ( $rt >= 600 )  { $responseWeight = 50; }
	elsif ( $rt >= 500 )  { $responseWeight = 60; }
	elsif ( $rt >= 400 )  { $responseWeight = 70; }
	elsif ( $rt >= 300 )  { $responseWeight = 80; }
	elsif ( $rt >= 200 )  { $responseWeight = 90; }
	elsif ( $rt >= 0 )    { $responseWeight = 100; }
	return ( $rt, $responseWeight );
}

#=========================================================================================

### 2011-12-29 keiths, centralising the copy of the remote files from slaves, so others can just load them.
sub nmisMaster
{
	my %args = @_;

	$C->{master_sleep} = 15 if $C->{master_sleep} eq "";

	if ( NMISNG::Util::getbool( $C->{server_master} ) )
	{
		NMISNG::Util::info("Running NMIS Master Functions");

		if ( $C->{master_sleep} or $sleep )
		{
			my $sleepNow = $C->{master_sleep};
			$sleepNow = $sleep if $sleep;
			NMISNG::Util::info("Master is sleeping $sleepNow seconds (waiting for summary updates on slaves)");
			sleep $sleepNow;
		}

		my $ST = Compat::NMIS::loadServersTable();
		for my $srv ( keys %{$ST} )
		{
			## don't process server localhost for opHA2
			next if $srv eq "localhost";

			NMISNG::Util::info("Master, processing Slave Server $srv, $ST->{$srv}{host}");

			NMISNG::Util::dbg("Get loadnodedetails from $srv");
			Compat::Connect::getFileFromRemote(
				server => $srv,
				func   => "loadnodedetails",
				group  => $ST->{$srv}{group},
				format => "text",
				file   => NMISNG::Util::getFileName( file => "$C->{'<nmis_var>'}/nmis-${srv}-Nodes" )
			);

			NMISNG::Util::dbg("Get sumnodetable from $srv");
			Compat::Connect::getFileFromRemote(
				server => $srv,
				func   => "sumnodetable",
				group  => $ST->{$srv}{group},
				format => "text",
				file   => NMISNG::Util::getFileName( file => "$C->{'<nmis_var>'}/nmis-${srv}-nodesum" )
			);

			my @hours = qw(8 16);
			foreach my $hour (@hours)
			{
				my $function = "summary" . $hour . "h";
				NMISNG::Util::dbg("get summary$hour from $srv");
				Compat::Connect::getFileFromRemote(
					server => $srv,
					func   => "summary$hour",
					group  => $ST->{$srv}{group},
					format => "text",
					file   => NMISNG::Util::getFileName( file => "$C->{'<nmis_var>'}/nmis-$srv-$function" )
				);
			}
		}
	}
}

#=========================================================================================

# preload all summary stats - for metric update and dashboard display.
sub nmisSummary
{
	my %args = @_;
	my $update_operations_stamp = $args{update_operations_stamp} // 1;
	my $pollTimer = Compat::Timing->new;

	NMISNG::Util::dbg("Calculating NMIS network stats for cgi cache");
	NMISNG::Util::update_operations_stamp( type => "summary", start => $starttime, stop => undef )
		if ( $type eq "summary" );    # not if part of collect

	### 2014-08-28 keiths, configurable metric periods
	my $metricsFirstPeriod
		= defined $C->{'metric_comparison_first_period'} ? $C->{'metric_comparison_first_period'} : "-8 hours";
	my $metricsSecondPeriod
		= defined $C->{'metric_comparison_second_period'} ? $C->{'metric_comparison_second_period'} : "-16 hours";

	summaryCache(file => 'nmis-summary8h', start => $metricsFirstPeriod, end => time() );
	my $k = summaryCache(
		file  => 'nmis-summary16h',
		start => $metricsSecondPeriod,
		end   => $metricsFirstPeriod
	);

	my $NS = Compat::NMIS::getNodeSummary( C => $C );
	my $file = "nmis-nodesum";
	NMISNG::Util::writeTable( dir => 'var', name => $file, data => $NS );
	NMISNG::Util::dbg("Finished calculating NMIS network stats for cgi cache - wrote $k nodes");
	NMISNG::Util::update_operations_stamp( type => "summary", start => $starttime, stop => Time::HiRes::time() )
		if ( $update_operations_stamp );    # not if part of collect

	if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) )
	{
		my $polltime = $pollTimer->elapTime();
		NMISNG::Util::logMsg("Poll Time: $polltime");
	}
}

sub summaryCache
{
	my %args        = @_;
	my $file        = $args{file};
	my $start       = $args{start};
	my $end         = $args{end};
	my %summaryHash = ();
	my $NT          = Compat::NMIS::loadLocalNodeTable();


	foreach my $node ( keys %{$NT} )
	{
		if ( NMISNG::Util::getbool( $NT->{$node}{active} ) )
		{
			my $S = NMISNG::Sys->new;
			$S->init( name => $node, snmp => 'false' );
			my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

			$summaryHash{$node}{reachable}   = 'NaN';
			$summaryHash{$node}{response}    = 'NaN';
			$summaryHash{$node}{loss}        = 'NaN';
			$summaryHash{$node}{health}      = 'NaN';
			$summaryHash{$node}{available}   = 'NaN';
			$summaryHash{$node}{intfCollect} = 0;
			$summaryHash{$node}{intfColUp}   = 0;
			my $stats;

			if ( $stats = Compat::NMIS::getSummaryStats( sys => $S,
																									 type => "health",
																									 start => $start, end => $end,
																									 index => $node ) )
			{
				%summaryHash = ( %summaryHash, %{$stats} );
			}
			if ( NMISNG::Util::getbool( $catchall_data->{nodedown} ) )
			{
				$summaryHash{$node}{nodedown} = 'true';
			}
			else
			{
				$summaryHash{$node}{nodedown} = 'false';
			}
		}
	}

	NMISNG::Util::writeTable( dir => 'var', name => $file, data => \%summaryHash );

	return ( scalar keys %summaryHash );
}

#=========================================================================================

### Added escalate 0, to allow fast escalation and to implement
### consistent policies for notification.  This also helps to get rid of flapping
### things, ie if escalate0 = 5 then an interface goes down, no alert sent, next
### poll interface goes up and event cancelled!  Downside is a little longer before
### receiving first notification, so it depends on what the support SLA is.

### 11-Nov-11, keiths, update to this, changed the escalation so that through policy you can
### wait for 5 mins or just notify now, so Ecalation0 is 0 seconds, Escalation1 is 300 seconds
### then in Ecalations.xxxx, core devices might notify at Escalation0 while others at Escalation1
sub runEscalate
{
	my %args = @_;

	my $pollTimer = Compat::Timing->new;

	my $C  = NMISNG::Util::loadConfTable();
	my $NT = Compat::NMIS::loadLocalNodeTable();

	my $nmisng = Compat::NMIS::new_nmisng();

	my $outage_time;
	my $planned_outage;
	my $event_hash;
	my %location_data;
	my $time;
	my $escalate;
	my $event_age;
	my $esc_key;
	my $event;
	my $index;
	my $group;
	my $role;
	my $type;
	my $details;
	my @x;
	my $k;
	my $level;
	my $contact;
	my $target;
	my $field;
	my %keyhash;
	my $ifDescr;
	my %msgTable;
	my $serial    = 0;
	my $serial_ns = 0;
	my %seen;


	NMISNG::Util::dbg("Starting");
	NMISNG::Util::update_operations_stamp( type => "escalate", start => $starttime, stop => undef )
		if ( $type eq "escalate" );    # not if part of collect
	                                   # load Contacts table
	my $CT = Compat::NMIS::loadContactsTable();

	# load the escalation policy table
	my $EST = Compat::NMIS::loadEscalationsTable();

	### 2013-08-07 keiths, taking to long when MANY interfaces e.g. > 200,000
	# load the interface file to later check interface collect status.
	#my $II = Compat::NMIS::loadInterfaceInfo();

	my $LocationsTable = Compat::NMIS::loadLocationsTable();

	### keiths, work around for extra tables.
	my $ServiceStatusTable;
	my $useServiceStatusTable = 0;
	if ( Compat::NMIS::tableExists('ServiceStatus') )
	{
		$ServiceStatusTable    = Compat::NMIS::loadGenericTable('ServiceStatus');
		$useServiceStatusTable = 1;
	}

	my $BusinessServicesTable;
	my $useBusinessServicesTable = 0;
	if ( Compat::NMIS::tableExists('BusinessServices') )
	{
		$BusinessServicesTable    = Compat::NMIS::loadGenericTable('BusinessServices');
		$useBusinessServicesTable = 1;
	}

	# the events configuration table, controls active/notify/logging for each known event
	my $events_config = NMISNG::Util::loadTable( dir => 'conf', name => 'Events' )
		;    # cannot use loadGenericTable as that checks and clashes with db_events_sql

	# add a full format time string for emails and message notifications
	# pull the system timezone and then the local time
	my $msgtime = NMISNG::Util::get_localtime();

	# first load all non-historic events for all nodes
	my %allevents = Compat::NMIS::loadAllEvents;

	# then send UP events to all those contacts to be notified as part of the escalation procedure
	# this loop skips ALL marked-as-current events!
	# current flag in event means: DO NOT TOUCH IN ESCALATE, STILL ALIVE AND ACTIVE
	# we might rename that transition t/f, and have this function handle only the ones with transition true.
	my @mustupnotify = grep( !NMISNG::Util::getbool( $allevents{$_}->{current} ), keys %allevents );
	for my $eventkey (@mustupnotify)
	{
		my $thisevent = $allevents{$eventkey};

		# if the event is configured for no notify, do nothing
		my $thisevent_control = $events_config->{$thisevent->{event}}
			|| {Log => "true", Notify => "true", Status => "true"};

		# in case of Notify being off for this event, we don't have to check/walk/handle any notify fields at all
		# as we're deleting the record after the loop anyway.
		if ( NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
		{
			foreach my $field ( split( ',', $thisevent->{notify} ) )    # field = type:contact
			{
				$target = "";
				my @x    = split /:/, $field;
				my $type = shift @x;                                    # netsend, email, or pager ?
				NMISNG::Util::dbg("Escalation type=$type contact=$contact");

				if ( $type =~ /email|ccopy|pager/ )
				{
					foreach $contact (@x)
					{
						if ( exists $CT->{$contact} )
						{
							if ( Compat::NMIS::dutyTime( $CT, $contact ) )
							{                                           # do we have a valid dutytime ??
								if ( $type eq "pager" )
								{
									$target = $target ? $target . "," . $CT->{$contact}{Pager} : $CT->{$contact}{Pager};
								}
								else
								{
									$target = $target ? $target . "," . $CT->{$contact}{Email} : $CT->{$contact}{Email};
								}
							}
						}
						else
						{
							NMISNG::Util::dbg("Contact $contact not found in Contacts table");
						}
					}    #foreach

# no email targets found, and if default contact not found, assume we are not covering 24hr dutytime in this slot, so no mail.
# maybe the next levelx escalation field will fill in the gap
					if ( !$target )
					{
						if ( $type eq "pager" )
						{
							$target = $CT->{default}{Pager};
						}
						else
						{
							$target = $CT->{default}{Email};
						}
						NMISNG::Util::dbg("No $type contact matched (maybe check DutyTime and TimeZone?) - looking for default contact $target"
						);
					}

					if ($target)
					{
						foreach my $trgt ( split /,/, $target )
						{
							my $message;
							my $priority;
							if ( $type eq "pager" )
							{
								$msgTable{$type}{$trgt}{$serial_ns}{message}
									= "NMIS: UP Notify $thisevent->{node} Normal $thisevent->{event} $thisevent->{element}";
								$serial_ns++;
							}
							else
							{
								if ( $type eq "ccopy" )
								{
									$message  = "FOR INFORMATION ONLY\n";
									$priority = &Compat::NMIS::eventToSMTPPri("Normal");
								}
								else
								{
									$priority = &Compat::NMIS::eventToSMTPPri( $thisevent->{level} );
								}
								$event_age = NMISNG::Util::convertSecsHours( time - $thisevent->{startdate} );

								$message
									.= "Node:\t$thisevent->{node}\nUP Event Notification\nEvent Elapsed Time:\t$event_age\nEvent:\t$thisevent->{event}\nElement:\t$thisevent->{element}\nDetails:\t$thisevent->{details}\n\n";

								if ( NMISNG::Util::getbool( $C->{mail_combine} ) )
								{
									$msgTable{$type}{$trgt}{$serial}{count}++;
									$msgTable{$type}{$trgt}{$serial}{subject}
										= "NMIS Escalation Message, contains $msgTable{$type}{$trgt}{$serial}{count} message(s), $msgtime";
									$msgTable{$type}{$trgt}{$serial}{message} .= $message;
									if ( $priority gt $msgTable{$type}{$trgt}{$serial}{priority} )
									{
										$msgTable{$type}{$trgt}{$serial}{priority} = $priority;
									}
								}
								else
								{
									$msgTable{$type}{$trgt}{$serial}{subject}
										= "$thisevent->{node} $thisevent->{event} - $thisevent->{element} - $thisevent->{details} at $msgtime";
									$msgTable{$type}{$trgt}{$serial}{message}  = $message;
									$msgTable{$type}{$trgt}{$serial}{priority} = $priority;
									$msgTable{$type}{$trgt}{$serial}{count}    = 1;
									$serial++;
								}
							}
						}

						# log the meta event, ONLY if both Log (and Notify) are enabled
						Compat::NMIS::logEvent(
							node    => $thisevent->{node},
							event   => "$type to $target UP Notify",
							level   => "Normal",
							element => $thisevent->{element},
							details => $thisevent->{details}
						) if ( NMISNG::Util::getbool( $thisevent_control->{Log} ) );

						NMISNG::Util::dbg("Escalation $type UP Notification node=$thisevent->{node} target=$target level=$thisevent->{level} event=$thisevent->{event} element=$thisevent->{element} details=$thisevent->{details} group=$NT->{$thisevent->{node}}{group}"
						);
					}
				}    # end email,ccopy,pager
				     # now the netsends
				elsif ( $type eq "netsend" )
				{
					my $message
						= "UP Event Notification $thisevent->{node} Normal $thisevent->{event} $thisevent->{element} $thisevent->{details} at $msgtime";
					foreach my $trgt (@x)
					{
						$msgTable{$type}{$trgt}{$serial_ns}{message} = $message;
						$serial_ns++;
						NMISNG::Util::dbg("NetSend $message to $trgt");

						# log the meta event, ONLY if both Log (and Notify) are enabled
						Compat::NMIS::logEvent(
							node    => $thisevent->{node},
							event   => "NetSend $message to $trgt UP Notify",
							level   => "Normal",
							element => $thisevent->{element},
							details => $thisevent->{details}
						) if ( NMISNG::Util::getbool( $thisevent_control->{Log} ) );
					}    #foreach
				}    # end netsend
				elsif ( $type eq "syslog" )
				{
					if ( NMISNG::Util::getbool( $C->{syslog_use_escalation} ) )    # syslog action
					{
						my $timenow = time();
						my $message
							= "NMIS_Event::$C->{server_name}::$timenow,$thisevent->{node},$thisevent->{event},$thisevent->{level},$thisevent->{element},$thisevent->{details}";
						my $priority = NMISNG::Notify::eventToSyslog( $thisevent->{level} );

						foreach my $trgt (@x)
						{
							$msgTable{$type}{$trgt}{$serial_ns}{message}  = $message;
							$msgTable{$type}{$trgt}{$serial_ns}{priority} = $priority;
							$serial_ns++;
							NMISNG::Util::dbg("syslog $message");
						}    #foreach
					}
				}    # end syslog
				elsif ( $type eq "json" )
				{
					# log the event as json file, AND save those updated bits back into the
					# soon-to-be-deleted/archived event record.
					my $node = $NT->{$thisevent->{node}};
					$thisevent->{nmis_server} = $C->{server_name};
					$thisevent->{customer}    = $node->{customer};
					$thisevent->{location}    = $LocationsTable->{$node->{location}}{Location};
					$thisevent->{geocode}     = $LocationsTable->{$node->{location}}{Geocode};

					if ($useServiceStatusTable)
					{
						$thisevent->{serviceStatus}  = $ServiceStatusTable->{$node->{serviceStatus}}{serviceStatus};
						$thisevent->{statusPriority} = $ServiceStatusTable->{$node->{serviceStatus}}{statusPriority};
					}

					if ($useBusinessServicesTable)
					{
						$thisevent->{businessService}
							= $BusinessServicesTable->{$node->{businessService}}{businessService};
						$thisevent->{businessPriority}
							= $BusinessServicesTable->{$node->{businessService}}{businessPriority};
					}

					# Copy the fields from nodes to the event
					my @nodeFields = split( ",", $C->{'json_node_fields'} );
					foreach my $field (@nodeFields)
					{
						$thisevent->{$field} = $node->{$field};
					}

					NMISNG::Notify::logJsonEvent( event => $thisevent, dir => $C->{'json_logs'} );

					# may sound silly to update-then-archive but i'd rather have the historic event record contain
					# the full story
					if ( my $err = Compat::NMIS::eventUpdate( event => $thisevent ) )
					{
						NMISNG::Util::logMsg("ERROR $err");
					}
				}    # end json
				     # any custom notification methods?
				else
				{
					if ( NMISNG::Util::checkPerlLib("Notify::$type") )
					{
						NMISNG::Util::dbg("Notify::$type $contact");

						my $timenow = time();
						my $datenow = NMISNG::Util::returnDateStamp();
						my $message
							= "$datenow: $thisevent->{node}, $thisevent->{event}, $thisevent->{level}, $thisevent->{element}, $thisevent->{details}";
						foreach $contact (@x)
						{
							if ( exists $CT->{$contact} )
							{
								if ( Compat::NMIS::dutyTime( $CT, $contact ) )
								{    # do we have a valid dutytime ??
									    # check if UpNotify is true, and save with this event
									    # and send all the up event notifies when the event is cleared.
									if ( NMISNG::Util::getbool( $EST->{$esc_key}{UpNotify} )
										and $thisevent->{event} =~ /$C->{upnotify_stateful_events}/i )
									{
										my $ct = "$type:$contact";
										my @l = split( ',', $thisevent->{notify} );
										if ( not grep { $_ eq $ct } @l )
										{
											push @l, $ct;
											$thisevent->{notify}
												= join( ',', @l );   # note: updated only for msgtable below, NOT saved!
										}
									}

									#$serial
									$msgTable{$type}{$contact}{$serial_ns}{message} = $message;
									$msgTable{$type}{$contact}{$serial_ns}{contact} = $CT->{$contact};
									$msgTable{$type}{$contact}{$serial_ns}{event}   = $thisevent;
									$serial_ns++;
								}
							}
							else
							{
								NMISNG::Util::dbg("Contact $contact not found in Contacts table");
							}
						}
					}
					else
					{
						NMISNG::Util::dbg("ERROR runEscalate problem with escalation target unknown at level$thisevent->{escalate} $level type=$type"
						);
					}
				}
			}
		}

		# now remove this event
		if ( my $err = Compat::NMIS::eventDelete( event => $thisevent ) )
		{
			NMISNG::Util::logMsg("ERROR $err");
		}
		delete $allevents{$eventkey};    # ditch the removed event in the in-mem snapshot, too.
	}

	#===========================================
	my $stateless_event_dampening = $C->{stateless_event_dampening} || 900;

	# now handle the actual escalations; only events marked-as-current are left now.
LABEL_ESC:
	for my $eventkey ( keys %allevents )
	{
		my $thisevent  = $allevents{$eventkey};
		my $mustupdate = undef;                   # live changes to thisevent are ok, but saved back ONLY if this is set
		NMISNG::Util::dbg("processing event $eventkey");

		# checking if event is stateless and dampen time has passed.
		if ( NMISNG::Util::getbool( $thisevent->{stateless} ) and time() > $thisevent->{startdate} + $stateless_event_dampening )
		{
			# yep, remove the event completely.
			NMISNG::Util::dbg("stateless event $thisevent->{event} has exceeded dampening time of $stateless_event_dampening seconds."
			);
			Compat::NMIS::eventDelete( event => $thisevent );
		}

		# set event control to policy or default=enabled.
		my $thisevent_control = $events_config->{$thisevent->{event}}
			|| {Log => "true", Notify => "true", Status => "true"};

		my $nd = $thisevent->{node};

		# lets start with checking that we have a valid node - the node may have been deleted.
		# note: Compat::NMIS::loadAllEvents() doesn't return events for vanished nodes (but for inactive ones it does)
		if ( !$NT->{$nd} or NMISNG::Util::getbool( $NT->{$nd}{active}, "invert" ) )
		{
			if (    NMISNG::Util::getbool( $thisevent_control->{Log} )
				and NMISNG::Util::getbool( $thisevent_control->{Notify} ) )    # meta-events are subject to both Notify and Log
			{
				Compat::NMIS::logEvent(
					node    => $nd,
					event   => "Deleted Event: $thisevent->{event}",
					level   => $thisevent->{level},
					element => $thisevent->{element},
					details => $thisevent->{details}
				);

				my $timenow = time();
				my $message
					= "NMIS_Event::$C->{server_name}::$timenow,$thisevent->{node},Deleted Event: $thisevent->{event},$thisevent->{level},$thisevent->{element},$thisevent->{details}";
				my $priority = NMISNG::Notify::eventToSyslog( $thisevent->{level} );
				NMISNG::Notify::sendSyslog(
					server_string => $C->{syslog_server},
					facility      => $C->{syslog_facility},
					message       => $message,
					priority      => $priority
				);
			}

			NMISNG::Util::logMsg("INFO ($nd) Node not active, deleted Event=$thisevent->{event} Element=$thisevent->{element}");
			Compat::NMIS::eventDelete( event => $thisevent );

			next LABEL_ESC;
		}

		### 2013-08-07 keiths, taking too long when MANY interfaces e.g. > 200,000
		if (    $thisevent->{event} =~ /interface/i
			and $thisevent->{event} !~ /proactive/i )
		{
			### load the interface information and check the collect status.
			my $S = NMISNG::Sys->new;    # node object
			if ( $S->init( name => $nd, snmp => 'false' ) )
			{                    # get cached info of node only
				my $IFD = $S->ifDescrInfo();    # interface info indexed by ifDescr
				if ( !NMISNG::Util::getbool( $IFD->{$thisevent->{element}}{collect} ) )
				{
					# meta events are subject to both Log and Notify controls
					if ( NMISNG::Util::getbool( $thisevent_control->{Log} ) and NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
					{
						Compat::NMIS::logEvent(
							node    => $thisevent->{node},
							event   => "Deleted Event: $thisevent->{event}",
							level   => $thisevent->{level},
							element => " no matching interface or no collect Element=$thisevent->{element}"
						);
					}
					NMISNG::Util::logMsg(
						"INFO ($thisevent->{node}) Interface not active, deleted Event=$thisevent->{event} Element=$thisevent->{element}"
					);

					Compat::NMIS::eventDelete( event => $thisevent );
					next LABEL_ESC;
				}
			}
		}

		# if an planned outage is in force, keep writing the start time of any unack event to the current start time
		# so when the outage expires, and the event is still current, we escalate as if the event had just occured
		my ( $outage, undef ) = Compat::NMIS::outageCheck( node => $thisevent->{node}, time => time() );
		NMISNG::Util::dbg("Outage for $thisevent->{node} is $outage");
		if ( $outage eq "current" and NMISNG::Util::getbool( $thisevent->{ack}, "invert" ) )
		{
			$thisevent->{startdate} = time();
			if ( my $err = Compat::NMIS::eventUpdate( event => $thisevent ) )
			{
				NMISNG::Util::logMsg("ERROR $err");
			}
		}

		# set the current outage time
		$outage_time = time() - $thisevent->{startdate};

		# if we are to escalate, this event must not be part of a planned outage and un-ack.
		if ( $outage ne "current" and NMISNG::Util::getbool( $thisevent->{ack}, "invert" ) )
		{
			# we have list of nodes that this node depends on in $NT->{$runnode}{depend}
			# if any of those have a current Node Down alarm, then lets just move on with a debug message
			# should we log that we have done this - maybe not....

			if ( $NT->{$thisevent->{node}}{depend} ne '' )
			{
				foreach my $node_depend ( split /,/, $NT->{$thisevent->{node}}{depend} )
				{
					next if $node_depend eq "N/A";                 # default setting
					next if $node_depend eq $thisevent->{node};    # remove the catch22 of self dependancy.
					                                               #only do dependancy if node is active.
					if ( defined $NT->{$node_depend}{active} and NMISNG::Util::getbool( $NT->{$node_depend}{active} ) )
					{
						if ( my $event_exists = Compat::NMIS::eventExist( $node_depend, "Node Down", undef ) )
						{
							my $erec = Compat::NMIS::eventLoad( filename => $event_exists ) if ($event_exists);
							if ( ref($erec) eq "HASH" and $erec->{current} )
							{
								NMISNG::Util::dbg("NOT escalating $thisevent->{node} $thisevent->{event} as dependant $node_depend is reported as down"
								);
								next LABEL_ESC;
							}
						}
					}
				}
			}

			undef %keyhash;    # clear this every loop
			$escalate = $thisevent->{escalate};    # save this as a flag

			# now depending on the event escalate the event up a level or so depending on how long it has been active
			# now would be the time to notify as to the event. node down every 15 minutes, interface down every 4 hours?
			# maybe a deccreasing run 15,30,60,2,4,etc
			# proactive events would be escalated daily
			# when escalation hits 10 they could auto delete?
			# core, distrib and access could escalate at different rates.

			my $nmisng_node = $nmisng->node( name => $thisevent->{node} );
			my ($catchall_inventory,$error_message) = $nmisng_node->inventory( concept => "catchall" );
			$nmisng->log->error("Failed to get catchall inventory for node:$thisevent->{node}, error_message:$error_message") && next
				if(!$catchall_inventory);
			# in this case we have no guarantee that we have catchall and if we don't creating it is pointless.
			my $catchall_data = $catchall_inventory->data_live();
			$group = lc( $catchall_data->{group} );
			$role  = lc( $catchall_data->{roleType} );
			$type  = lc( $catchall_data->{nodeType} );
			$event = lc( $thisevent->{event} );

			NMISNG::Util::dbg("looking for Event to Escalation Table match for Event[ Node:$thisevent->{node} Event:$event Element:$thisevent->{element} ]"
			);
			NMISNG::Util::dbg("and node values node=$thisevent->{node} group=$group role=$role type=$type");

			# Escalation_Key=Group:Role:Type:Event
			my @keylist = (
				$group . "_" . $role . "_" . $type . "_" . $event,
				$group . "_" . $role . "_" . $type . "_" . "default",
				$group . "_" . $role . "_" . "default" . "_" . $event,
				$group . "_" . $role . "_" . "default" . "_" . "default",
				$group . "_" . "default" . "_" . $type . "_" . $event,
				$group . "_" . "default" . "_" . $type . "_" . "default",
				$group . "_" . "default" . "_" . "default" . "_" . $event,
				$group . "_" . "default" . "_" . "default" . "_" . "default",
				"default" . "_" . $role . "_" . $type . "_" . $event,
				"default" . "_" . $role . "_" . $type . "_" . "default",
				"default" . "_" . $role . "_" . "default" . "_" . $event,
				"default" . "_" . $role . "_" . "default" . "_" . "default",
				"default" . "_" . "default" . "_" . $type . "_" . $event,
				"default" . "_" . "default" . "_" . $type . "_" . "default",
				"default" . "_" . "default" . "_" . "default" . "_" . $event,
				"default" . "_" . "default" . "_" . "default" . "_" . "default"
			);

			# lets allow all possible keys to match !
			# so one event could match two or more escalation rules
			# can have specific notifies to one group, and a 'catch all' to manager for example.

			foreach my $klst (@keylist)
			{
				foreach my $esc ( keys %{$EST} )
				{
					my $esc_short = lc "$EST->{$esc}{Group}_$EST->{$esc}{Role}_$EST->{$esc}{Type}_$EST->{$esc}{Event}";

					$EST->{$esc}{Event_Node} = ( $EST->{$esc}{Event_Node} eq '' ) ? '.*' : $EST->{$esc}{Event_Node};
					$EST->{$esc}{Event_Element}
						= ( $EST->{$esc}{Event_Element} eq '' ) ? '.*' : $EST->{$esc}{Event_Element};
					$EST->{$esc}{Event_Node} =~ s;/;;g;
					$EST->{$esc}{Event_Element} =~ s;/;\\/;g;
					if (    $klst eq $esc_short
						and $thisevent->{node} =~ /$EST->{$esc}{Event_Node}/i
						and $thisevent->{element} =~ /$EST->{$esc}{Event_Element}/i )
					{
						$keyhash{$esc} = $klst;
						NMISNG::Util::dbg("match found for escalation key=$esc");
					}
					else
					{
						#NMISNG::Util::dbg("no match found for escalation key=$esc, esc_short=$esc_short");
					}
				}
			}

			my $cnt_hash = keys %keyhash;
			NMISNG::Util::dbg("$cnt_hash match(es) found for $thisevent->{node}");

			foreach $esc_key ( keys %keyhash )
			{
				NMISNG::Util::dbg("Matched Escalation Table Group:$EST->{$esc_key}{Group} Role:$EST->{$esc_key}{Role} Type:$EST->{$esc_key}{Type} Event:$EST->{$esc_key}{Event} Event_Node:$EST->{$esc_key}{Event_Node} Event_Element:$EST->{$esc_key}{Event_Element}"
				);
				NMISNG::Util::dbg("Pre Escalation : $thisevent->{node} Event $thisevent->{event} is $outage_time seconds old escalation is $thisevent->{escalate}"
				);

				# default escalation for events
				# 28 apr 2003 moved times to nmis.conf
				for my $esclevel ( reverse( 0 .. 10 ) )
				{
					if ( $outage_time >= $C->{"escalate$esclevel"} )
					{
						$mustupdate = 1 if ( $thisevent->{escalate} != $esclevel );    # if level has changed
						$thisevent->{escalate} = $esclevel;
						last;
					}
				}

				NMISNG::Util::dbg("Post Escalation: $thisevent->{node} Event $thisevent->{event} is $outage_time seconds old, escalation is $thisevent->{escalate}"
				);
				if ( $C->{debug} and $escalate == $thisevent->{escalate} )
				{
					my $level = "Level" . ( $thisevent->{escalate} + 1 );
					NMISNG::Util::dbg("Next Notification Target would be $level");
					NMISNG::Util::dbg( "Contact: " . $EST->{$esc_key}{$level} );
				}

				# send a new email message as the escalation again.
				# ehg 25oct02 added win32 netsend message type (requires SAMBA on this host)
				if ( $escalate != $thisevent->{escalate} )
				{
					$event_age = NMISNG::Util::convertSecsHours( time - $thisevent->{startdate} );
					$time      = &NMISNG::Util::returnDateStamp;

					# get the string of type email:contact1:contact2,netsend:contact1:contact2,\
					# pager:contact1:contact2,email:sysContact
					$level = lc( $EST->{$esc_key}{'Level' . $thisevent->{escalate}} );

					if ( $level ne "" )
					{
						# Now we have a string, check for multiple notify types
						foreach $field ( split ",", $level )
						{
							$target = "";
							@x      = split /:/, lc $field;
							$type   = shift @x;               # first entry is email, ccopy, netsend or pager

							NMISNG::Util::dbg("Escalation type=$type");

							if ( $type =~ /email|ccopy|pager/ )
							{
								foreach $contact (@x)
								{
									my $contactLevelSend = 0;
									my $contactDutyTime  = 0;

									# if sysContact, use device syscontact as key into the contacts table hash
									if ( $contact eq "syscontact" )
									{
										if ( $catchall_data->{sysContact} ne '' )
										{
											$contact = lc $catchall_data->{sysContact};
											NMISNG::Util::dbg("Using node $thisevent->{node} sysContact $catchall_data->{sysContact}");
										}
										else
										{
											$contact = 'default';
										}
									}

									### better handling of upnotify for certain notification types.
									if ( $type !~ /email|pager/ )
									{
										# check if UpNotify is true, and save with this event
										# and send all the up event notifies when the event is cleared.
										if (    NMISNG::Util::getbool( $EST->{$esc_key}{UpNotify} )
											and $thisevent->{event} =~ /$C->{upnotify_stateful_events}/i
											and NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
										{
											my $ct = "$type:$contact";
											my @l = split( ',', $thisevent->{notify} );
											if ( not grep { $_ eq $ct } @l )
											{
												push @l, $ct;
												$thisevent->{notify} = join( ',', @l );
												$mustupdate = 1;
											}
										}
									}

									if ( exists $CT->{$contact} )
									{
										if ( Compat::NMIS::dutyTime( $CT, $contact ) )
										{    # do we have a valid dutytime ??
											$contactDutyTime = 1;

											# Duty Time is OK check level match
											if ( $CT->{$contact}{Level} eq "" )
											{
												NMISNG::Util::dbg("SEND Contact $contact no filtering by Level defined");
												$contactLevelSend = 1;
											}
											elsif ( $thisevent->{level} =~ /$CT->{$contact}{Level}/i )
											{
												NMISNG::Util::dbg("SEND Contact $contact filtering by Level: $CT->{$contact}{Level}, event level is $thisevent->{level}"
												);
												$contactLevelSend = 1;
											}
											elsif ( $thisevent->{level} !~ /$CT->{$contact}{Level}/i )
											{
												NMISNG::Util::dbg("STOP Contact $contact filtering by Level: $CT->{$contact}{Level}, event level is $thisevent->{level}"
												);
												$contactLevelSend = 0;
											}
										}

										if ( $contactDutyTime and $contactLevelSend )
										{
											if ( $type eq "pager" )
											{
												$target
													= $target
													? $target . "," . $CT->{$contact}{Pager}
													: $CT->{$contact}{Pager};
											}
											else
											{
												$target
													= $target
													? $target . "," . $CT->{$contact}{Email}
													: $CT->{$contact}{Email};
											}

											# check if UpNotify is true, and save with this event
											# and send all the up event notifies when the event is cleared.
											if (    NMISNG::Util::getbool( $EST->{$esc_key}{UpNotify} )
												and $thisevent->{event} =~ /$C->{upnotify_stateful_events}/i
												and NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
											{
												my $ct = "$type:$contact";
												my @l = split( ',', $thisevent->{notify} );
												if ( not grep { $_ eq $ct } @l )
												{
													push @l, $ct;
													$thisevent->{notify} = join( ',', @l );
													$mustupdate = 1;
												}
											}
										}
										else
										{
											NMISNG::Util::dbg("STOP Contact duty time: $contactDutyTime, contact level: $contactLevelSend"
											);
										}
									}
									else
									{
										NMISNG::Util::dbg("Contact $contact not found in Contacts table");
									}
								}    #foreach

								# no email targets found, and if default contact not found, assume we are not
								# covering 24hr dutytime in this slot, so no mail.
								# maybe the next levelx escalation field will fill in the gap
								if ( !$target )
								{
									if ( $type eq "pager" )
									{
										$target = $CT->{default}{Pager};
									}
									else
									{
										$target = $CT->{default}{Email};
									}
									NMISNG::Util::dbg("No $type contact matched (maybe check DutyTime and TimeZone?) - looking for default contact $target"
									);
								}
								else    # have target
								{
									foreach my $trgt ( split /,/, $target )
									{
										my $message;
										my $priority;
										if ( $type eq "pager" )
										{
											if ( NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
											{
												$msgTable{$type}{$trgt}{$serial_ns}{message}
													= "NMIS: Esc. $thisevent->{escalate} $event_age $thisevent->{node} $thisevent->{level} $thisevent->{event} $thisevent->{details}";
												$serial_ns++;
											}
										}
										else
										{
											if ( $type eq "ccopy" )
											{
												$message  = "FOR INFORMATION ONLY\n";
												$priority = &Compat::NMIS::eventToSMTPPri("Normal");
											}
											else
											{
												$priority = &Compat::NMIS::eventToSMTPPri( $thisevent->{level} );
											}

											###2013-10-08 arturom, keiths, Added link to interface name if interface event.
											$C->{nmis_host_protocol} = "http" if $C->{nmis_host_protocol} eq "";
											$message
												.= "Node:\t$thisevent->{node}\nNotification at Level$thisevent->{escalate}\nEvent Elapsed Time:\t$event_age\nSeverity:\t$thisevent->{level}\nEvent:\t$thisevent->{event}\nElement:\t$thisevent->{element}\nDetails:\t$thisevent->{details}\nLink to Node: $C->{nmis_host_protocol}://$C->{nmis_host}$C->{network}?act=network_node_view&widget=false&node=$thisevent->{node}\n";
											if ( $thisevent->{event} =~ /Interface/ )
											{
												my $ifIndex = undef;
												my $S       = NMISNG::Sys->new;    # sys accessor object
												if ( ( $S->init( name => $thisevent->{node}, snmp => 'false' ) ) )
												{                          # get cached info of node only
													my $IFD = $S->ifDescrInfo();    # interface info indexed by ifDescr
													if ( NMISNG::Util::getbool( $IFD->{$thisevent->{element}}{collect} ) )
													{
														$ifIndex = $IFD->{$thisevent->{element}}{ifIndex};
														$message
															.= "Link to Interface:\t$C->{nmis_host_protocol}://$C->{nmis_host}$C->{network}?act=network_interface_view&widget=false&node=$thisevent->{node}&intf=$ifIndex\n";
													}
												}
											}
											$message .= "\n";

											if ( NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
											{
												if ( NMISNG::Util::getbool( $C->{mail_combine} ) )
												{
													$msgTable{$type}{$trgt}{$serial}{count}++;
													$msgTable{$type}{$trgt}{$serial}{subject}
														= "NMIS Escalation Message, contains $msgTable{$type}{$trgt}{$serial}{count} message(s), $msgtime";
													$msgTable{$type}{$trgt}{$serial}{message} .= $message;
													if ( $priority gt $msgTable{$type}{$trgt}{$serial}{priority} )
													{
														$msgTable{$type}{$trgt}{$serial}{priority} = $priority;
													}
												}
												else
												{
													$msgTable{$type}{$trgt}{$serial}{subject}
														= "$thisevent->{node} $thisevent->{event} - $thisevent->{element} - $thisevent->{details} at $msgtime";
													$msgTable{$type}{$trgt}{$serial}{message}  = $message;
													$msgTable{$type}{$trgt}{$serial}{priority} = $priority;
													$msgTable{$type}{$trgt}{$serial}{count}    = 1;
													$serial++;
												}
											}
										}
									}

									# meta-events are subject to Notify and Log
									Compat::NMIS::logEvent(
										node    => $thisevent->{node},
										event   => "$type to $target Esc$thisevent->{escalate} $thisevent->{event}",
										level   => $thisevent->{level},
										element => $thisevent->{element},
										details => $thisevent->{details}
										)
										if (NMISNG::Util::getbool( $thisevent_control->{Notify} )
										and NMISNG::Util::getbool( $thisevent_control->{Log} ) );

									NMISNG::Util::dbg("Escalation $type Notification node=$thisevent->{node} target=$target level=$thisevent->{level} event=$thisevent->{event} element=$thisevent->{element} details=$thisevent->{details} group=$NT->{$thisevent->{node}}{group}"
									);
								}    # if $target
							}    # end email,ccopy,pager

							# now the netsends
							elsif ( $type eq "netsend" )
							{
								if ( NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
								{
									my $message
										= "Escalation $thisevent->{escalate} $thisevent->{node} $thisevent->{level} $thisevent->{event} $thisevent->{element} $thisevent->{details} at $msgtime";
									foreach my $trgt (@x)
									{
										$msgTable{$type}{$trgt}{$serial_ns}{message} = $message;
										$serial_ns++;
										NMISNG::Util::dbg("NetSend $message to $trgt");

										# meta-events are subject to both
										Compat::NMIS::logEvent(
											node    => $thisevent->{node},
											event   => "NetSend $message to $trgt $thisevent->{event}",
											level   => $thisevent->{level},
											element => $thisevent->{element},
											details => $thisevent->{details}
										) if ( NMISNG::Util::getbool( $thisevent_control->{Log} ) );
									}    #foreach
								}
							}    # end netsend
							elsif ( $type eq "syslog" )
							{
								# check if UpNotify is true, and save with this event
								# and send all the up event notifies when the event is cleared.
								if (    NMISNG::Util::getbool( $EST->{$esc_key}{UpNotify} )
									and $thisevent->{event} =~ /$C->{upnotify_stateful_events}/i
									and NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
								{
									my $ct = "$type:server";
									my @l = split( ',', $thisevent->{notify} );
									if ( not grep { $_ eq $ct } @l )
									{
										push @l, $ct;
										$thisevent->{notify} = join( ',', @l );
										$mustupdate = 1;
									}
								}

								if ( NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
								{
									my $timenow = time();
									my $message
										= "NMIS_Event::$C->{server_name}::$timenow,$thisevent->{node},$thisevent->{event},$thisevent->{level},$thisevent->{element},$thisevent->{details}";
									my $priority = NMISNG::Notify::eventToSyslog( $thisevent->{level} );
									if ( NMISNG::Util::getbool( $C->{syslog_use_escalation} ) )
									{
										foreach my $trgt (@x)
										{
											$msgTable{$type}{$trgt}{$serial_ns}{message} = $message;
											$msgTable{$type}{$trgt}{$serial}{priority}   = $priority;
											$serial_ns++;
											NMISNG::Util::dbg("syslog $message");
										}    #foreach
									}
								}
							}    # end syslog
							elsif ( $type eq "json" )
							{
								if (    NMISNG::Util::getbool( $EST->{$esc_key}{UpNotify} )
									and $thisevent->{event} =~ /$C->{upnotify_stateful_events}/i
									and NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
								{
									my $ct = "$type:server";
									my @l = split( ',', $thisevent->{notify} );
									if ( not grep { $_ eq $ct } @l )
									{
										push @l, $ct;
										$thisevent->{notify} = join( ',', @l );
										$mustupdate = 1;
									}
								}

								# amend the event - attention: this changes the live event,
								# and will be saved back!
								$mustupdate = 1;
								my $node = $NT->{$thisevent->{node}};
								$thisevent->{nmis_server} = $C->{server_name};
								$thisevent->{customer}    = $node->{customer};
								$thisevent->{location}    = $LocationsTable->{$node->{location}}{Location};
								$thisevent->{geocode}     = $LocationsTable->{$node->{location}}{Geocode};

								if ($useServiceStatusTable)
								{
									$thisevent->{serviceStatus}
										= $ServiceStatusTable->{$node->{serviceStatus}}{serviceStatus};
									$thisevent->{statusPriority}
										= $ServiceStatusTable->{$node->{serviceStatus}}{statusPriority};
								}

								if ($useBusinessServicesTable)
								{
									$thisevent->{businessService}
										= $BusinessServicesTable->{$node->{businessService}}{businessService};
									$thisevent->{businessPriority}
										= $BusinessServicesTable->{$node->{businessService}}{businessPriority};
								}

								# Copy the fields from nodes to the event
								my @nodeFields = split( ",", $C->{'json_node_fields'} );
								foreach my $field (@nodeFields)
								{
									$thisevent->{$field} = $node->{$field};
								}

								NMISNG::Notify::logJsonEvent( event => $thisevent, dir => $C->{'json_logs'} )
									if ( NMISNG::Util::getbool( $thisevent_control->{Notify} ) );
							}    # end json
							elsif ( NMISNG::Util::getbool( $thisevent_control->{Notify} ) )
							{
								if ( NMISNG::Util::checkPerlLib("Notify::$type") )
								{
									NMISNG::Util::dbg("Notify::$type $contact");
									my $timenow = time();
									my $datenow = NMISNG::Util::returnDateStamp();
									my $message
										= "$datenow: $thisevent->{node}, $thisevent->{event}, $thisevent->{level}, $thisevent->{element}, $thisevent->{details}";
									foreach $contact (@x)
									{
										if ( exists $CT->{$contact} )
										{
											if ( Compat::NMIS::dutyTime( $CT, $contact ) )
											{    # do we have a valid dutytime ??
												    # check if UpNotify is true, and save with this event
												    # and send all the up event notifies when the event is cleared.
												if ( NMISNG::Util::getbool( $EST->{$esc_key}{UpNotify} )
													and $thisevent->{event} =~ /$C->{upnotify_stateful_events}/i )
												{
													my $ct = "$type:$contact";
													my @l = split( ',', $thisevent->{notify} );
													if ( not grep { $_ eq $ct } @l )
													{
														push @l, $ct;
														$thisevent->{notify} = join( ',', @l );    # fudged up
														$mustupdate = 1;
													}
												}

												#$serial
												$msgTable{$type}{$contact}{$serial_ns}{message} = $message;
												$msgTable{$type}{$contact}{$serial_ns}{contact} = $CT->{$contact};
												$msgTable{$type}{$contact}{$serial_ns}{event}   = $thisevent;
												$serial_ns++;
											}
										}
										else
										{
											NMISNG::Util::dbg("Contact $contact not found in Contacts table");
										}
									}
								}
								else
								{
									NMISNG::Util::dbg("ERROR runEscalate problem with escalation target unknown at level$thisevent->{escalate} $level type=$type"
									);
								}
							}
						}    # foreach field
					}    # endif $level
				}    # if escalate
			}    # foreach esc_key
		}    # end of outage check

# now we're done with this event, let's update it if we have to - and if nobody has deleted the event since the start of this update run (as we're not locking this globally) - eventkey is the full filename
		if ( $mustupdate && -f $eventkey )
		{
			if ( my $err = Compat::NMIS::eventUpdate( event => $thisevent ) )
			{
				NMISNG::Util::logMsg("ERROR $err");
			}
		}
	}

	# Cologne, send the messages now
	sendMSG( data => \%msgTable );
	NMISNG::Util::dbg("Finished");
	if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) )
	{
		my $polltime = $pollTimer->elapTime();
		NMISNG::Util::logMsg("Poll Time: $polltime");
	}
	NMISNG::Util::update_operations_stamp(
		type  => "escalate",
		start => $starttime,
		stop  => Time::HiRes::time()
	) if ( $type eq "escalate" );    # not if part of collect
}    # end runEscalate

#=========================================================================================

#
# structure of the hash:
# device name => email, ccopy, netsend, pager
#	target
#  		serial
#			subject
#			message
#			priority
# Cologne.

sub sendMSG
{
	my %args     = @_;
	my $msgTable = $args{data};
	my $C        = NMISNG::Util::loadConfTable();    # get ref

	my $target;
	my $serial;
	NMISNG::Util::dbg("Starting");

	foreach my $method ( keys %$msgTable )
	{
		NMISNG::Util::dbg("Method $method");
		if ( $method eq "email" )
		{
			# fixme: this is slightly inefficient as the new sendEmail can send to multiple targets in one go
			foreach $target ( keys %{$msgTable->{$method}} )
			{
				foreach $serial ( keys %{$msgTable->{$method}{$target}} )
				{
					next if $C->{mail_server} eq '';

					my ( $status, $code, $errmsg ) = NMISNG::Notify::sendEmail(

						# params for connection and sending
						sender     => $C->{mail_from},
						recipients => [$target],

						mailserver => $C->{mail_server},
						serverport => $C->{mail_server_port},
						hello      => $C->{mail_domain},
						usetls     => $C->{mail_use_tls},
						ipproto    => $C->{mail_server_ipproto},

						username => $C->{mail_user},
						password => $C->{mail_password},

						# and params for making the message on the go
						to       => $target,
						from     => $C->{mail_from},
						subject  => $$msgTable{$method}{$target}{$serial}{subject},
						body     => $$msgTable{$method}{$target}{$serial}{message},
						priority => $$msgTable{$method}{$target}{$serial}{priority},
					);

					if ( !$status )
					{
						NMISNG::Util::logMsg("Error: Sending email to $target failed: $code $errmsg");
					}
					else
					{
						NMISNG::Util::dbg("Escalation Email Notification sent to $target");
					}
				}
			}
		}    # end email
		### Carbon copy notifications - no action required - FYI only.
		elsif ( $method eq "ccopy" )
		{
			# fixme: this is slightly inefficient as the new sendEmail can send to multiple targets in one go
			foreach $target ( keys %{$msgTable->{$method}} )
			{
				foreach $serial ( keys %{$msgTable->{$method}{$target}} )
				{
					next if $C->{mail_server} eq '';

					my ( $status, $code, $errmsg ) = NMISNG::Notify::sendEmail(

						# params for connection and sending
						sender     => $C->{mail_from},
						recipients => [$target],

						mailserver => $C->{mail_server},
						serverport => $C->{mail_server_port},
						hello      => $C->{mail_domain},
						usetls     => $C->{mail_use_tls},
						ipproto    => $C->{mail_server_ipproto},

						username => $C->{mail_user},
						password => $C->{mail_password},

						# and params for making the message on the go
						to       => $target,
						from     => $C->{mail_from},
						subject  => $$msgTable{$method}{$target}{$serial}{subject},
						body     => $$msgTable{$method}{$target}{$serial}{message},
						priority => $$msgTable{$method}{$target}{$serial}{priority},
					);

					if ( !$status )
					{
						NMISNG::Util::logMsg("Error: Sending email to $target failed: $code $errmsg");
					}
					else
					{
						NMISNG::Util::dbg("Escalation CC Email Notification sent to $target");
					}
				}
			}
		}    # end ccopy
		elsif ( $method eq "netsend" )
		{
			foreach $target ( keys %{$msgTable->{$method}} )
			{
				foreach $serial ( keys %{$msgTable->{$method}{$target}} )
				{
					NMISNG::Util::dbg("netsend $$msgTable{$method}{$target}{$serial}{message} to $target");

					# read any stdout messages and throw them away
					if ( $^O =~ /win32/i )
					{
						# win32 platform
						my $dump = `net send $target $$msgTable{$method}{$target}{$serial}{message}`;
					}
					else
					{
						# Linux box
						my $dump = `echo $$msgTable{$method}{$target}{$serial}{message}|smbclient -M $target`;
					}
				}    # end netsend
			}
		}

		# now the syslog
		elsif ( $method eq "syslog" )
		{
			foreach $target ( keys %{$msgTable->{$method}} )
			{
				foreach $serial ( keys %{$msgTable->{$method}{$target}} )
				{
					NMISNG::Util::dbg(" sendSyslog to $target");
					NMISNG::Notify::sendSyslog(
						server_string => $C->{syslog_server},
						facility      => $C->{syslog_facility},
						message       => $$msgTable{$method}{$target}{$serial}{message},
						priority      => $$msgTable{$method}{$target}{$serial}{priority}
					);
				}    # end syslog
			}
		}

		# now the pagers
		elsif ( $method eq "pager" )
		{
			foreach $target ( keys %{$msgTable->{$method}} )
			{
				foreach $serial ( keys %{$msgTable->{$method}{$target}} )
				{
					next if $C->{snpp_server} eq '';
					NMISNG::Util::dbg(" SendSNPP to $target");
					NMISNG::Notify::sendSNPP(
						server  => $C->{snpp_server},
						pagerno => $target,
						message => $$msgTable{$method}{$target}{$serial}{message}
					);
				}
			}    # end pager
		}

		# now the extensible stuff.......
		else
		{

			my $class       = "Notify::$method";
			my $classMethod = $class . "::sendNotification";
			if ( NMISNG::Util::checkPerlLib($class) )
			{
				eval "require $class";
				NMISNG::Util::logMsg($@) if $@;
				NMISNG::Util::dbg("Using $classMethod to send notification to $$msgTable{$method}{$target}{$serial}{contact}->{Contact}"
				);
				my $function = \&{$classMethod};
				foreach $target ( keys %{$msgTable->{$method}} )
				{
					foreach $serial ( keys %{$msgTable->{$method}{$target}} )
					{
						NMISNG::Util::dbg( "Notify method=$method, target=$target, serial=$serial message="
								. $$msgTable{$method}{$target}{$serial}{message} );
						if ( $target and $$msgTable{$method}{$target}{$serial}{message} )
						{
							$function->(
								message  => $$msgTable{$method}{$target}{$serial}{message},
								event    => $$msgTable{$method}{$target}{$serial}{event},
								contact  => $$msgTable{$method}{$target}{$serial}{contact},
								priority => $$msgTable{$method}{$target}{$serial}{priority},
								C        => $C
							);
						}
					}
				}
			}
			else
			{
				NMISNG::Util::dbg("ERROR unknown device $method");
			}
		}    # end sms
	}
	NMISNG::Util::dbg("Finished");
}

#=========================================================================================

### Adding overall network metrics collection and updates
sub runMetrics
{
	my %args = @_;
	my $S    = $args{sys};

	my $GT = Compat::NMIS::loadGroupTable();

	my %groupSummary;
	my $data;
	my $group;
	my $status;

	my $pollTimer = Compat::Timing->new;

	NMISNG::Util::dbg("Starting");

	# Doing the whole network - this defaults to -8 hours span
	my $groupSummary = Compat::NMIS::getGroupSummary();
	$status                      = Compat::NMIS::overallNodeStatus;
	$status                      = Compat::NMIS::statusNumber($status);
	$data->{reachability}{value} = $groupSummary->{average}{reachable};
	$data->{availability}{value} = $groupSummary->{average}{available};
	$data->{responsetime}{value} = $groupSummary->{average}{response};
	$data->{health}{value}       = $groupSummary->{average}{health};
	$data->{status}{value}       = $status;
	$data->{intfCollect}{value}  = $groupSummary->{average}{intfCollect};
	$data->{intfColUp}{value}    = $groupSummary->{average}{intfColUp};
	$data->{intfAvail}{value}    = $groupSummary->{average}{intfAvail};

	# RRD options
	$data->{reachability}{option} = "gauge,0:100";
	$data->{availability}{option} = "gauge,0:100";
	### 2014-03-18 keiths, setting maximum responsetime to 30 seconds.
	$data->{responsetime}{option} = "gauge,0:30000";
	$data->{health}{option}       = "gauge,0:100";
	$data->{status}{option}       = "gauge,0:100";
	$data->{intfCollect}{option}  = "gauge,0:U";
	$data->{intfColUp}{option}    = "gauge,0:U";
	$data->{intfAvail}{option}    = "gauge,0:U";

	NMISNG::Util::dbg("Doing Network Metrics database reach=$data->{reachability}{value} avail=$data->{availability}{value} resp=$data->{responsetime}{value} health=$data->{health}{value} status=$data->{status}{value}"
	);

	my $db = $S->create_update_rrd( data => $data, type => "metrics", item => 'network' );
	if ( !$db )
	{
		NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
	}

	foreach $group ( sort keys %{$GT} )
	{
		$groupSummary = Compat::NMIS::getGroupSummary( group => $group );
		$status                      = Compat::NMIS::overallNodeStatus( group => $group );
		$status                      = Compat::NMIS::statusNumber($status);
		$data->{reachability}{value} = $groupSummary->{average}{reachable};
		$data->{availability}{value} = $groupSummary->{average}{available};
		$data->{responsetime}{value} = $groupSummary->{average}{response};
		$data->{health}{value}       = $groupSummary->{average}{health};
		$data->{status}{value}       = $status;
		$data->{intfCollect}{value}  = $groupSummary->{average}{intfCollect};
		$data->{intfColUp}{value}    = $groupSummary->{average}{intfColUp};
		$data->{intfAvail}{value}    = $groupSummary->{average}{intfAvail};

		NMISNG::Util::dbg("Doing group=$group Metrics database reach=$data->{reachability}{value} avail=$data->{availability}{value} resp=$data->{responsetime}{value} health=$data->{health}{value} status=$data->{status}{value}"
		);
		#
		$db = $S->create_update_rrd( data => $data, type => "metrics", item => $group );
		if ( !$db )
		{
			NMISNG::Util::logMsg( "ERROR updateRRD failed: " . NMISNG::rrdfunc::getRRDerror() );
		}
	}
	NMISNG::Util::dbg("Finished");

	NMISNG::Util::logMsg( "Poll Time: " . $pollTimer->elapTime() )
		if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) );

}    # end runMetrics

#=========================================================================================

sub runLinks
{
	my %subnets;
	my $links;
	my $C = NMISNG::Util::loadConfTable();
	my $II;
	my $ipAddr;
	my $subnet;
	my $cnt;

	if ( NMISNG::Util::getbool( $C->{disable_interfaces_summary} ) )
	{
		NMISNG::Util::logMsg("runLinks disabled with disable_interfaces_summary=$C->{disable_interfaces_summary}");
		return;
	}

	NMISNG::Util::dbg("Start");
	my $nmisng = Compat::NMIS::new_nmisng();

	if ( !( $II = Compat::NMIS::loadInterfaceInfo() ) )
	{
		NMISNG::Util::logMsg("ERROR reading all interface info");
		return;
	}

	if ( NMISNG::Util::getbool( $C->{db_links_sql} ) )
	{
		$links = Compat::DBfunc::->select( table => 'Links' );
	}
	else
	{
		$links = NMISNG::Util::loadTable( dir => 'conf', name => 'Links' );
	}

	my $link_ifTypes = $C->{link_ifTypes} ne '' ? $C->{link_ifTypes} : '.';
	my $qr_link_ifTypes = qr/$link_ifTypes/i;

	my %catchall;

	NMISNG::Util::dbg("Auto Generating Links file");
	foreach my $intHash ( sort keys %{$II} )
	{
		$cnt = 1;
		while ( defined $II->{$intHash}{"ipSubnet$cnt"} )
		{
			$ipAddr = $II->{$intHash}{"ipAdEntAddr$cnt"};
			$subnet = $II->{$intHash}{"ipSubnet$cnt"};
			if (    $ipAddr ne ""
				and $ipAddr ne "0.0.0.0"
				and $ipAddr !~ /^127/
				and NMISNG::Util::getbool( $II->{$intHash}{collect} )
				and $II->{$intHash}{ifType} =~ /$qr_link_ifTypes/ )
			{
				my $neednode = $II->{$intHash}{node};
				if (!$catchall{$neednode})
				{
					my $nodeobj = $nmisng->node(name => $neednode);
					die "No node named $neednode exists!\n" if (!$nodeobj); # fixme9: better option?

					my ($inventory,$error) = $nodeobj->inventory(concept => "catchall");
					die "Failed to retrieve $neednode inventory: $error\n" if ($error);
					$catchall{$neednode} = $inventory->data;
				}

				if ( !exists $subnets{$subnet}{subnet} )
				{
					$subnets{$subnet}{subnet}      = $subnet;
					$subnets{$subnet}{address1}    = $ipAddr;
					$subnets{$subnet}{count}       = 1;
					$subnets{$subnet}{description} = $II->{$intHash}{Description};
					$subnets{$subnet}{mask}        = $II->{$intHash}{"ipAdEntNetMask$cnt"};
					$subnets{$subnet}{ifSpeed}     = $II->{$intHash}{ifSpeed};
					$subnets{$subnet}{ifType}      = $II->{$intHash}{ifType};
					$subnets{$subnet}{net1}        = $catchall{$neednode}->{netType};
					$subnets{$subnet}{role1}       = $catchall{$neednode}->{roleType};
					$subnets{$subnet}{node1}       = $II->{$intHash}{node};
					$subnets{$subnet}{ifDescr1}    = $II->{$intHash}{ifDescr};
					$subnets{$subnet}{ifIndex1}    = $II->{$intHash}{ifIndex};
				}
				else
				{
					++$subnets{$subnet}{count};
					if ( !defined $subnets{$subnet}{description} )
					{    # use node2 description if node1 description did not exist.
						$subnets{$subnet}{description} = $II->{$intHash}{Description};
					}
					$subnets{$subnet}{net2}     = $catchall{$neednode}->{netType};
					$subnets{$subnet}{role2}    = $catchall{$neednode}->{roleType};
					$subnets{$subnet}{node2}    = $II->{$intHash}{node};
					$subnets{$subnet}{ifDescr2} = $II->{$intHash}{ifDescr};
					$subnets{$subnet}{ifIndex2} = $II->{$intHash}{ifIndex};

				}
			}
			if ( $C->{debug} > 2 )
			{
				for my $i ( keys %{$subnets{$subnet}} )
				{
					NMISNG::Util::dbg("subnets $i=$subnets{$subnet}{$i}");
				}
			}
			$cnt++;
		}
	}
	foreach my $subnet ( sort keys %subnets )
	{
		if ( $subnets{$subnet}{count} == 2 )
		{
			# skip subnet for same node-interface in link table
			next
				if grep {
				        $links->{$_}{node1} eq $subnets{$subnet}{node1}
					and $links->{$_}{ifIndex1} eq $subnets{$subnet}{ifIndex1}
				} keys %{$links};

			# insert entry in db if not exists
			if ( NMISNG::Util::getbool( $C->{db_links_sql} ) )
			{
				if ( not exists $links->{$subnet}{subnet} )
				{
					Compat::DBfunc::->insert( table => 'Links', data => {index => $subnet} );
				}
			}

			# form a key - use subnet as the unique key, same as read in, so will update any links with new information
			if (    defined $subnets{$subnet}{description}
				and $subnets{$subnet}{description} ne 'noSuchObject'
				and $subnets{$subnet}{description} ne "" )
			{
				$links->{$subnet}{link} = $subnets{$subnet}{description};
			}
			else
			{
				# label the link as the subnet if no description
				$links->{$subnet}{link} = $subnet;
			}
			$links->{$subnet}{subnet}  = $subnets{$subnet}{subnet};
			$links->{$subnet}{mask}    = $subnets{$subnet}{mask};
			$links->{$subnet}{ifSpeed} = $subnets{$subnet}{ifSpeed};
			$links->{$subnet}{ifType}  = $subnets{$subnet}{ifType};

			# define direction based on wan-lan and core-distribution-access
			# selection weights cover the most well-known types
			# fixme: this is pretty ugly and doesn't use $C->{severity_by_roletype}
			my %netweight = ( wan => 1, lan => 2, _ => 3, );
			my %roleweight = ( core => 1, distribution => 2, _ => 3, access => 4 );

			my $netweight1
				= defined( $netweight{$subnets{$subnet}->{net1}} )
				? $netweight{$subnets{$subnet}->{net1}}
				: $netweight{"_"};
			my $netweight2
				= defined( $netweight{$subnets{$subnet}->{net2}} )
				? $netweight{$subnets{$subnet}->{net2}}
				: $netweight{"_"};

			my $roleweight1
				= defined( $roleweight{$subnets{$subnet}->{role1}} )
				? $roleweight{$subnets{$subnet}->{role1}}
				: $roleweight{"_"};
			my $roleweight2
				= defined( $roleweight{$subnets{$subnet}->{role2}} )
				? $roleweight{$subnets{$subnet}->{role2}}
				: $roleweight{"_"};

			my $k
				= ( ( $netweight1 == $netweight2 && $roleweight1 > $roleweight2 ) || $netweight1 > $netweight2 )
				? 2
				: 1;

			$links->{$subnet}{net}  = $subnets{$subnet}{"net$k"};
			$links->{$subnet}{role} = $subnets{$subnet}{"role$k"};

			$links->{$subnet}{node1}      = $subnets{$subnet}{"node$k"};
			$links->{$subnet}{interface1} = $subnets{$subnet}{"ifDescr$k"};
			$links->{$subnet}{ifIndex1}   = $subnets{$subnet}{"ifIndex$k"};

			$k = $k == 1 ? 2 : 1;
			$links->{$subnet}{node2}      = $subnets{$subnet}{"node$k"};
			$links->{$subnet}{interface2} = $subnets{$subnet}{"ifDescr$k"};
			$links->{$subnet}{ifIndex2}   = $subnets{$subnet}{"ifIndex$k"};

			# dont overwrite any manually configured dependancies.
			if ( !exists $links->{$subnet}{depend} ) { $links->{$subnet}{depend} = "N/A" }

			# reformat the name
			##	$links->{$subnet}{link} =~ s/ /_/g;

			if ( NMISNG::Util::getbool( $C->{db_links_sql} ) )
			{
				if ( not exists $links->{$subnet}{subnet} )
				{
					Compat::DBfunc::->update( table => 'Links', data => $links->{$subnet}, index => $subnet );
				}
			}
			NMISNG::Util::dbg("Adding link $links->{$subnet}{link} for $subnet to links");
		}
	}
	$links = {} if !$links;
	if ( !NMISNG::Util::getbool( $C->{db_links_sql} ) )
	{
		NMISNG::Util::writeTable( dir => 'conf', name => 'Links', data => $links );
	}
	NMISNG::Util::logMsg("Check table Links and update link names and other entries");

	NMISNG::Util::dbg("Finished");
}

#=========================================================================================

# starts up fpingd and/or opslad
sub runDaemons
{
	my $C = NMISNG::Util::loadConfTable();
	NMISNG::Util::dbg("Starting");

	# fast ping daemon desired and in need of being started?
	if ( NMISNG::Util::getbool( $C->{daemon_fping_active} ) )
	{
		# check the pid file first
		my $pidfile = $C->{fpingd_pidfile} || "/var/run/fpingd.pid";
		my $alreadyrunning;
		if (-f $pidfile)
		{
			# starting more than one daemon is bad
			open(F, "$pidfile") or die "cannot open $pidfile: $!\n";
			$alreadyrunning = <F>;
			close(F);
			chomp($alreadyrunning);

			undef $alreadyrunning if (!$alreadyrunning # nothing there
																or !kill(0, $alreadyrunning)); # or not alive
		}

		if (!$alreadyrunning)
		{
			my $fpingpath  = $C->{'<nmis_bin>'}."/".$C->{daemon_fping_filename};
			die "cannot start fpingd, $fpingpath not executable!\n" if (!-x $fpingpath);

			system($fpingpath, "restart=true");
			NMISNG::Util::logMsg("INFO launched $C->{daemon_fping_filename} daemon");
		}
	}

	# ipsla daemon desired and in need of being started?
	if ( NMISNG::Util::getbool( $C->{daemon_ipsla_active} ) )
	{
		# check the pid file first
		my $pidfile = $C->{ipsla_pidfile} || "/var/run/ipslad.pid";
		my $alreadyrunning;
		if (-f $pidfile)
		{
			# starting more than one daemon is bad
			open(F, "$pidfile") or die "cannot open $pidfile: $!\n";
			$alreadyrunning = <F>;
			close(F);
			chomp($alreadyrunning);

			undef $alreadyrunning if (!$alreadyrunning # nothing there
																or !kill(0, $alreadyrunning)); # or not alive
		}

		if (!$alreadyrunning)
		{
			my $ipslapath  = $C->{'<nmis_bin>'}."/".$C->{daemon_ipsla_filename};
			die "cannot start ipslad, $ipslapath not executable!\n" if (!-x $ipslapath);

			system($ipslapath);
			NMISNG::Util::logMsg("INFO launched $ipslapath daemon");
		}
	}

	NMISNG::Util::dbg("Finished");
}

#=========================================================================================




#=========================================================================================

# run threshold calculation operation on all or one node, in a single loop
# args:
#   node - (optional),
#   running_independently - set to 1 if not in collect/outer loop that will do saves
# returns: nothing
# fixme9: needs to be taught to run for N nodes which are not all and not just a single one!
sub runThreshold
{
	my ($node,$running_independently) = @_;

	# check global_threshold not explicitely set to false
	if ( !NMISNG::Util::getbool( $C->{global_threshold}, "invert" ) )
	{
		my $node_select;
		if ($node)
		{
			die "Invalid node=$node: No node of that name\n"
				if ( !( $node_select = Compat::NMIS::checkNodeName($node) ) );
		}
		doThresholdsAndCreateStatus( name => $node_select, table => doSummaryBuild( name => $node_select ), running_independently => $running_independently );
	}
	else
	{
		NMISNG::Util::dbg("Skipping runThreshold with configuration 'global_threshold' = $C->{'global_threshold'}");
	}
}

# collects (using getSummaryStats) and returns summary stats
# for one or all nodes, also writes two debug files.
#
# args: name (optional), sys (optional, only if name is given)
# returns: summary stats hash
sub doSummaryBuild
{
	my (%args) = @_;
	my $node = $args{name};
	my $S    = $node && $args{sys} ? $args{sys} : undef;    # use given sys object only with this node

	NMISNG::Util::dbg("Start of Summary Build");

	my $NT = Compat::NMIS::loadLocalNodeTable();
	my %stshlth;
	my %stats;
	my %stsintf;

	foreach my $nd ( sort keys %{$NT} )
	{
		next if $node ne "" and $node ne $nd;
		if ( NMISNG::Util::getbool( $NT->{$nd}{active} ) and NMISNG::Util::getbool( $NT->{$nd}{collect} ) )
		{
			if ( !$S )
			{
				# get cached info of node, iff required
				$S = NMISNG::Sys->new;
				next if ( !$S->init( name => $nd, snmp => 'false' ) );
			}

			my $M  = $S->mdl;       # model ref
			my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

			next if NMISNG::Util::getbool( $catchall_data->{nodedown} );

			# oke, look for requests in summary of Model
			foreach my $tp ( keys %{$M->{summary}{statstype}} )
			{
				next if ( !exists $M->{system}->{rrd}->{$tp}->{threshold} );
				my $threshold_period = getThresholdPeriod( subconcept => $tp );

				# check whether this is an indexed section, ie. whether there are multiple instances with
				# their own indices
				# fixme: this is wrong, $tp should be either graphtype OR section
				my @instances = $S->getTypeInstances( graphtype => $tp, section => $tp );
				if (@instances)
				{
					foreach my $i (@instances)
					{
						my $sts = Compat::NMIS::getSummaryStats(
							sys   => $S,
							type  => $tp,
							start => $threshold_period,
							end   => 'now',
							index => $i
						);

						# save all info from %sts for threshold run
						foreach ( keys %{$sts->{$i}} ) { $stats{$nd}{$tp}{$i}{$_} = $sts->{$i}{$_}; }

						foreach my $nm ( keys %{$M->{summary}{statstype}{$tp}{sumname}} )
						{
							$stshlth{ $catchall_data->{nodeType} }{$nd}{$nm}{$i}{Description}
								=  "WHAT GOES HERE? NI->label makes no sense";#$NI->{label}{$tp}{$i};    # descr
							    # check if threshold level available, thresholdname must be equal to type
							if ( exists $M->{threshold}{name}{$tp} )
							{
								( $stshlth{ $catchall_data->{nodeType} }{$nd}{$nm}{$i}{level}, undef, undef )
									= getThresholdLevel( sys => $S, thrname => $tp, stats => $sts, index => $i );
							}

							# save values
							foreach my $stsname ( @{$M->{summary}{statstype}{$tp}{sumname}{$nm}{stsname}} )
							{
								$stshlth{ $catchall_data->{nodeType} }{$nd}{$nm}{$i}{$stsname} = $sts->{$i}{$stsname};
								NMISNG::Util::dbg("stored summary health node=$nd type=$tp name=$stsname index=$i value=$sts->{$i}{$stsname}"
								);
							}
						}
					}
				}

				# non-indexed
				else
				{
					my $dbname = $S->makeRRDname( graphtype => $tp );
					if ( $dbname && -r $dbname )
					{
						my $sts = Compat::NMIS::getSummaryStats( sys => $S, type => $tp, start => $threshold_period, end => 'now' );

						# save all info from %sts for threshold run
						foreach ( keys %{$sts} ) { $stats{$nd}{$tp}{$_} = $sts->{$_}; }

						# check if threshold level available, thresholdname must be equal to type
						if ( exists $M->{threshold}{name}{$tp} )
						{
							( $stshlth{ $catchall_data->{nodeType} }{$nd}{"${tp}_level"}, undef, undef )
								= getThresholdLevel( sys => $S, thrname => $tp, stats => $sts, index => '' );
						}
						foreach my $nm ( keys %{$M->{summary}{statstype}{$tp}{sumname}} )
						{
							foreach my $stsname ( @{$M->{summary}{statstype}{$tp}{sumname}{$nm}{stsname}} )
							{
								$stshlth{ $catchall_data->{nodeType} }{$nd}{$stsname} = $sts->{$stsname};
								NMISNG::Util::dbg("stored summary health node=$nd type=$tp name=$stsname value=$sts->{$stsname}");
							}
						}
					}
				}

				# reset the threshold period, may have been changed to threshold_period-<something>
				my $tp = "interface";
				$threshold_period = getThresholdPeriod( subconcept => $tp );

				# this could maybe use the model and get collect right away as that's
				# all it seems to be used for right now
				my $ids = $S->nmisng_node->get_inventory_ids( concept => 'interface', filter => { enabled => 1, historic => 0 } );
				# get all collected interfaces
				foreach my $id (@$ids)
				{
					my ($intf_inventory,$intf_error) = $S->nmisng_node->inventory( _id => $id );
					my $data = $intf_inventory->data();
					my $index = $data->{index};

					my $sts = Compat::NMIS::getSummaryStats(
						sys   => $S,
						type  => $tp,
						start => $threshold_period,
						end   => time(),
						index => $index
					);
					foreach ( keys %{$sts->{$index}} )
					{
						$stats{$nd}{interface}{$index}{$_} = $sts->{$index}{$_};
					}    # save for threshold

					# copy all stats into the stsintf info.
					foreach ( keys %{$sts->{$index}} ) { $stsintf{"${index}.$S->{name}"}{$_} = $sts->{$index}{$_}; }
				}
			}
		}

		# use a new sys object for every node
		undef $S;
	}

	# these two tables are produced ONLY for debugging, they're not used by nmis
	NMISNG::Util::writeTable( dir => 'var', name => "nmis-summaryintf15m",   data => \%stsintf );
	NMISNG::Util::writeTable( dir => 'var', name => "nmis-summaryhealth15m", data => \%stshlth );
	NMISNG::Util::dbg("Finished");

	return \%stats;    # input for threshold process
}

# figures out which threshold alerts need to be run for one (or all) nodes, based on model
# delegates the evaluation work to applyThresholdToInventory, then updates info structures.
#
# args: name (optional), table (required, must be hash ref but may be empty),
# sys (optional, only used if name is given)
#
# note: writes node info file if run as part of type=threshold
# returns: nothing
sub doThresholdsAndCreateStatus
{
	my %args = @_;
	my $name = $args{name};
	my $sts  = $args{table};    # pointer to data built up by doSummaryBuild
	my $S    = $args{sys};
	my $running_independently = $args{running_independently};

	my $nmisng = Compat::NMIS::new_nmisng();

	NMISNG::Util::dbg("Starting");

	NMISNG::Util::update_operations_stamp( type => "threshold", start => $starttime, stop => undef )
		if( $running_independently );

	my $pollTimer = Compat::Timing->new;

	my $events_config = NMISNG::Util::loadTable( dir => 'conf', name => 'Events' );
	my $node_model_data = $nmisng->get_nodes_model( name => $name, filter => { active => 'true', threshold => 'true' }, sort => { name => 1 } );

	for my $onenode (@{$node_model_data->data})
	{
		if ( $node_model_data->count() > 1 || !$S )
		{
			$S = NMISNG::Sys->new;
			next if ( !$S->init( name => $onenode->{name}, snmp => 'false' ) );
		}

		my $M  = $S->mdl;       # pointer to Model table
		my $catchall_inventory = $S->inventory( concept => 'catchall' );
		my $catchall_data = $catchall_inventory->data_live();

		# fixme9 one of the few spots that still require nodeinfo
		my $statusinfo = $S->compat_nodeinfo->{status};

		# skip if node down
		if ( NMISNG::Util::getbool( $catchall_data->{nodedown} ) )
		{
			NMISNG::Util::info("Node down, skipping thresholding for $S->{name}");
			next;
		}
		NMISNG::Util::info("Starting Thresholding node=$S->{name}");

		# first the standard thresholds
		my $thrname = [qw(response reachable available)];
		my $inventory = $S->inventory( concept => 'health' );
		applyThresholdToInventory( sys => $S, table => $sts, type => 'health', thrname => $thrname, inventory => $inventory );

		# search for threshold names in Model of this node
		foreach my $s ( keys %{$M} )    # section name
		{
			# thresholds live ONLY under rrd, other 'types of store' don't interest us here
			my $ts = 'rrd';
			foreach my $type ( keys %{$M->{$s}{$ts}} )    # name/type of subsection
			{
				my $thissection = $M->{$s}->{$ts}->{$type};

				if ( !$thissection->{threshold} )
				{
					NMISNG::Util::dbg( "section $s, type $type has no threshold" );
					next;     # nothing to do
				}
				NMISNG::Util::dbg( "section $s, type $type has a threshold" );


				# get commasep string of threshold name(s), turn it into an array, unless it's already an array
				$thrname = ( ref($thissection->{threshold}) ne 'ARRAY' )
					? [ split( /,/, NMISNG::Util::stripSpaces($thissection->{threshold}) ) ]
					: $thissection->{threshold};

				# attention: control expressions for indexed section must be run per instance,
				# and no more getbool possible (see below for reason)
				my $control = $thissection->{control};
				NMISNG::Util::dbg( "control found:$control for section=$s type=$type", 1 ) if($control);

				# find all instances of this subconcept and try and run thresholding for them, doesn't matter if indexed
				# or not, this will run them all
				my $inventory_model = $S->nmisng_node->get_inventory_model(filter => { subconcepts => $type, enabled => 1, historic => 0 });
				NMISNG::Util::dbg( "threshold=".join(",",@$thrname)." found in section=$s type=$type indexed=$thissection->{indexed}, count=".$inventory_model->count() );
				# turn the 'models' into objects so that parseString can use it if required
				NMISNG::Inventory::instantiate( nmisng => $S->nmisng_node->nmisng, modeldata => $inventory_model );
				foreach my $inventory (@{$inventory_model->data})
				{
					my $data = $inventory->data;
					my $index = $data->{index} // undef;

					if ( $control && !$S->parseString( string => "($control) ? 1:0", sect => $type, index => $index, eval => 1, inventory => $inventory ) )
					{
						NMISNG::Util::dbg("threshold of type:$type, index:$index skipped by control=$control");
						next;
					}
					if( $data->{threshold} && !NMISNG::Util::getbool( $data->{threshold} ) )
					{
						NMISNG::Util::dbg("skipping disabled threshold type:$type for index:$index");
						next;
					}
					applyThresholdToInventory(
						sys     => $S,
						table   => $sts,
						type    => $type,
						thrname => $thrname,
						index   => $index,
						inventory => $inventory
					);
					# item    => $data->{ClassMap}{$class}{Name},
						# class   => $class
						# TODO: CBQOS
						# this autovivifies but it does not matter
						# elsif ( $type =~ /cbqos/ and $data->{threshold} eq 'true')
						# {
						# 	my ( $cbqos, $direction ) = split( /\-/, $type );
						# 	my $inventory = $S->inventory( concept => "cbqos-$direction", index => $index );
						# 	$data = $inventory->data();
						# 	NMISNG::Util::dbg("CBQOS cbqos=$cbqos direction=$direction index=$index");
						# 	foreach my $class ( keys %{$data->{ClassMap}} )
						# 	{
						# 		NMISNG::Util::dbg("  CBQOS class=$class $data->{ClassMap}{$class}{Name}");
						# 		applyThresholdToInventory(
						# 			sys     => $S,
						# 			table   => $sts,
						# 			type    => $type,
						# 			thrname => [$thrname],
						# 			index   => $index,
						# 			item    => $data->{ClassMap}{$class}{Name},
						# 			class   => $class
						# 		);
						# 	}
				}
			}
		}

		## process each status and have it decay the overall node status......
		#"High TCP Connection Count--tcpCurrEstab" : {
		#   "status" : "ok",
		#   "value" : "1",
		#   "event" : "High TCP Connection Count",
		#   "element" : "tcpCurrEstab",
		#   "index" : null,
		#   "level" : "Normal",
		#   "type" : "test",
		#   "updated" : 1423619108,
		#   "method" : "Alert",
		#   "property" : "$r > 250"
		#},
		my $count   = 0;
		my $countOk = 0;
		foreach my $statusKey ( sort keys %$statusinfo )
		{
			my $eventKey = $statusinfo->{$statusKey}{event};
			$eventKey = "Alert: $S->{info}{status}{$statusKey}{event}"
				if $statusinfo->{$statusKey}{method} eq "Alert";

			# event control is as configured or all true.
			my $thisevent_control = $events_config->{$eventKey} || {Log => "true", Notify => "true", Status => "true"};

			# if this is an alert and it is older than 1 full poll cycle, delete it from status.
			if ( $statusinfo->{$statusKey}{updated} < time - 500 )
			{
				delete $statusinfo->{$statusKey};
			}

			# in case of Status being off for this event, we don't have to include it in the calculations
			elsif ( not NMISNG::Util::getbool( $thisevent_control->{Status} ) )
			{
				NMISNG::Util::dbg("Status Summary Ignoring: event=$statusinfo->{$statusKey}{event}, Status=$thisevent_control->{Status}",
					1
				);
				$statusinfo->{$statusKey}{status} = "ignored";
				++$count;
				++$countOk;
			}
			else
			{
				++$count;
				if ( $statusinfo->{$statusKey}{status} eq "ok" )
				{
					++$countOk;
				}
			}
		}
		if ( $count and $countOk )
		{
			my $perOk = sprintf( "%.2f", $countOk / $count * 100 );
			NMISNG::Util::info("Status Summary = $perOk, $count, $countOk\n");
			$catchall_data->{status_summary} = $perOk;
			$catchall_data->{status_updated} = time();

			# cache the current nodestatus for use in the dash
			my $nodestatus = Compat::NMIS::nodeStatus( catchall_data => $catchall_data );
			$catchall_data->{nodestatus} = "reachable";
			if ( not $nodestatus )
			{
				$catchall_data->{nodestatus} = "unreachable";
			}
			elsif ( $nodestatus == -1 )
			{
				$catchall_data->{nodestatus} = "degraded";
			}
		}

		# Save the new status results, but only if run standalone
		if( $running_independently )
		{
			$S->writeNodeInfo();
			$catchall_inventory->save();
		}

	}

	NMISNG::Util::dbg("Finished");
	if ( defined $C->{log_polling_time} and NMISNG::Util::getbool( $C->{log_polling_time} ) )
	{
		my $polltime = $pollTimer->elapTime();
		if ($name)
		{
			NMISNG::Util::logMsg("Poll Time: $name, $polltime");
		}
		else
		{
			NMISNG::Util::logMsg("Poll Time: $polltime");
		}
	}
	NMISNG::Util::update_operations_stamp( type => "threshold", start => $starttime, stop => Time::HiRes::time() )
		if( $running_independently );
}

sub getThresholdPeriod
{
	my (%args) = @_;
	my $subconcept = $args{subconcept};

	my $threshold_period = $C->{"threshold_period-default"} || "-15 minutes";

	### 2013-09-16 keiths, User defined threshold periods.
	if ( exists $C->{"threshold_period-$subconcept"} and $C->{"threshold_period-$subconcept"} ne "" )
	{
		$threshold_period = $C->{"threshold_period-$subconcept"};
		NMISNG::Util::dbg("Found Configured Threshold for $subconcept, changing to \"$threshold_period\"");
	}
	return $threshold_period;
}

# performs the threshold value checking and event raising for
# one or more threshold configurations
# uses latest_data to get derived_data(stats) which should hold the stats with the correct
# period calculated at the last poll cycle
# args: sys, type, thrname (arrayref), index, item, class, inventory (all required),
# table (required hashref but may be empty),
# type is subconcept
# returns: nothing but raises/clears events (via thresholdProcess) and updates table
sub applyThresholdToInventory
{
	my %args = @_;

	my $S    = $args{sys};
	my $inventory = $args{inventory};
	my $M    = $S->mdl;

	my $sts     = $args{table};
	my $type    = $args{type};
	my $thrname = $args{thrname};
	my $index   = $args{index};
	my $item    = $args{item};
	my $class   = $args{class};
	my $stats;
	my $element;
	die "cannot applyThresholdToInventory on something with no inventory, subconcept:$type,index:$index" if(!$inventory);

	NMISNG::Util::dbg("WORKING ON Threshold for thrname=".join(",",@$thrname)." type=$type item=$item");

	my $data = $inventory->data();

	#	check if values are already in table (done by doSummaryBuild)
	if ( exists $sts->{$S->{name}}{$type} )
	{
		$stats = $sts->{$S->{name}}{$type};
	}
	else
	{
		# stats have already been calculated and stored in derived data, the threshold_period
		# should have been used on them then, so just look up the last value
		my $latest_data_ret = $inventory->get_newest_timed_data();
		if( $latest_data_ret->{success} )
		{
			$stats = $latest_data_ret->{derived_data}{$type};
		}
		else
		{
			die "could not get latest_data for inventory: subconcept:$type, index:$index";
		}
	}

	if ( $index eq '' )
	{
		$element = '';
	}
	else
	{
		$element = $inventory->description;
	}

	NMISNG::Util::TODO("Inventory will require description to be accurate");
	NMISNG::Util::TODO("Inventory cbqos needs to be figured out after it's timed_data is complete");
	# elsif ( $index ne '' and $thrname =~ /^hrsmpcpu/ )
	# {
	# 	$element = "CPU $index";
	# }
	# elsif ( $index ne '' and $thrname =~ /^hrdisk/ )
	# {
	# 	$inventory = $S->inventory( concept => 'storage', index => $index );
	# 	$data = ( $inventory ) ? $inventory->data : {};
	# 	$element = "$data->{hrStorageDescr}";
	# }
	# elsif ( $type =~ /cbqos|interface|pkts/ )
	# {
	# 	#inventory keyed by index and ifDescr so we need partial
	# 	my $inventory = $S->inventory( concept => 'interface', index => $index, partial => 1 );
	# 	$data = ( $inventory ) ? $inventory->data : {};
	# 	if( $data->{ifDescr} )
	# 	{
	# 		$element = $data->{ifDescr};
	# 		$element = "$data->{ifDescr}: $item" if($type =~ /cbqos/);
	# 	}
	# }
	# elsif ( defined $M->{systemHealth}{sys}{$type}{indexed}
	# 	and $M->{systemHealth}{sys}{$type}{indexed} ne "true" )
	# {
	# 	NMISNG::Util::TODO("Inventory migration not complete here (and below)");
	# 	my $elementVar = $M->{systemHealth}{sys}{$type}{indexed};
	# 	$inventory = $S->inventory( concept => $type, index => $index );
	# 	$data = ($inventory) ? $inventory->data() : {};
	# 	$element = $data->{$elementVar} if ($data->{$elementVar} ne "" );
	# }
	if ( $element eq "" )
	{
		$element = $index;
	}

	# walk through threshold names
	foreach my $nm (@$thrname)
	{
		NMISNG::Util::dbg("processing threshold $nm");

		# check for control_regex
		if (    defined $M->{threshold}{name}{$nm}
			and $M->{threshold}{name}{$nm}{control_regex} ne ""
			and $item ne "" )
		{
			if ( $item =~ /$M->{threshold}{name}{$nm}{control_regex}/ )
			{
				NMISNG::Util::dbg("MATCHED threshold $nm control_regex MATCHED $item");
			}
			else
			{
				NMISNG::Util::dbg("SKIPPING threshold $nm: $item did not match control_regex");
				next();
			}
		}

		my ( $level, $value, $thrvalue, $reset ) = getThresholdLevel(
			sys     => $S,
			thrname => $nm,
			stats   => $stats,
			index   => $index,
			item    => $item
		);

		# get 'Proactive ....' string of Model
		my $event = $S->parseString( string => $M->{threshold}{name}{$nm}{event}, index => $index, eval => 0 );

		my $details = "";
		my $spacer  = "";

		if ( $type =~ /interface|pkts/ &&  $data->{Description} ne "" )
		{
			$details = $data->{Description};
			$spacer  = " ";
		}

		### 2014-08-27 keiths, display human speed and handle ifSpeedIn and ifSpeedOut
		if (  NMISNG::Util::getbool( $C->{global_events_bandwidth} )
			and $type =~ /interface|pkts/
			and $inventory->ifSpeed ne "" )
		{
			my $ifSpeed = $inventory->ifSpeed();
			$ifSpeed = $inventory->ifSpeedIn if ( $event =~ /Input/ );
			$ifSpeed = $inventory->ifSpeedOut if ( $event =~ /Output/ );
			$details .= $spacer . "Bandwidth=" . NMISNG::Util::convertIfSpeed($ifSpeed);
		}

		thresholdProcess(
			sys      => $S,
			type     => $type,       # crucial for event context
			event    => $event,
			level    => $level,
			element  => $element,    # crucial for context
			details  => $details,
			value    => $value,
			thrvalue => $thrvalue,
			reset    => $reset,
			thrname  => $nm,         # crucial for context
			index    => $index,      # crucial for context
			class    => $class
		);                           # crucial for context
	}
}

sub getThresholdLevel
{
	my %args = @_;
	my $S    = $args{sys};
	my $M    = $S->mdl;
	my $catchall_data = $S->inventory( concept => 'catchall' )->data_live();

	my $thrname = $args{thrname};
	my $stats   = $args{stats};      # value of items
	my $index   = $args{index};
	my $item    = $args{item};

	my $val;
	my $level;
	my $thrvalue;

	NMISNG::Util::dbg("Start threshold=$thrname, index=$index item=$item");

	# find subsection with threshold values in Model
	my $T = $M->{threshold}{name}{$thrname}{select};
	foreach my $thr ( sort { $a <=> $b } keys %{$T} )
	{
		next if $thr eq 'default';    # skip now the default values
		if ( ( $S->parseString( string => "($T->{$thr}{control})?1:0", index => $index, item => $item, eval => 1 ) ) )
		{
			$val = $T->{$thr}{value};
			NMISNG::Util::dbg("found threshold=$thrname entry=$thr");
			last;
		}
	}

	# if not found and there are default values available get this now
	if ( $val eq "" and $T->{default}{value} ne "" )
	{
		$val = $T->{default}{value};
		NMISNG::Util::dbg("found threshold=$thrname entry=default");
	}
	if ( $val eq "" )
	{
		NMISNG::Util::logMsg("ERROR, no threshold=$thrname entry found in Model=$catchall_data->{nodeModel}");
		return;
	}

	my $value;    # value of doSummary()
	my $reset = 0;

	# item is the attribute name of summary stats of Model
	$value = $stats->{$M->{threshold}{name}{$thrname}{item}}         if $index eq "";
	$value = $stats->{$index}{$M->{threshold}{name}{$thrname}{item}} if $index ne "";
	NMISNG::Util::dbg("threshold=$thrname, item=$M->{threshold}{name}{$thrname}{item}, value=$value");

	# check unknow value
	if ( $value =~ /NaN/i )
	{
		NMISNG::Util::dbg("INFO, illegal value $value, skipped");
		return ( "Normal", $value, $reset );
	}

	### all zeros policy to disable thresholding - match and return 'normal'
	if (    $val->{warning} == 0
		and $val->{minor} == 0
		and $val->{major} == 0
		and $val->{critical} == 0
		and $val->{fatal} == 0
		and defined $val->{warning}
		and defined $val->{minor}
		and defined $val->{major}
		and defined $val->{critical}
		and defined $val->{fatal} )
	{
		return ( "Normal", $value, $reset );
	}

	# Thresholds for higher being good and lower bad
	if (    $val->{warning} > $val->{fatal}
		and defined $val->{warning}
		and defined $val->{minor}
		and defined $val->{major}
		and defined $val->{critical}
		and defined $val->{fatal} )
	{
		if ( $value <= $val->{fatal} ) { $level = "Fatal"; $thrvalue = $val->{fatal}; }
		elsif ( $value <= $val->{critical} and $value > $val->{fatal} )
		{
			$level    = "Critical";
			$thrvalue = $val->{critical};
		}
		elsif ( $value <= $val->{major} and $value > $val->{critical} ) { $level = "Major"; $thrvalue = $val->{major}; }
		elsif ( $value <= $val->{minor} and $value > $val->{major} )    { $level = "Minor"; $thrvalue = $val->{minor}; }
		elsif ( $value <= $val->{warning} and $value > $val->{minor} )
		{
			$level    = "Warning";
			$thrvalue = $val->{warning};
		}
		elsif ( $value > $val->{warning} ) { $level = "Normal"; $reset = $val->{warning}; $thrvalue = $val->{warning}; }
	}

	# Thresholds for lower being good and higher being bad
	elsif ( $val->{warning} < $val->{fatal}
		and defined $val->{warning}
		and defined $val->{minor}
		and defined $val->{major}
		and defined $val->{critical}
		and defined $val->{fatal} )
	{
		if ( $value < $val->{warning} ) { $level = "Normal"; $reset = $val->{warning}; $thrvalue = $val->{warning}; }
		elsif ( $value >= $val->{warning} and $value < $val->{minor} )
		{
			$level    = "Warning";
			$thrvalue = $val->{warning};
		}
		elsif ( $value >= $val->{minor} and $value < $val->{major} )    { $level = "Minor"; $thrvalue = $val->{minor}; }
		elsif ( $value >= $val->{major} and $value < $val->{critical} ) { $level = "Major"; $thrvalue = $val->{major}; }
		elsif ( $value >= $val->{critical} and $value < $val->{fatal} )
		{
			$level    = "Critical";
			$thrvalue = $val->{critical};
		}
		elsif ( $value >= $val->{fatal} ) { $level = "Fatal"; $thrvalue = $val->{fatal}; }
	}
	if ( $level eq "" )
	{
		NMISNG::Util::logMsg(
			"ERROR no policy found, threshold=$thrname, value=$value, node=$S->{name}, model=$catchall_data->{nodeModel} section threshold"
		);
		$level = "Normal";
	}
	NMISNG::Util::dbg("result threshold=$thrname, level=$level, value=$value, thrvalue=$thrvalue, reset=$reset");
	return ( $level, $value, $thrvalue, $reset );
}

sub thresholdProcess
{
	my %args = @_;
	my $S    = $args{sys};

	# fixme why no error checking? what about negative or floating point values like 1.3e5?
	if ( $args{value} =~ /^\d+$|^\d+\.\d+$/ )
	{
		NMISNG::Util::info("$args{event}, $args{level}, $args{element}, value=$args{value} reset=$args{reset}");

		my $details = "Value=$args{value} Threshold=$args{thrvalue}";
		if ( defined $args{details} and $args{details} ne "" )
		{
			$details = "$args{details}: Value=$args{value} Threshold=$args{thrvalue}";
		}
		my $statusResult = "ok";
		if ( $args{level} =~ /Normal/i )
		{
			Compat::NMIS::checkEvent(
				sys     => $S,
				event   => $args{event},
				level   => $args{level},
				element => $args{element},
				details => $details,
				value   => $args{value},
				reset   => $args{reset}
			);
		}
		else
		{
			Compat::NMIS::notify(
				sys     => $S,
				event   => $args{event},     # this is cooked at this point and no good for context
				level   => $args{level},
				element => $args{element},
				details => $details,
				context => {
					type          => "threshold",
					source        => "snmp",           # fixme needs extension to support wmi as source
					name          => $args{thrname},
					thresholdtype => $args{type},
					index         => $args{index},
					class         => $args{class},
				}
			);
			$statusResult = "error";
		}
		my $index = $args{index};
		if ( $index eq "" )
		{
			$index = 0;
		}
		my $statusKey = "$args{thrname}--$index";

		$statusKey = "$args{thrname}--$index--$args{class}" if defined $args{class} and $args{class};

		$S->{info}{status}{$statusKey} = {
			method   => "Threshold",
			type     => $args{type},
			property => $args{thrname},
			event    => $args{event},
			index    => $args{index},
			level    => $args{level},
			status   => $statusResult,
			element  => $args{element},
			value    => $args{value},
			updated  => time()
		};
	}
}

sub printRunTime
{
	my $endTime = sprintf( "%.2f", Time::HiRes::time() - $starttime );
	NMISNG::Util::info("End of $0, type=$type ran for $endTime seconds.\n");
}

# sysUpTime under nodeinfo is a mess: not only is nmis overwriting it with
# in nonreversible format on the go,
# it's also used by and scribbled over in various places, and needs synthesizing
# from two separate properties in case of a wmi-only node.
#
# this helper takes in a sys object and attempts to make sysUpTime and sysUpTimeSec
# from whatever sys' nodeinfo structure contains.
sub makesysuptime
{
	my ($sys) = @_;
	my $catchall_data = $sys->inventory( concept => 'catchall' )->data_live();

	return if ( !$catchall_data );

	# if this is wmi, we need to make a sysuptime first. these are seconds
	# who should own sysUpTime, this needs to only happen if SNMP not available OMK-3223
	#if ($catchall_data->{wintime} && $catchall_data->{winboottime})
	#{
	#	$catchall_data->{sysUpTime} = 100 * ($catchall_data->{wintime}-$catchall_data->{winboottime});
	#}

	# pre-mangling it's a number, maybe fractional, in 1/100s ticks
	# post-manging it is text, and we can't do a damn thing anymore
	if ( defined( $catchall_data->{sysUpTime} ) && $catchall_data->{sysUpTime} =~ /^\d+(\.\d*)?$/ )
	{
		$catchall_data->{sysUpTimeSec} = int( $catchall_data->{sysUpTime} / 100 );              # save away
		$catchall_data->{sysUpTime}    = NMISNG::Util::convUpTime( $catchall_data->{sysUpTimeSec} );    # seconds into text
	}
	return;
}

# *****************************************************************************
# Copyright (C) Opmantek Limited (www.opmantek.com)
# This program comes with ABSOLUTELY NO WARRANTY;
# This is free software licensed under GNU GPL, and you are welcome to
# redistribute it under certain conditions; see www.opmantek.com or email
# contact@opmantek.com
# *****************************************************************************
