#!/usr/bin/perl
#
#  Copyright (C) Opmantek Limited (www.opmantek.com)
#
#  ALL CODE MODIFICATIONS MUST BE SENT TO CODE@OPMANTEK.COM
#
#  This file is part of Network Management Information System ("NMIS").
#
#  NMIS is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  NMIS is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with NMIS (most likely in a file named LICENSE).
#  If not, see <http://www.gnu.org/licenses/>
#
#  For further information on NMIS or for a license other than GPL please see
#  www.opmantek.com or email contact@opmantek.com
#
#  User group details:
#  http://support.opmantek.com/users/
#
# *****************************************************************************
use strict;

use File::Copy;
use File::Find;
use File::Basename;
use File::Path;
use Cwd;
use POSIX qw();
no warnings;										# noisy module checking

use version 0.77;
use Getopt::Std;

my $me = basename($0);

my $usage = "NMIS Copyright (C) Opmantek Limited (www.opmantek.com)
This program comes with ABSOLUTELY NO WARRANTY;

Usage: $me [-hyd] [-t /some/path] [[-p|-P] /some/file] [optX=valX...]

-h:  show this help screen
-d:  produce extra debug output and logs
-t:  Installation target directory
-y:  non-interactive  mode, all questions are answered
     with the default choice
-p:  pre-seeded non-interactive mode, answers come from
     the file given as argument
-P:  generate default preseed file\n\n";

my (%options, %extras);
die $usage if ( @ARGV == 1 && $ARGV[0] =~ /^-(\?|h|-help)$/i
								|| !getopts("yldnt:p:P:", \%options));

for my $maybe (@ARGV)
{
	my ($k,$v) = split(/=/,$maybe, 2);
	next  if ($k =~ /[^a-zA-Z0-9_-]/); # ignore extras with problematic chars in the key
	$extras{$k} = $v;
}
my $sourcedir = getcwd;
my $targetdir = $options{t} || "/usr/local/nmis9";
my $hookdir = "$sourcedir/installer_hooks";
my $debug = $options{d}? 1 : 0;
my $simulate = $options{n}? 1 : 0;
my $noninteractive = $options{y} || $options{p}? 1 : 0 ; # preseed is also a noninteractive mode
my $logfile = undef; # until we have a dir
my $answers;				 # preseed mode

# preseed generation requested?
if (my $newseed = $options{P})
{
	die "Error: will not overwrite existing preseed file $newseed!\n"
			if (-e $newseed);

	my @candidates = ("$sourcedir/installer",
										"$sourcedir/admin/setup_mongodb.pl",
										glob("${sourcedir}/installer_hooks/*"));

	# tag -> question, file, line nr, default
	my %tags;

	my $perlre = qr/(^|\W)(input_yn|input_text)\s*\(\s*(["'].+?["'])\s*,\s*"([a-f0-9]{4})"\s*\)/;
	my $shellre = qr/(^|\W)(input_yn|input_text)\s+(["'].+?["'])\s+"([a-f0-9]{4})"/;

	# read file, determine format, look for all input_yn and input_text
	# calls that carry a unique tag and collect filename, line nr, tag and question
	#
	# attention: to find input_yn and input_text instances correctly
	# the whole invocation must be given on a single line!
	for my $onefn (@candidates)
	{
		print STDERR "checking file $onefn...\n";
		open(F, $onefn) or die "cannot open $onefn: $!\n";
		my @incoming = <F>;
		close(F);

		my $isperl = $incoming[0] =~ /perl/;
		my $whichre = $isperl? $perlre : $shellre;

		for my $lineno (0..$#incoming)
		{
			chomp(my $line = $incoming[$lineno]);
			while ($line =~ /$whichre/g)
			{
				my ($querytype, $question, $tag) = ($2,$3,$4);

				# dupl detection also required for tags previously generated or
				# generated by hand or whatever...
				die "\nerror: duplicate tag \"$tag\" found!\npresent in $tags{$tag}->{file} and $onefn\n"
						if (ref($tags{$tag}));

				$tags{$tag} = {
					question => $question,
					file => $onefn,
					linenr => $lineno,
					default => $querytype eq "input_text"? "": "y" };
			}
		}
	}
	open(F, ">$newseed") or die "cannot write to $newseed: $!\n";
	print F gen_preseed(\%tags);
	close(F);
	exit 0;
}
$answers = load_preseed($options{p}) if ($options{p});

my %modules;										# check_installed_modules et.al.

die "This installer must be run as root, terminating now.\n" if ($> != 0 && !$simulate);

delete $ENV{"PERL_CPANM_OPT"};

if ($noninteractive)
{
	$ENV{"PERL_MM_USE_DEFAULT"}=1;
}
else
{
	$ENV{"PERL_MM_USE_DEFAULT"}=0;
}

# there are some slight but annoying differences
my ($osflavour,$osmajor,$osminor,$ospatch,$osiscentos,$osisrocky);
if (-f "/etc/redhat-release")
{
	$osflavour="redhat";
	logmsg(0, "detected OS flavour RedHat/CentOS");

	open(F, "/etc/redhat-release") or die "cannot read redhat-release: $!\n";
	my $reldata = join('',<F>);
	close(F);

	($osmajor,$osminor,$ospatch) = ($1,$2,$4)
			if ($reldata =~ /(\d+)\.(\d+)(\.(\d+))?/);
	if ($reldata =~ /CentOS/)
	{
		$osiscentos = 1;
	}
	if ($reldata =~ /Rocky/)
	{
		$osisrocky = 1;
	}
}
elsif (-f "/etc/os-release")
{
	open(F,"/etc/os-release") or die "cannot read os-release: $!\n";
	my $osinfo = join("",<F>);
	close(F);
	if ($osinfo =~ /ID=[\"\']?debian/)
	{
		$osflavour="debian";
		logmsg(0, "detected OS flavour Debian");
	}
	elsif ($osinfo =~ /ID=[\"\']?ubuntu/)
	{
		$osflavour="ubuntu";
		logmsg(0, "detected OS flavour Ubuntu");
	}
	($osmajor,$osminor,$ospatch) = ($1,$3,$5)
			if ($osinfo =~ /VERSION_ID=\"(\d+)(\.(\d+))?(\.(\d+))?\"/);


	# This code should mimic that in ./installer_hooks/common_functions.sh flavour () function
	# grep 'ID_LIKE' as a catch-all for debian and ubuntu repectively - done last to not affect existing tried and tested code:
	if ( ! defined($osflavour) )
	{
		if ($osinfo =~ /ID_LIKE=[\"\']?debian/)
		{
			$osflavour="debian";
			my $debian_codename=$1 if ($osinfo =~ /DEBIAN_CODENAME=\s*[\"\']?(.+)[\"\']?\s*/);
			# we dont need 'else' catch-all blocks here as we fall back to the debian version
			# populated in the generic block above:
			if ( defined($debian_codename) )
			{
				if ($debian_codename =~ /bookworm/i)
				{
					$osmajor=12;
					$osminor=0;
					$ospatch=0;
				}
				elsif ($debian_codename =~ /bullseye/i)
				{
					$osmajor=11;
					$osminor=0;
					$ospatch=0;
				}
				elsif ($debian_codename =~ /buster/i)
				{
					$osmajor=10;
					$osminor=0;
					$ospatch=0;
				}
				elsif ($debian_codename =~ /stretch/i)
				{
					$osmajor=9;
					$osminor=0;
					$ospatch=0;
				}
				elsif ($debian_codename =~ /jessie/i)
				{
					$osmajor=8;
					$osminor=0;
					$ospatch=0;
				}
			}
			logmsg(0, "detected OS derivative of Debian: \$osmajor='$osmajor'; \$osminor='$osminor'; \$ospatch='$ospatch'");
		}
		elsif ($osinfo =~ /ID_LIKE=[\"\']?ubuntu/)
		{
			$osflavour="ubuntu";
			logmsg(0, "detected OS derivative Ubuntu");
			my $ubuntu_codename=$1 if ($osinfo =~ /UBUNTU_CODENAME=\s*[\"\']?(.+)[\"\']?\s*/);
			# we dont need 'else' catch-all blocks here as we fall back to the ubuntu version
			# populated in the generic block above:
			if ( defined($ubuntu_codename) )
			{
				if ($ubuntu_codename =~ /lunar/i)
				{
					$osmajor=23;
					$osminor=04;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /kinetic/i)
				{
					$osmajor=22;
					$osminor=10;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /jammy/i)
				{
					$osmajor=22;
					$osminor=04;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /impish/i)
				{
					$osmajor=21;
					$osminor=10;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /hirsute/i)
				{
					$osmajor=21;
					$osminor=04;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /groovy/i)
				{
					$osmajor=20;
					$osminor=10;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /focal/i)
				{
					$osmajor=20;
					$osminor=04;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /eoan/i)
				{
					$osmajor=19;
					$osminor=10;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /disco/i)
				{
					$osmajor=19;
					$osminor=04;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /cosmic/i)
				{
					$osmajor=18;
					$osminor=10;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /bionic/i)
				{
					$osmajor=18;
					$osminor=04;
					$ospatch=0;
				}
				elsif ($ubuntu_codename =~ /xenial/i)
				{
					$osmajor=16;
					$osminor=04;
					$ospatch=0;
				}
			}
			logmsg(0, "detected OS derivative of Ubuntu: \$osmajor='$osmajor'; \$osminor='$osminor'; \$ospatch='$ospatch'");
		}
	}
	if ( ! defined($osflavour) )
	{
		logdie("Unsupported or unknown distribution!\n");
	}
}

# ensure we don't create unworkable dirs and files, if the parent shell
# has a super-restrictive umask...
umask(0022);

# is this an initial installation or an upgrade?
# this is a bit of guesswork.
my $is_initial_install = (-d $targetdir && -f "$targetdir/conf/Config.nmis")? 0:1;

# figure out version - build infra will have saved that in .version
# but we need to also cater for install from source, in which case we use regex to extract version from NMISNG.pm:
my $prodversion;
if ( -e "./.version" )
{
	$prodversion = eval { do "./.version" };
	logdie("Invalid release (1) - no version!") if ($@ or !$prodversion);
}
elsif ( -e "./lib/NMISNG.pm" )
{
	open(F,"./lib/NMISNG.pm") or die "cannot read NMISNG.pm: $!\n";
	my $nmisng_source= join("",<F>);
	close(F);
	if ($nmisng_source =~ /our\s+\$VERSION\s*=\s*(?:"|')(.+)(?:"|')\s*/)
	{
		$prodversion = $1;
		if ($@ or !$prodversion)
		{
			logdie("Invalid release (2) - no version!");
		}
	}
}
logdie("Invalid release (3) - no version!") if (!$prodversion);

printBanner("NMIS ($prodversion) Installation script");
my $hostname = `hostname --fqdn`; chomp $hostname;

print "This installer will install NMIS into $targetdir.
To select a different installation location please rerun the
installer with the -t option.\n\n";
my $response = input_yn("Ok to proceed with installation?","52cc");
logdie("User cancelled installation.") if (!$response);

if (!-d $targetdir && !$simulate)
{
	safemkdir($targetdir) or die("Can not mkdir $targetdir!\n");
}
$logfile = "$targetdir/install.log";


logmsg(0,"Installation of NMIS ($prodversion)\n",
			 "started: ".scalar(localtime).", host: $hostname\n",
			 "source: $sourcedir, target: $targetdir\n",
			 "debug: $debug, simulate: $simulate, unattended install: $noninteractive\n",
			 "initial install into blank $targetdir: $is_initial_install\n");

# first, run the pre phase plugins - especially dependency!
# these are mainly for stuff like checking pre-reqs, massaging the environment etc.
printBanner("Performing pre-installation steps");
run_hooks("pre");

# dependencies should now be satisfied as far as easily doable
# now check the modules as-is and whether they're satisfied
printBanner("Checking Perl Module Dependencies...");

my ($isok,@missingones) = check_installed_modules();
if (!$isok)
{
	print "The installer can use CPAN to install the missing Perl packages
that NMIS depends on, if your system has Internet access.

These modules can be installed with CPAN:

  perl -MCPAN -e shell
    install [module name]

  or more conveniently by running
   cpan [module name] [module name...]\n\n";

	# curl is present in most basic redhat install
	# wget is present on debian/ubuntu via priority:important
	# however, ca-certificates may be missing/incomplete at this time
	my $testres = system("curl --insecure -L -s -m 10 --retry 2 -o /dev/null https://firstwave.com/ 2>/dev/null") >> 8;
	$testres = system("wget --no-check-certificate -q -T 10 --tries=3 -O /dev/null https://firstwave.com/ 2>/dev/null") >> 8
			if ($testres);
	my $can_use_web = !$testres;

	if (!$can_use_web or !input_yn("OK to use CPAN to install missing modules?","9849"))
	{
		logmsg(0, "Cannot install missing CPAN modules: ".join(" ",@missingones));

		print "Cannot install missing CPAN modules!\nNMIS will not work properly until the following Perl modules are installed (from CPAN):\n\n"
				.join(" ",@missingones)
				."\n\nWe recommend that you stop the installer now, resolve the dependencies,
and then restart the installer.\n\n";

		if (input_yn("Stop the installer?","365b"))
		{
			die "\nAborting the installation. Please install the missing Perl packages\nwith cpan, then restart the installer.\n";
		}
	}
	else
	{
		# installed cpanm for installing cpan modules
		# as it is far more robust at handling failed tests which hang on cpan installs
		my $cpanm = "cpanm";

		if ($debug)
		{
			my $type_which_cpanm = type_which($cpanm);
			logmsg(0,"type_which_cpanm: $type_which_cpanm\n");
		}

		# fix cpanm path if not set
		if (system("type $cpanm >/dev/null") != 0)
		{
			$cpanm = type_which($cpanm);
		}

		# centos + rhel 7 install of MongoDB-v2.2.1 fails at crud_spec.t, but MongoDB-v2.2.0 installs okay
		my $rhel7_mongodb_module='MongoDB@2.2.0';

		if (defined $cpanm)
		{
			logmsg(0,"CPANM installation complete, proceeding with module installation using cpanm");
			logmsg(0,"cpanm: $cpanm");

			# --prompt option looks really useful to investigate and decide on failed tests, but we must honor $noniteractive
			#
			#		Prompts when a test fails so that you can skip, force install, retry or look in the shell to see what's going wrong.
			#		It also prompts when one of the dependency failed if you want to proceed the installation.
			#		Defaults to false, and you can say --no-prompt to override if it's set in the default options in PERL_CPANM_OPT.
			my $prompt;
			if ($noninteractive)
			{
				$prompt = "";
			}
			else
			{
				$prompt = "--prompt";
			}

			# We pre-install HTTP::Daemon with --notest for this module that often hangs on testing on ubuntu, redhat and centos
			# HTTP::Daemon is a dependency of WWW::Mechanize
			if ( grep( /^WWW::Mechanize$/, @missingones) or grep( /^HTTP::Daemon$/, @missingones) )
			{
				system("cpanm HTTP::Daemon --sudo $prompt --notest 2>&1");	# can't use execprint as cpanm may be interactive
			}
			# We pre-install WWW::Mechanize with --notest for this module that often hangs on testing on ubuntu, redhat and centos
			if ( grep( /^WWW::Mechanize$/, @missingones) )
			{
				system("cpanm WWW::Mechanize --sudo $prompt --notest 2>&1");	# can't use execprint as cpan is interactive: but is cpanm interactive?
			}
			# centos + rhel 7 install of MongoDB-v2.2.1 fails at crud_spec.t, but MongoDB-v2.2.0 installs okay
			if ($osflavour eq "redhat" and $osmajor = 7)
			{
				$_ eq 'MongoDB' and $_ = $rhel7_mongodb_module for @missingones;
			}
			# force install Mojolicious where not being installed to fix the upgrade from apt installed earlier version than 8.11
			# we no longer apt install Mojolicious for this reason:
			if (! grep( /^Mojolicious$/, @missingones) )
			{
				push @missingones, "Mojolicious";
			}


			# default test-timeout is 30 mins: install will return exit code 1 on test timeout
			# retry 3 times
			# can't use execprint as cpanm may be interactive
			system("cpanm --sudo $prompt ".join(" ",@missingones)." 2>&1||cpanm --sudo $prompt ".join(" ",@missingones)." 2>&1||cpanm --sudo $prompt ".join(" ",@missingones)." 2>&1");
			# special case: always retry centos + rhel 7 MongoDB module
			# as the cpanm install fails to install this module randomly (not often)
			if ($osflavour eq "redhat" and $osmajor = 7)
			{
				system("cpanm --sudo $prompt $rhel7_mongodb_module 2>&1");
			}
		}
		else
		{
			logmsg(0,"CPANM installation failed");
			# we fallback to cpan code used prior to cpanm
			logmsg(0,"Installing modules with CPAN");

			# prime cpan if necessary: non-interactive, follow prereqs,
			if (!-e $ENV{"HOME"}."/.cpan") # might be symlink
			{
				print "Performing initial CPAN configuration\n";
				if ($noninteractive)
				{
					# no inputs, all defaults
					execPrint('cpan');

					# adjust options unsuitable for noninteractive work
					open(X,"|cpan") or die "cannot fork cpan: $!\n";
					print X "o conf prerequisites_policy follow\no conf commit\n";
					close X;
				}
				else
				{
					# there doesn't seem an easy way to prime the cpan shell with args,
					# then let interact with the user via stdin/stdout... and not all versions
					# of cpan seem to start it automatically
					print "\n
If the CPAN configuration doesn't start automatically, then please
enter 'o conf init' on the CPAN prompt.

Should you get prompted to choose Perl Library directories, 'local::lib'
or the like, please choose 'sudo' or 'manual' - NOT 'local::lib'!

To return to the installer when done, please exit the CPAN shell with 'exit'.\n";
					input_ok();
					system("cpan");
				}
				logmsg(0,"CPAN configuration complete, proceeding with module installation");
			}
			system("cpan ".join(" ",@missingones));  # can't use execprint as cpan is interactive
		}
	}
}

# ready to install/upgrade,
# before copying anything, lock nmis

#  fixme: make these into precopy stage!
open(F,">$targetdir/conf/NMIS_IS_LOCKED");
print F "$0 is operating, started at ".(scalar localtime)."\n";
close F;
open(F, ">/tmp/nmis_install_running");
print F $$;
close(F);

printBanner("Copying Files");
find(sub {
	my ($name,$dir,$fn) = ($_, $File::Find::dir, $File::Find::name);
	next if ($name =~ /^\./ # no hidden files
					 or $name =~  /^(installer|pre-install.sh)$/ # or installer files
					 or $dir =~ m!/installer_hooks$!  # installer files
					 or ($name eq "installer_hooks" && -d $fn)); # installer files
	print ".";

	# $dir includes sourcedir prefix
	my $destdir = $dir;
	$destdir =~ s/^$sourcedir//;

	if (-d $fn)
	{
		safemkdir("$targetdir/$destdir/$name");
	}
	elsif (-f $fn)
	{
		my $dest = "$targetdir/$destdir/$name";
		safecopy($fn, $dest); # logs and dies on errors
	}
		 }, $sourcedir);

printBanner("Performing Initialisation Operations");
run_hooks("postcopy");					# users config stuff, migrations, patching


printBanner("Performing Final Operations");
run_hooks("postinstall"); # unlock

# ensure the logfile and manifest are rwr-r-, regardless of system umask
# fixme  move chmod(0644, $logfile) if (-f $logfile);


printBanner("installation complete.");
exit 0;



# called for every file found by file::find
# args: none, $_ and file::find::stuff
# updates %modules
# returns: nothing
# note: callback from file::find means DON'T use the same filehandle F as elsewhere!
sub getModules
{
	my ($dirname, $shortname, $fullpath) = ($File::Find::dir, $_, $File::Find::name);
	# interesting? yes if it's a .pm or .pl, or if it lives in bin (no extensions there)

	return if (-d $fullpath
						 or $shortname =~ /^\./
						 or !($shortname =~ /\.p[ml]$/ or $dirname eq "$sourcedir/bin"));

	my $fh;
	open($fh,  $fullpath) or logdie("cannot read $fullpath: $!");
	logmsg(1,"reading file $fullpath...");
	while (my $line = <$fh>)
	{
		return if ($line =~ /^\x{7f}ELF/); # compiled binary
		chomp $line;
		next if (!$line or $line =~ /^\s*#/);

		# test for module use 'xxx' or 'xxx::yyy' or deeper, plus numeric min version
		if ( $line =~ /^\s*(use|require)\s+((\w+::)*\w+)(\s+([0-9\.]+))?.*;/ )
		{
			my ($usetype, $mod, $minversion) = ($1,$2,$4);
			logmsg(1,"$shortname: '$line' => module $mod, minversion $minversion\n");

			# ignore "use 5.10.11"
			next if ($mod =~ /^[0-9\.]+$/);

			$modules{$mod}->{file} = undef; # mark as not found, resolved later
			$modules{$mod}->{usetype} = $usetype; # only last one is kept
			# keep highest
			$modules{$mod}->{minversion} = $minversion if (defined($minversion)
																										 && (!defined($modules{$mod}->{minversion})
																												 or version->parse($modules{$mod}->{minversion}) < version->parse($minversion)));
			$modules{$mod}->{priority} = 10; # low default
			push @{$modules{$mod}->{usedby}}, $fullpath
					if (!grep($_ eq $fullpath, @{$modules{$mod}->{usedby}}))
		}
	}
	close $fh;
}


# returns (1) if no critical modules missing,
# (0,critical modules) otherwise
# args: none, walks the $sourcedir
sub check_installed_modules
{
	printBanner("Checking for required Perl modules");

	# walk the walk...
	find(\&getModules, $sourcedir);

	# fudge in a few indirectly needed ones
	# these are critical for getting mojolicious installed, as centos 6 perl has a much too old perl
	# these modules are in core since 5.19 or thereabouts

	$modules{"IO::Socket::IP"} = { file => undef, usetype  => "use",
																 usedby => "lib/NMISNG/Auth.pm", priority => 98 };
	# io socket ip needs at least this version of socket...
	# and that must be FIRST
	$modules{"Socket"} = { file => undef, usetype  => "use",
												 usedby => "lib/NMISNG/Auth.pm",
												 minversion => "1.97",
												 priority => 99 };
	# and socket needs at least this version of extutils constant to build
	$modules{"ExtUtils::Constant"} = { file => undef, usetype  => "use",
																		 usedby => "lib/NMISNG/Auth.pm",
																		 minversion => "0.23",
																		 priority => 100 };
	# and mojolicious needs all these
	$modules{"JSON::PP"} = { file => undef, usetype => "use",
													 usedby => "lib/NMISNG/Auth.pm", priority => 99 };
	$modules{"Time::Local"} = { file => undef, usetype => "use",
															usedby => "lib/NMISNG/Auth.pm",
															minversion => "1.2", priority => 99 };
	# and time::local needs at least this version of test::More
	$modules{"Test::More"} = { file => undef, usetype => "use",
														 usedby => "lib/NMISNG/Auth.pm",
														 minversion => "0.96", priority => 100 };

	# for compiling the mongodb perl driver
	$modules{"Config::AutoConf"} = { file => undef, usetype => "use",
														 usedby => "lib/NMISNG/DB.pm",
																	 minversion => "0.3", priority => 100 };

	$modules{"Path::Tiny"} = { file => undef, usetype => "use",
														 usedby => "lib/NMISNG/DB.pm",
														 # minversion => "0.3",
														 priority => 100 };

	# must be cpan'd before datetime and mongodb
	$modules{"DateTime::Locale"} = { file => undef, usetype => "use",
																	 usedby => "lib/NMISNG/DB.pm",
																	 # minversion => "0.3",
																	 priority => 100 };

	# we strictly requre mojolicious 8.11 or newer,
	# as the older mojo::log api is too different
	$modules{"Mojolicious"} = { file => undef, usetype => "use",
															usedby => "lib/NMISNG/Log.pm",
															minversion => "8.11", };

	my $libprefix = "$sourcedir/lib";

	# now determine if installed or not.
	# sort by the required cpan sequencing (no priority is last)
	foreach my $modname (keys %modules)
	{
		my $mFile = "$modname.pm";
		$mFile =~ s/::/\//g;				# translate logical namespaced name into path

		my $thisentry = $modules{$modname};
		next if ($thisentry->{version}); # already checked

		# do we have it?
		if (-f (my $ours = "$libprefix/$mFile" ))
		{
			$thisentry->{file} = $ours;
			$thisentry->{version} = moduleVersion($ours, $modname);
		}
		else
		{
			# Now look in @INC for module path and name and record the highest-versioned one
			for my $incpath (@INC)
			{
				if (-f (my $upstream = "$incpath/$mFile"))
				{
					my $thisversion = moduleVersion($upstream, $modname);

					if (!$thisentry->{version}
							or version->parse($thisversion) >= version->parse($thisentry->{version}))
					{
						$thisentry->{file} = $upstream;
						$thisentry->{version} = $thisversion;
					}
				}
			}
		}
	}

	# now figure out what's missing (and which might be ignorable)
	# note that they need to be returned in order of cpan sequencing priority!
  my (@missing, @critmissing);
  my %noncritical = ("Net::LDAP"=>1, "Net::LDAPS"=>1, "IO::Socket::SSL"=>1,
										 "Crypt::UnixCrypt"=>1, "Authen::TacacsPlus"=>1, "Authen::Simple::RADIUS"=>1,
										 "SOAP::Lite" => 1, "Net::SFTP::Foreign" => 1, "CiscoMerakiCloud" => 1);

  logmsg(0, "Detected Module Status:\nName - Minimum Version - Current Version - Current Path\n");
	# sort by install prio (highest first), or file
	foreach my $k ( sort { $modules{$b}->{priority} <=> $modules{$a}->{priority}
												 or $modules{$a}->{file} cmp $modules{$b}->{file} } keys %modules)
	{
		my $thisentry = $modules{$k};

    logmsg(0, join("\t", $k, ($thisentry->{minversion} || "N/A"),
									 ($thisentry->{version}||"N/A"),
									 ($thisentry->{file} || "NOT FOUND")));

		# report as missing: if not present, or version below required minimum
    push @missing, $k if 	(!defined $thisentry->{file}
													 or (defined $thisentry->{minversion}
															 and version->parse($thisentry->{version})
															 < version->parse($thisentry->{minversion})));
	}

	if (@missing)
	{
		@critmissing = grep( !$noncritical{$_}, @missing);
		my @optionals = grep ($noncritical{$_}, @missing);

		if (@optionals)
		{
			printBanner("Some Optional Perl Modules are missing (or too old)");
			print qq|The following optional modules are missing or too old:\n| .join(" ", @optionals)
					.qq|\n\nNote: The modules Net::LDAP, Net::LDAPS, IO::Socket::SSL, Crypt::UnixCrypt,
Authen::TacacsPlus, Authen::Simple::RADIUS are optional components for the
NMIS AAA system.\n\n|;
		}

		if (@critmissing)
		{
			printBanner("Some Required Perl Modules are missing (or too old)!");
			print qq|The following Perl modules are missing or too old and must
to be installed (or upgraded) before NMIS will work fully:\n\n| . join(" ", @critmissing)."\n\n";

			logmsg(0, "Missing Required modules: ".join(" ", @critmissing));
		}
	}

	return (@critmissing?0:1, @critmissing);
}

# get the module version
# note: this is non-optimal, and fails on a few modules (e.g. Encode)
# args: actual file, and module name
# returns: module version or undef
sub moduleVersion
{
	my ($mFile, $modname) = @_;
	my $ver;

	open FH, "$mFile" or return undef;
	while (<FH>)
	{
		if (/^\s*((our|my)\s+\$|\$(\w+::)*)VERSION\s*=\s*['"]?\s*[vV]?([0-9\.a-zA-Z]+)\s*['"]?s*;/)
		{
			close FH;
			if ($ver = $4)
			{
				logmsg(1,"got version $ver for $modname from $mFile");
				return $ver;
			}
		}
	}
	close FH;

	# present but didn't match? load and ask the module then...
	logmsg(1,"loading module $modname from $mFile for version check...");
	eval { no warnings; require $mFile; };
	if ($@)
	{
		logmsg(1,"failed to load $modname: $@");
		return undef;
	}

	# encode doesn't like this variant
	logmsg(1,"trying version check type one on $modname");
	$ver = eval { $modname->VERSION };
	if (!$ver or $@)
	{
		logmsg(1,"trying version check type two on $modname");
		$ver = eval '$'."$modname"."::VERSION";
	}

	logmsg(1,"got version $ver for $modname");
	return $ver;
}

# print prompt, read and return response string if interactive;
# or return default response in noninteractive mode.
#
# default  is "", except in preseed mode where the default
# is looked up from the preseed data tagged by the seedling argument
sub input_text
{
	my ($query,$seedling) = @_;

	print $query;

	if ($noninteractive)
	{
		if ($seedling && ref($answers) && defined($answers->{$seedling}))
		{
			my $answer = $answers->{$seedling};

			print " (preseeded answer \"$answer\")\n";
			logmsg(0, "preseeded answer \"$answer\" for \"$query\"");
			return $answer;
		}
		else
		{
			print " (auto-default \"\")\n\n";
			logmsg(0,"auto-default answer \"\" for \"$query\"");
			return "";
		}
	}
	else
	{
		print "\nEnter new value or hit <Enter> to accept default: ";
		my $input = <STDIN>;
		chomp $input;
		logmsg(0, "User input for \"$query\": \"$input\"");
		return $input;
	}
}

# print question, return true if y (or in unattended mode).
# default is yes, except in preseed mode where the default
# is looked up from the preseed data tagged by the seedling argument
sub input_yn
{
	my ($query, $seedling) = @_;

	while (1)
	{
		print $query;
		if ($noninteractive)
		{
			if ($seedling && ref($answers) && defined($answers->{$seedling}))
			{
				my $answer = $answers->{$seedling};
				my $result = ( $answer =~ /^\s*(y(?:es)?)\s*$/i? 1:0);

				print " (preseeded answer \"$answer\" interpreted as \""
						.($result? "YES":"NO")."\")\n\n";
				logmsg(0,"preseeded answer \"$answer\" for \"$query\" interpreted as \""
						.($result? "YES":"NO"));
				return $result;
			}
			else
			{
				print " (auto-default YES)\n\n";
				logmsg(0,"auto-default answer YES for \"$query\"");
				return 1;
			}
		}
		else
		{
			print "\nType 'y' or <Enter> to accept, or 'n' to decline: ";
			my $input = <STDIN>;
			chomp $input;
			logmsg(0, "User input for \"$query\": \"$input\"");

			if ($input !~ /^\s*(y(?:es)?|n(?:o)?)?\s*$/i)
			{
				print "Invalid input \"$input\"\n\n";
				next;
			}

			return ($input =~ /^\s*(y(?:es)?)?\s*$/i)? 1:0;
		}
	}
}

# prints prompt, waits for confirmation
sub input_ok
{
	print "\nHit <Enter> to continue:\n";
	my $x = <STDIN> if (!$noninteractive);
}

# run program synchronously but non-interactively, through the shell!
# log output, print+return errors
# if in simulation mode, print what would be done and DON'T execute anything
sub execPrint
{
	my ($cmd) = @_;

	if ($simulate)
	{
		print "\nSIMULATION MODE, NOT executing command '$cmd'\n\n";
		return 0;
	}

	logmsg(0,"\n###+++\nEXEC: $cmd");
	# robust: retry on failure
	my $out;
	my $res;
	foreach ( 1, 2, 3, 4, 5, 6) {
		$out = `$cmd 2>&1`;
		my $rawstatus = $?;
		$res = POSIX::WIFEXITED($rawstatus)? POSIX::WEXITSTATUS($rawstatus): -1;
		if ($res == 0)
		{
			logmsg($debug,"\n###+++\nexecPrint '$cmd' succeeded\n\n");
			last;
		}
		if ($debug)
		{
			printBanner("execPrint '$cmd' failed. Retrying...");
		}
		#else
		#{
		#	print "\n###+++\nexecPrint '$cmd' failed. Retrying...\n\n";
		#	logmsg(0,"\n###+++\nexecPrint '$cmd' failed. Retrying...\n\n");
		#}
		sleep 10;
	}

	if ( $res != 0 )
	{
		print "-------COMMAND RETURNED EXIT CODE $res--------\n",
		$cmd, "\n", $out, "----------------------------------------\n";
		logmsg(0,"\n###+++\nEXEC: $cmd, result $res, output $out\n");
	}
	else
	{
		logmsg(0,"OUTPUT: $out") if ($out ne '');
	}
	logmsg(0,"###+++\n");
	return $res;
}

# copy file from a to b, but only if the target is not a symlink
#
# if symlink, warn the user about it and request
# confirmation (default action: leave unchanged)
#
# creates dirs where required
# args: source path, destination path, options (hash)
# returns: 1 if ok, dies on errors
sub safecopy
{
	my ($source, $destination, %options) = @_;
	logdie("safecopy: invalid args, $source is not a file!\n") if (!-f $source);
	logdie("safecopy: invalid args, $destination missing or a dir!\n") if (!$destination or -d $destination);

	if (!-d (my $destdir = dirname($destination)))
	{
		safemkdir($destdir);
	}
	if (-l $destination )
	{
		my $actualtarget = readlink($destination);
		print "Warning: $destination is a symbolic link pointing to $actualtarget!\n";

		# default should be the safe behaviour, i.e. don't clobber the target
		if (input_yn("OK to leave the symbolic link $destination unchanged?","0b55"))
		{
			print "Not overwriting $destination.\nThis will require manual post-installation adjustments.\n\n";
			logmsg(0,"NOT overwriting $destination (=> $actualtarget).\n");
			return 1;
		}
		else
		{
			logmsg(0,"Overwriting $destination (=> $actualtarget) as requested.");
		}
	}
	# must work around 'text file busy' on executables (right now just wmic)
	if (-e $destination)
	{
		logmsg(0,"replacing $destination with $source");
		unlink($destination) or logdie("failed to remove $destination: $!\n");
	}
	else
	{
		logmsg(0,"copying $source to $destination");
	}
	# unfortunately, file::copy in centos/rh6 is too old for useful behaviour wrt. permissions,
	if (version->parse($File::Copy::VERSION) < version->parse("2.15"))
	{
		logdie("Failed to copy $source to $destination: $!\n")
				if (system("cp","-a", $source, $destination));
	}
	else
	{
		File::Copy::cp($source,$destination) or die "Failed to copy $source to $destination: $!\n";
	}
	return 1;
}

# creates a whole directory hierarchy like mkdir -p
# args: dir name
# returns: 1 if ok, dies on failure
sub safemkdir
{
	my ($dirname) = @_;
	logdie("safemkdir: invalid args, dirname missing!\n") if (!$dirname);

	return 1 if (-d $dirname);
	logmsg(0, "making directory $dirname");
	# Ensurehi we don't create unworkable dirs and files, if the parent shell
	# has a super-restrictive umask: file::path perms are subject to umask!
	my $prevmask = umask(0022);
	my $error;
	File::Path::make_path($dirname, { error => \$error,
																		mode =>  0755 } ); # umask is applied to this :-/
	if (ref($error) eq "ARRAY" and @$error)
	{
		my @errs;
		for my $issue (@$error)
		{
			push @errs, join(": ", each %$issue);
		}
		logdie("Could not create directory $dirname: ".join(", ",@errs)."\n");
	}
	umask($prevmask);
	return 1;
}

# runs all hook programs/scripts in the hookdir
# files must be executable, and named NN-PHASE-SOMETEXT - anything else is ignored
#
# environment given to the hooks:
# TARGETDIR points to the target directory
# PRODUCT, VERSION and GENERATION are strings/numbers from the manifest
# LOGFILE is the full path to the installation log file (not given if SIMULATE is active)
# UNATTENDED is set if non-interactive mode is requested
# DEBUG is set when the debug mode is active
# SIMULATE is set if the simulation-make-no-changes mode is requested
# CLEANSLATE is set if this is the first install of product X
# OPT_XYZ is set from any extra args xyz=abc, key is uppercased. freeform, up to the hook scripts to handle.
#
# working dir will be the source directory
#
# the programs MUST return success or run_hooks will terminate the installer
# they SHOULD append their output to the logfile
#
# run_hooks returns nothing, aborts installer on any errors
sub run_hooks
{
	my ($phase) = @_;

	opendir(D,$hookdir) or return;
	for my $fn (sort readdir(D))
	{
		if ($fn =~ /^\d+-$phase-\S+$/ && -x "$hookdir/$fn")
		{
			logmsg(0,"Running plugin $fn");
			my $child = fork;
			logdie("cannot fork: $!") if (!defined $child);
			if ($child > 0)
			{
				wait;
				my $result = $?;
				logdie("Plugin returned non-zero exit code, terminating installation\n")
						if ($result || $result>>8);
				logmsg(1,"Plugin $fn returned ".($result>>8)."\n\n");
			}
			else
			{
				$ENV{TARGETDIR}=$targetdir;
				$ENV{PRODUCT} = "NMIS";
				$ENV{VERSION} = $prodversion;
				$ENV{DEBUG} = 1 if ($options{d});
				$ENV{UNATTENDED} = 1 if ($noninteractive);
				$ENV{SIMULATE} = 1 if ($simulate);
				$ENV{LOGFILE} = $logfile if (!$simulate);
				$ENV{CLEANSLATE} = 1 if ($is_initial_install);
				$ENV{PRESEED} = $options{p} if ($options{p}); # preseed file
				for my $extra (keys %extras)
				{
					$ENV{"OPT_".uc($extra)} = $extras{$extra};
				}
				chdir($sourcedir);			# just to be on the safe side...
				exec("$hookdir/$fn") || logdie("exec failed: $!\n");
			}
		}
	}
	closedir(D);
}

sub printBanner
{
	my ($string) = @_;
	print "\n\n++++++++++++++++++++++++++++++++++++++++++++++++++++++
$string
++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\n";
	logmsg(0,"\n###+++\n$string\n###+++\n\n") if (!$simulate);
}

sub logdie
{
	my (@msgs) = @_;
	my $txt = join("",@msgs)."\n";
	logmsg(0,$txt);
	die $txt;
}

# lazy but good enough: we reopen the logfile every time, that way we don't fall afoul
# of hook processes etc.
sub logmsg
{
	my ($level,@msgs) = @_;
	return if ($level > $debug);

	if ($simulate)
	{
		print @msgs;
		print "\n" if ($msgs[-1] !~ /\n$/);
	}
	elsif ($logfile)
	{
		open(LH, ">>$logfile") or die "can't append to $logfile: $!\n";
		print LH @msgs;
		print LH "\n" if ($msgs[-1] !~ /\n$/);
		close(LH);
	}
}

# returns preseed text for the given tag hash
sub gen_preseed
{
	my ($tags) = @_;

	my $response = qq|# preseed file for the NMIS installer

# to be used as input for the installer in unattended preseed mode
# ie. ./nmisX.Y.Z.run -- -p <preseedfile>

# format:
# empty lines and lines starting with # are ignored

# all preseeding lines must start with the question's identifying tag,
# followed by some whitespace, then the seeded answer in double quotes.

# to specify an answer for a question, look up the question
# and tag for the relevant installer interaction, and provide an answer
# on the following tag line.

# for yes-no questions the recognised choices are "Y", "y", "N" and "n".

# the list of seedable questions:\n|;

	for my $tag (sort { $tags->{$a}->{file} cmp $tags->{$b}->{file}
											or $tags->{$a}->{linenr} <=> $tags->{$b}->{linenr} } keys %$tags)
	{
		my $thistag = $tags->{$tag};
		my $shortname = basename($thistag->{file});

		$response .= qq|
# $shortname line $thistag->{linenr}
# question $thistag->{question}
$tag\t"$thistag->{default}"\n|;
	}
	return $response;
}


# returns hash (ref) of seedling tag -> answer
sub load_preseed
{
	my ($fn) = @_;

	my $unhappy = (!-e $fn)? "no such file" :
			(!-f $fn)? "not a plain file" : undef;
	die "cannot read $fn: $unhappy\n" if ($unhappy);

	open(F, $fn) or die "cannot read $fn: $!\n";

	my %answers;

	for my $line (<F>)
	{
		if ($line =~ /^([a-f0-9]{4})\s+"([^"]*)"/)
		{
			$answers{$1} = $2;
		}
	}
	close(F);
	return \%answers;
}

# trivial type/which implementation, saves us file::which or forking off a shell
# args: program name
# returns: full path or undef
sub type_which
{
	my ($needle) = @_;
	for my $maybe (split(/:/, $ENV{PATH}))
	{
		return "$maybe/$needle" if (-x "$maybe/$needle");
	}
	return undef;
}

